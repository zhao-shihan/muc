#pragma once

// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_ALGORITHM_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_ALGORITHM_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 202002L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

/*
 * C++ implementation of timsort
 *
 * ported from Python's and OpenJDK's:
 * - http://svn.python.org/projects/python/trunk/Objects/listobject.c
 * -
 * http://cr.openjdk.java.net/~martin/webrevs/openjdk7/timsort/raw_files/new/src/share/classes/java/util/TimSort.java
 *
 * Copyright (c) 2011 Fuji, Goro (gfx) <gfuji@cpan.org>.
 * Copyright (c) 2019-2024 Morwenn.
 * Copyright (c) 2021 Igor Kushnir <igorkuo@gmail.com>.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#ifndef GFX_TIMSORT_HPP
#define GFX_TIMSORT_HPP

#include <algorithm>
#include <functional>
#include <iterator>
#include <ranges>
#include <utility>
#include <vector>

// Semantic versioning macros

#define GFX_TIMSORT_VERSION_MAJOR 3
#define GFX_TIMSORT_VERSION_MINOR 0
#define GFX_TIMSORT_VERSION_PATCH 0

// Diagnostic selection macros

#if defined(GFX_TIMSORT_ENABLE_ASSERT) || defined(GFX_TIMSORT_ENABLE_AUDIT)
#include <cassert>
#define GFX_TIMSORT_ASSERT(expr) assert(expr)
#else
#define GFX_TIMSORT_ASSERT(expr) ((void)0)
#endif

#ifdef GFX_TIMSORT_ENABLE_AUDIT
#define GFX_TIMSORT_AUDIT(expr) assert(expr)
#else
#define GFX_TIMSORT_AUDIT(expr) ((void)0)
#endif

#ifdef GFX_TIMSORT_ENABLE_LOG
#include <iostream>
#define GFX_TIMSORT_LOG(expr) \
    (std::clog << "# " << __func__ << ": " << expr << std::endl)
#else
#define GFX_TIMSORT_LOG(expr) ((void)0)
#endif

namespace muc {

// ---------------------------------------
// Implementation details
// ---------------------------------------

namespace detail {

template<typename Iterator>
struct run {
    using diff_t = typename std::iterator_traits<Iterator>::difference_type;

    Iterator base;
    diff_t len;

    run(Iterator b, diff_t l) :
        base(b),
        len(l) {}
};

template<typename RandomAccessIterator>
class TimSort {
    using iter_t = RandomAccessIterator;
    using value_t = typename std::iterator_traits<iter_t>::value_type;
    using diff_t = typename std::iterator_traits<iter_t>::difference_type;

    static constexpr int MIN_MERGE = 32;
    static constexpr int MIN_GALLOP = 7;

    int minGallop_ = MIN_GALLOP;
    std::vector<value_t> tmp_; // temp storage for merges
    std::vector<run<RandomAccessIterator>> pending_;

    template<typename Compare, typename Projection>
    static void binarySort(iter_t const lo, iter_t const hi, iter_t start,
                           Compare comp, Projection proj) {
        GFX_TIMSORT_ASSERT(lo <= start);
        GFX_TIMSORT_ASSERT(start <= hi);
        if (start == lo) {
            ++start;
        }
        for (; start < hi; ++start) {
            GFX_TIMSORT_ASSERT(lo <= start);
            auto pos = std::ranges::upper_bound(
                lo, start, std::invoke(proj, *start), comp, proj);
            rotateRight(pos, std::ranges::next(start));
        }
    }

    template<typename Compare, typename Projection>
    static diff_t countRunAndMakeAscending(iter_t const lo, iter_t const hi,
                                           Compare comp, Projection proj) {
        GFX_TIMSORT_ASSERT(lo < hi);

        auto runHi = std::ranges::next(lo);
        if (runHi == hi) {
            return 1;
        }

        if (std::invoke(comp, std::invoke(proj, *runHi),
                        std::invoke(proj, *lo))) { // decreasing
            do {
                ++runHi;
            } while (runHi < hi &&
                     std::invoke(comp, std::invoke(proj, *runHi),
                                 std::invoke(proj, *std::ranges::prev(runHi))));
            std::ranges::reverse(lo, runHi);
        } else { // non-decreasing
            do {
                ++runHi;
            } while (
                runHi < hi &&
                !std::invoke(comp, std::invoke(proj, *runHi),
                             std::invoke(proj, *std::ranges::prev(runHi))));
        }

        return runHi - lo;
    }

    static diff_t minRunLength(diff_t n) {
        GFX_TIMSORT_ASSERT(n >= 0);

        diff_t r = 0;
        while (n >= 2 * MIN_MERGE) {
            r |= (n & 1);
            n >>= 1;
        }
        return n + r;
    }

    void pushRun(iter_t const runBase, diff_t const runLen) {
        pending_.emplace_back(runBase, runLen);
    }

    template<typename Compare, typename Projection>
    void mergeCollapse(Compare comp, Projection proj) {
        while (pending_.size() > 1) {
            diff_t n = pending_.size() - 2;

            if ((n > 0 && pending_[n - 1].len <=
                              pending_[n].len + pending_[n + 1].len) ||
                (n > 1 && pending_[n - 2].len <=
                              pending_[n - 1].len + pending_[n].len)) {
                if (pending_[n - 1].len < pending_[n + 1].len) {
                    --n;
                }
                mergeAt(n, comp, proj);
            } else if (pending_[n].len <= pending_[n + 1].len) {
                mergeAt(n, comp, proj);
            } else {
                break;
            }
        }
    }

    template<typename Compare, typename Projection>
    void mergeForceCollapse(Compare comp, Projection proj) {
        while (pending_.size() > 1) {
            diff_t n = pending_.size() - 2;

            if (n > 0 && pending_[n - 1].len < pending_[n + 1].len) {
                --n;
            }
            mergeAt(n, comp, proj);
        }
    }

    template<typename Compare, typename Projection>
    void mergeAt(diff_t const i, Compare comp, Projection proj) {
        diff_t const stackSize = pending_.size();
        GFX_TIMSORT_ASSERT(stackSize >= 2);
        GFX_TIMSORT_ASSERT(i >= 0);
        GFX_TIMSORT_ASSERT(i == stackSize - 2 || i == stackSize - 3);

        auto base1 = pending_[i].base;
        auto len1 = pending_[i].len;
        auto base2 = pending_[i + 1].base;
        auto len2 = pending_[i + 1].len;

        pending_[i].len = len1 + len2;

        if (i == stackSize - 3) {
            pending_[i + 1] = pending_[i + 2];
        }

        pending_.pop_back();

        mergeConsecutiveRuns(base1, len1, base2, len2, std::move(comp),
                             std::move(proj));
    }

    template<typename Compare, typename Projection>
    void mergeConsecutiveRuns(iter_t base1, diff_t len1, iter_t base2,
                              diff_t len2, Compare comp, Projection proj) {
        GFX_TIMSORT_ASSERT(len1 > 0);
        GFX_TIMSORT_ASSERT(len2 > 0);
        GFX_TIMSORT_ASSERT(base1 + len1 == base2);

        auto k =
            gallopRight(std::invoke(proj, *base2), base1, len1, 0, comp, proj);
        GFX_TIMSORT_ASSERT(k >= 0);

        base1 += k;
        len1 -= k;

        if (len1 == 0) {
            return;
        }

        len2 = gallopLeft(std::invoke(proj, base1[len1 - 1]), base2, len2,
                          len2 - 1, comp, proj);
        GFX_TIMSORT_ASSERT(len2 >= 0);
        if (len2 == 0) {
            return;
        }

        if (len1 <= len2) {
            mergeLo(base1, len1, base2, len2, comp, proj);
        } else {
            mergeHi(base1, len1, base2, len2, comp, proj);
        }
    }

    template<typename T, typename Iter, typename Compare, typename Projection>
    static diff_t gallopLeft(T const& key, Iter const base, diff_t const len,
                             diff_t const hint, Compare comp, Projection proj) {
        GFX_TIMSORT_ASSERT(len > 0);
        GFX_TIMSORT_ASSERT(hint >= 0);
        GFX_TIMSORT_ASSERT(hint < len);

        diff_t lastOfs = 0;
        diff_t ofs = 1;

        if (std::invoke(comp, std::invoke(proj, base[hint]), key)) {
            auto maxOfs = len - hint;
            while (
                ofs < maxOfs &&
                std::invoke(comp, std::invoke(proj, base[hint + ofs]), key)) {
                lastOfs = ofs;
                ofs = (ofs << 1) + 1;

                if (ofs <= 0) { // int overflow
                    ofs = maxOfs;
                }
            }
            if (ofs > maxOfs) {
                ofs = maxOfs;
            }

            lastOfs += hint;
            ofs += hint;
        } else {
            diff_t const maxOfs = hint + 1;
            while (
                ofs < maxOfs &&
                !std::invoke(comp, std::invoke(proj, base[hint - ofs]), key)) {
                lastOfs = ofs;
                ofs = (ofs << 1) + 1;

                if (ofs <= 0) {
                    ofs = maxOfs;
                }
            }
            if (ofs > maxOfs) {
                ofs = maxOfs;
            }

            diff_t const tmp = lastOfs;
            lastOfs = hint - ofs;
            ofs = hint - tmp;
        }
        GFX_TIMSORT_ASSERT(-1 <= lastOfs);
        GFX_TIMSORT_ASSERT(lastOfs < ofs);
        GFX_TIMSORT_ASSERT(ofs <= len);

        return std::ranges::lower_bound(base + (lastOfs + 1), base + ofs, key,
                                        comp, proj) -
               base;
    }

    template<typename T, typename Iter, typename Compare, typename Projection>
    static diff_t gallopRight(T const& key, Iter const base, diff_t const len,
                              diff_t const hint, Compare comp,
                              Projection proj) {
        GFX_TIMSORT_ASSERT(len > 0);
        GFX_TIMSORT_ASSERT(hint >= 0);
        GFX_TIMSORT_ASSERT(hint < len);

        diff_t ofs = 1;
        diff_t lastOfs = 0;

        if (std::invoke(comp, key, std::invoke(proj, base[hint]))) {
            diff_t const maxOfs = hint + 1;
            while (
                ofs < maxOfs &&
                std::invoke(comp, key, std::invoke(proj, base[hint - ofs]))) {
                lastOfs = ofs;
                ofs = (ofs << 1) + 1;

                if (ofs <= 0) {
                    ofs = maxOfs;
                }
            }
            if (ofs > maxOfs) {
                ofs = maxOfs;
            }

            diff_t const tmp = lastOfs;
            lastOfs = hint - ofs;
            ofs = hint - tmp;
        } else {
            diff_t const maxOfs = len - hint;
            while (
                ofs < maxOfs &&
                !std::invoke(comp, key, std::invoke(proj, base[hint + ofs]))) {
                lastOfs = ofs;
                ofs = (ofs << 1) + 1;

                if (ofs <= 0) { // int overflow
                    ofs = maxOfs;
                }
            }
            if (ofs > maxOfs) {
                ofs = maxOfs;
            }

            lastOfs += hint;
            ofs += hint;
        }
        GFX_TIMSORT_ASSERT(-1 <= lastOfs);
        GFX_TIMSORT_ASSERT(lastOfs < ofs);
        GFX_TIMSORT_ASSERT(ofs <= len);

        return std::ranges::upper_bound(base + (lastOfs + 1), base + ofs, key,
                                        comp, proj) -
               base;
    }

    static void rotateLeft(iter_t first, iter_t last) {
        auto tmp = std::ranges::iter_move(first);
        auto [_, last_1] =
            std::ranges::move(std::ranges::next(first), last, first);
        *last_1 = std::move(tmp);
    }

    static void rotateRight(iter_t first, iter_t last) {
        auto last_1 = std::ranges::prev(last);
        auto tmp = std::ranges::iter_move(last_1);
        std::ranges::move_backward(first, last_1, last);
        *first = std::move(tmp);
    }

    template<typename Compare, typename Projection>
    void mergeLo(iter_t const base1, diff_t len1, iter_t const base2,
                 diff_t len2, Compare comp, Projection proj) {
        GFX_TIMSORT_ASSERT(len1 > 0);
        GFX_TIMSORT_ASSERT(len2 > 0);
        GFX_TIMSORT_ASSERT(base1 + len1 == base2);

        if (len1 == 1) {
            return rotateLeft(base1, base2 + len2);
        }
        if (len2 == 1) {
            return rotateRight(base1, base2 + len2);
        }

        move_to_tmp(base1, len1);

        auto cursor1 = tmp_.begin();
        auto cursor2 = base2;
        auto dest = base1;

        *dest = std::ranges::iter_move(cursor2);
        ++cursor2;
        ++dest;
        --len2;

        int minGallop(minGallop_);

        // outer:
        while (true) {
            diff_t count1 = 0;
            diff_t count2 = 0;

            do {
                GFX_TIMSORT_ASSERT(len1 > 1);
                GFX_TIMSORT_ASSERT(len2 > 0);

                if (std::invoke(comp, std::invoke(proj, *cursor2),
                                std::invoke(proj, *cursor1))) {
                    *dest = std::ranges::iter_move(cursor2);
                    ++cursor2;
                    ++dest;
                    ++count2;
                    count1 = 0;
                    if (--len2 == 0) {
                        goto epilogue;
                    }
                } else {
                    *dest = std::ranges::iter_move(cursor1);
                    ++cursor1;
                    ++dest;
                    ++count1;
                    count2 = 0;
                    if (--len1 == 1) {
                        goto epilogue;
                    }
                }
            } while ((count1 | count2) < minGallop);

            do {
                GFX_TIMSORT_ASSERT(len1 > 1);
                GFX_TIMSORT_ASSERT(len2 > 0);

                count1 = gallopRight(std::invoke(proj, *cursor2), cursor1, len1,
                                     0, comp, proj);
                if (count1 != 0) {
                    std::ranges::move_backward(cursor1, cursor1 + count1,
                                               dest + count1);
                    dest += count1;
                    cursor1 += count1;
                    len1 -= count1;

                    if (len1 <= 1) {
                        goto epilogue;
                    }
                }
                *dest = std::ranges::iter_move(cursor2);
                ++cursor2;
                ++dest;
                if (--len2 == 0) {
                    goto epilogue;
                }

                count2 = gallopLeft(std::invoke(proj, *cursor1), cursor2, len2,
                                    0, comp, proj);
                if (count2 != 0) {
                    std::ranges::move(cursor2, cursor2 + count2, dest);
                    dest += count2;
                    cursor2 += count2;
                    len2 -= count2;
                    if (len2 == 0) {
                        goto epilogue;
                    }
                }
                *dest = std::ranges::iter_move(cursor1);
                ++cursor1;
                ++dest;
                if (--len1 == 1) {
                    goto epilogue;
                }

                --minGallop;
            } while ((count1 >= MIN_GALLOP) | (count2 >= MIN_GALLOP));

            if (minGallop < 0) {
                minGallop = 0;
            }
            minGallop += 2;
        } // end of "outer" loop

epilogue: // merge what is left from either cursor1 or cursor2

        minGallop_ = (std::min)(minGallop, 1);

        if (len1 == 1) {
            GFX_TIMSORT_ASSERT(len2 > 0);
            std::ranges::move(cursor2, cursor2 + len2, dest);
            *(dest + len2) = std::ranges::iter_move(cursor1);
        } else {
            GFX_TIMSORT_ASSERT(
                len1 != 0 &&
                "Comparison function violates its general contract");
            GFX_TIMSORT_ASSERT(len2 == 0);
            GFX_TIMSORT_ASSERT(len1 > 1);
            std::ranges::move(cursor1, cursor1 + len1, dest);
        }
    }

    template<typename Compare, typename Projection>
    void mergeHi(iter_t const base1, diff_t len1, iter_t const base2,
                 diff_t len2, Compare comp, Projection proj) {
        GFX_TIMSORT_ASSERT(len1 > 0);
        GFX_TIMSORT_ASSERT(len2 > 0);
        GFX_TIMSORT_ASSERT(base1 + len1 == base2);

        if (len1 == 1) {
            return rotateLeft(base1, base2 + len2);
        }
        if (len2 == 1) {
            return rotateRight(base1, base2 + len2);
        }

        move_to_tmp(base2, len2);

        auto cursor1 = base1 + len1;
        auto cursor2 = tmp_.begin() + (len2 - 1);
        auto dest = base2 + (len2 - 1);

        *dest = std::ranges::iter_move(--cursor1);
        --dest;
        --len1;

        int minGallop(minGallop_);

        // outer:
        while (true) {
            diff_t count1 = 0;
            diff_t count2 = 0;

            // The next loop is a hot path of the algorithm, so we decrement
            // eagerly the cursor so that it always points directly to the value
            // to compare, but we have to implement some trickier logic to make
            // sure that it points to the next value again by the end of said
            // loop
            --cursor1;

            do {
                GFX_TIMSORT_ASSERT(len1 > 0);
                GFX_TIMSORT_ASSERT(len2 > 1);

                if (std::invoke(comp, std::invoke(proj, *cursor2),
                                std::invoke(proj, *cursor1))) {
                    *dest = std::ranges::iter_move(cursor1);
                    --dest;
                    ++count1;
                    count2 = 0;
                    if (--len1 == 0) {
                        goto epilogue;
                    }
                    --cursor1;
                } else {
                    *dest = std::ranges::iter_move(cursor2);
                    --cursor2;
                    --dest;
                    ++count2;
                    count1 = 0;
                    if (--len2 == 1) {
                        ++cursor1; // See comment before the loop
                        goto epilogue;
                    }
                }
            } while ((count1 | count2) < minGallop);
            ++cursor1; // See comment before the loop

            do {
                GFX_TIMSORT_ASSERT(len1 > 0);
                GFX_TIMSORT_ASSERT(len2 > 1);

                count1 = len1 - gallopRight(std::invoke(proj, *cursor2), base1,
                                            len1, len1 - 1, comp, proj);
                if (count1 != 0) {
                    dest -= count1;
                    cursor1 -= count1;
                    len1 -= count1;
                    std::ranges::move_backward(cursor1, cursor1 + count1,
                                               dest + (1 + count1));

                    if (len1 == 0) {
                        goto epilogue;
                    }
                }
                *dest = std::ranges::iter_move(cursor2);
                --cursor2;
                --dest;
                if (--len2 == 1) {
                    goto epilogue;
                }

                count2 =
                    len2 -
                    gallopLeft(std::invoke(proj, *std::ranges::prev(cursor1)),
                               tmp_.begin(), len2, len2 - 1, comp, proj);
                if (count2 != 0) {
                    dest -= count2;
                    cursor2 -= count2;
                    len2 -= count2;
                    std::ranges::move(std::ranges::next(cursor2),
                                      cursor2 + (1 + count2),
                                      std::ranges::next(dest));
                    if (len2 <= 1) {
                        goto epilogue;
                    }
                }
                *dest = std::ranges::iter_move(--cursor1);
                --dest;
                if (--len1 == 0) {
                    goto epilogue;
                }

                --minGallop;
            } while ((count1 >= MIN_GALLOP) | (count2 >= MIN_GALLOP));

            if (minGallop < 0) {
                minGallop = 0;
            }
            minGallop += 2;
        } // end of "outer" loop

epilogue: // merge what is left from either cursor1 or cursor2

        minGallop_ = (std::min)(minGallop, 1);

        if (len2 == 1) {
            GFX_TIMSORT_ASSERT(len1 > 0);
            dest -= len1;
            std::ranges::move_backward(cursor1 - len1, cursor1,
                                       dest + (1 + len1));
            *dest = std::ranges::iter_move(cursor2);
        } else {
            GFX_TIMSORT_ASSERT(
                len2 != 0 &&
                "Comparison function violates its general contract");
            GFX_TIMSORT_ASSERT(len1 == 0);
            GFX_TIMSORT_ASSERT(len2 > 1);
            std::ranges::move(tmp_.begin(), tmp_.begin() + len2,
                              dest - (len2 - 1));
        }
    }

    void move_to_tmp(iter_t const begin, diff_t len) {
        tmp_.assign(std::make_move_iterator(begin),
                    std::make_move_iterator(begin + len));
    }

public:
    template<typename Compare, typename Projection>
    static void merge(iter_t const lo, iter_t const mid, iter_t const hi,
                      Compare comp, Projection proj) {
        GFX_TIMSORT_ASSERT(lo <= mid);
        GFX_TIMSORT_ASSERT(mid <= hi);

        if (lo == mid || mid == hi) {
            return; // nothing to do
        }

        TimSort ts;
        ts.mergeConsecutiveRuns(lo, mid - lo, mid, hi - mid, std::move(comp),
                                std::move(proj));

        GFX_TIMSORT_LOG("1st size: " << (mid - lo)
                                     << "; 2nd size: " << (hi - mid)
                                     << "; tmp_.size(): " << ts.tmp_.size());
    }

    template<typename Compare, typename Projection>
    static void sort(iter_t const lo, iter_t const hi, Compare comp,
                     Projection proj) {
        GFX_TIMSORT_ASSERT(lo <= hi);

        auto nRemaining = hi - lo;
        if (nRemaining < 2) {
            return; // nothing to do
        }

        if (nRemaining < MIN_MERGE) {
            auto initRunLen = countRunAndMakeAscending(lo, hi, comp, proj);
            GFX_TIMSORT_LOG("initRunLen: " << initRunLen);
            binarySort(lo, hi, lo + initRunLen, comp, proj);
            return;
        }

        TimSort ts;
        auto minRun = minRunLength(nRemaining);
        auto cur = lo;
        do {
            auto runLen = countRunAndMakeAscending(cur, hi, comp, proj);

            if (runLen < minRun) {
                auto force = (std::min)(nRemaining, minRun);
                binarySort(cur, cur + force, cur + runLen, comp, proj);
                runLen = force;
            }

            ts.pushRun(cur, runLen);
            ts.mergeCollapse(comp, proj);

            cur += runLen;
            nRemaining -= runLen;
        } while (nRemaining != 0);

        GFX_TIMSORT_ASSERT(cur == hi);
        ts.mergeForceCollapse(comp, proj);
        GFX_TIMSORT_ASSERT(ts.pending_.size() == 1);

        GFX_TIMSORT_LOG("size: " << (hi - lo)
                                 << " tmp_.size(): " << ts.tmp_.size()
                                 << " pending_.size(): " << ts.pending_.size());
    }
};

} // namespace detail

// ---------------------------------------
// Public interface implementation
// ---------------------------------------

/**
 * Stably merges two consecutive sorted ranges [first, middle) and [middle,
 * last) into one sorted range [first, last) with a comparison function and a
 * projection function.
 */
template<
    std::random_access_iterator Iterator, std::sentinel_for<Iterator> Sentinel,
    typename Compare = std::ranges::less, typename Projection = std::identity>
    requires std::sortable<Iterator, Compare, Projection>
auto timmerge(Iterator first, Iterator middle, Sentinel last, Compare comp = {},
              Projection proj = {}) -> Iterator {
    auto last_it = std::ranges::next(first, last);
    GFX_TIMSORT_AUDIT(std::ranges::is_sorted(first, middle, comp, proj) &&
                      "Precondition");
    GFX_TIMSORT_AUDIT(std::ranges::is_sorted(middle, last_it, comp, proj) &&
                      "Precondition");
    detail::TimSort<Iterator>::merge(first, middle, last_it, comp, proj);
    GFX_TIMSORT_AUDIT(std::ranges::is_sorted(first, last_it, comp, proj) &&
                      "Postcondition");
    return last_it;
}

/**
 * Stably merges two sorted halves [first, middle) and [middle, last) of a range
 * into one sorted range [first, last) with a comparison function and a
 * projection function.
 */
template<std::ranges::random_access_range Range,
         typename Compare = std::ranges::less,
         typename Projection = std::identity>
    requires std::sortable<std::ranges::iterator_t<Range>, Compare, Projection>
auto timmerge(Range&& range, std::ranges::iterator_t<Range> middle,
              Compare comp = {},
              Projection proj = {}) -> std::ranges::borrowed_iterator_t<Range> {
    return muc::timmerge(std::begin(range), middle, std::end(range), comp,
                         proj);
}

/**
 * Stably sorts a range with a comparison function and a projection function.
 */
template<
    std::random_access_iterator Iterator, std::sentinel_for<Iterator> Sentinel,
    typename Compare = std::ranges::less, typename Projection = std::identity>
    requires std::sortable<Iterator, Compare, Projection>
auto timsort(Iterator first, Sentinel last, Compare comp = {},
             Projection proj = {}) -> Iterator {
    auto last_it = std::ranges::next(first, last);
    detail::TimSort<Iterator>::sort(first, last_it, comp, proj);
    GFX_TIMSORT_AUDIT(std::ranges::is_sorted(first, last_it, comp, proj) &&
                      "Postcondition");
    return last_it;
}

/**
 * Stably sorts a range with a comparison function and a projection function.
 */
template<std::ranges::random_access_range Range,
         typename Compare = std::ranges::less,
         typename Projection = std::identity>
    requires std::sortable<std::ranges::iterator_t<Range>, Compare, Projection>
auto timsort(Range&& range, Compare comp = {},
             Projection proj = {}) -> std::ranges::borrowed_iterator_t<Range> {
    return muc::timsort(std::begin(range), std::end(range), comp, proj);
}

} // namespace muc

#undef GFX_TIMSORT_ENABLE_ASSERT
#undef GFX_TIMSORT_ASSERT
#undef GFX_TIMSORT_ENABLE_AUDIT
#undef GFX_TIMSORT_AUDIT
#undef GFX_TIMSORT_ENABLE_LOG
#undef GFX_TIMSORT_LOG

#endif // GFX_TIMSORT_HPP
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_ARRAY_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_ARRAY_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <array>
#include <complex>
#include <cstdint>

namespace muc {

template<typename T>
using array2 = std::array<T, 2>;
template<typename T>
using array3 = std::array<T, 3>;
template<typename T>
using array4 = std::array<T, 4>;

template<std::size_t N>
using arrayi = std::array<int, N>;
template<std::size_t N>
using arrayl = std::array<long, N>;
template<std::size_t N>
using arrayll = std::array<long long, N>;
template<std::size_t N>
using arrayu = std::array<unsigned, N>;
template<std::size_t N>
using arrayul = std::array<unsigned long, N>;
template<std::size_t N>
using arrayull = std::array<unsigned long long, N>;
template<std::size_t N>
using arrayi8 = std::array<std::int8_t, N>;
template<std::size_t N>
using arrayi16 = std::array<std::int16_t, N>;
template<std::size_t N>
using arrayi32 = std::array<std::int32_t, N>;
template<std::size_t N>
using arrayi64 = std::array<std::int64_t, N>;
template<std::size_t N>
using arrayu8 = std::array<std::uint8_t, N>;
template<std::size_t N>
using arrayu16 = std::array<std::uint16_t, N>;
template<std::size_t N>
using arrayu32 = std::array<std::uint32_t, N>;
template<std::size_t N>
using arrayu64 = std::array<std::uint64_t, N>;
template<std::size_t N>
using arrayf = std::array<float, N>;
template<std::size_t N>
using arrayd = std::array<double, N>;
template<std::size_t N>
using arrayld = std::array<long double, N>;
template<std::size_t N>
using arraycf = std::array<std::complex<float>, N>;
template<std::size_t N>
using arraycd = std::array<std::complex<double>, N>;
template<std::size_t N>
using arraycld = std::array<std::complex<long double>, N>;

using array2i = arrayi<2>;
using array2l = arrayl<2>;
using array2ll = arrayll<2>;
using array2u = arrayu<2>;
using array2ul = arrayul<2>;
using array2ull = arrayull<2>;
using array2i8 = arrayi8<2>;
using array2i16 = arrayi16<2>;
using array2i32 = arrayi32<2>;
using array2i64 = arrayi64<2>;
using array2u8 = arrayu8<2>;
using array2u16 = arrayu16<2>;
using array2u32 = arrayu32<2>;
using array2u64 = arrayu64<2>;
using array2f = arrayf<2>;
using array2d = arrayd<2>;
using array2ld = arrayld<2>;
using array2cf = arraycf<2>;
using array2cd = arraycd<2>;
using array2cld = arraycld<2>;

using array3i = arrayi<3>;
using array3l = arrayl<3>;
using array3ll = arrayll<3>;
using array3u = arrayu<3>;
using array3ul = arrayul<3>;
using array3ull = arrayull<3>;
using array3i8 = arrayi8<3>;
using array3i16 = arrayi16<3>;
using array3i32 = arrayi32<3>;
using array3i64 = arrayi64<3>;
using array3u8 = arrayu8<3>;
using array3u16 = arrayu16<3>;
using array3u32 = arrayu32<3>;
using array3u64 = arrayu64<3>;
using array3f = arrayf<3>;
using array3d = arrayd<3>;
using array3ld = arrayld<3>;
using array3cf = arraycf<3>;
using array3cd = arraycd<3>;
using array3cld = arraycld<3>;

using array4i = arrayi<4>;
using array4l = arrayl<4>;
using array4ll = arrayll<4>;
using array4u = arrayu<4>;
using array4ul = arrayul<4>;
using array4ull = arrayull<4>;
using array4i8 = arrayi8<4>;
using array4i16 = arrayi16<4>;
using array4i32 = arrayi32<4>;
using array4i64 = arrayi64<4>;
using array4u8 = arrayu8<4>;
using array4u16 = arrayu16<4>;
using array4u32 = arrayu32<4>;
using array4u64 = arrayu64<4>;
using array4f = arrayf<4>;
using array4d = arrayd<4>;
using array4ld = arrayld<4>;
using array4cf = arraycf<4>;
using array4cd = arraycd<4>;
using array4cld = arraycld<4>;

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_BIT_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_BIT_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

#if __cplusplus >= 202002L // >= C++20
#include <bit>
#else // <= C++17
#include <cstring>
#endif

namespace muc {

#if __cplusplus >= 202002L // >= C++20

/// @brief A backport of std::bit_cast. Obtain a value of type To by
/// reinterpreting the object representation of From. Every bit in the value
/// representation of the returned To object is equal to the corresponding bit
/// in the object representation of from. The values of padding bits in the
/// returned To object are unspecified.
/// @note This implementation in C++17 additionally requires destination type to
/// be trivially constructible.
/// @tparam To destination type
/// @tparam From source type
/// @param src the source of bits for the return value
/// @return An object of type To whose value representation is as described
/// above.
template<typename To, typename From>
constexpr auto bit_cast(const From& src) noexcept -> To {
    return std::bit_cast<To>(src);
}

#else // <= C++17

/// @brief A backport of std::bit_cast. Obtain a value of type To by
/// reinterpreting the object representation of From. Every bit in the value
/// representation of the returned To object is equal to the corresponding bit
/// in the object representation of from. The values of padding bits in the
/// returned To object are unspecified.
/// @note This implementation in C++17 additionally requires destination type to
/// be trivially constructible.
/// @tparam To destination type
/// @tparam From source type
/// @param src the source of bits for the return value
/// @return An object of type To whose value representation is as described
/// above.
template<typename To, typename From>
auto bit_cast(const From& src) noexcept
    -> std::enable_if_t<sizeof(To) == sizeof(From) and
                            std::is_trivially_copyable_v<From> and
                            std::is_trivially_copyable_v<To>,
                        To> {
    static_assert(std::is_trivially_constructible_v<To>,
                  "This implementation additionally requires destination type "
                  "to be trivially constructible");
    To dst;
    std::memcpy(&dst, &src, sizeof(To));
    return dst;
}

#endif

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <climits>
#include <cstddef>

namespace muc {

template<typename T>
inline constexpr std::size_t bit_size{CHAR_BIT * sizeof(T)};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <algorithm>
#include <array>
#include <cstddef>
#include <type_traits>

namespace muc {

/// @brief Reverses the bytes in the given integer value.
/// @tparam T value type
/// @param value integer value
/// @return An integer value of type T whose object representation comprises the
/// bytes of that of value in reversed order.
template<typename T, std::enable_if_t<std::is_integral_v<T>, bool> = true>
auto byteswap(T value) noexcept -> T {
    static_assert(std::has_unique_object_representations_v<T>,
                  "T may not have padding bits");
    auto bit{muc::bit_cast<std::array<std::byte, sizeof(T)>>(value)};
    std::reverse(bit.begin(), bit.end());
    return muc::bit_cast<T>(bit);
}

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc::impl {

template<typename T>
struct is_really_unsigned_integral :
    std::bool_constant<std::is_unsigned_v<T> and not std::is_same_v<T, bool> and
                       not std::is_same_v<T, char> and
#if __cplusplus >= 202002L
                       not std::is_same_v<T, char8_t> and
#endif
                       not std::is_same_v<T, char16_t> and
                       not std::is_same_v<T, char32_t> and
                       not std::is_same_v<T, wchar_t>> {
};

template<typename T>
inline constexpr auto is_really_unsigned_integral_v{
    is_really_unsigned_integral<T>::value};

} // namespace muc::impl

#include <type_traits>

namespace muc {

/// @brief Checks if x is an integral power of two. This participates in
/// overload resolution only if T is an unsigned integer type (that is, unsigned
/// char, unsigned short, unsigned int, unsigned long, unsigned long long, or an
/// extended unsigned integer type).
/// @tparam T unsigned integer type
/// @param x value of unsigned integer type
/// @return true if x is an integral power of two; otherwise false.
template<typename T,
         std::enable_if_t<impl::is_really_unsigned_integral_v<T>, bool> = true>
constexpr auto has_single_bit(T x) noexcept -> bool {
    return x && !(x & (x - 1u));
}

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <limits>
#include <type_traits>

namespace muc {

/// @brief Computes the result of bitwise left-rotating the value of x by s
/// positions. This overload participates in overload resolution only if T is an
/// unsigned integer type (that is, unsigned char, unsigned short, unsigned int,
/// unsigned long, unsigned long long, or an extended unsigned integer type).
/// @tparam T unsigned integer type
/// @param x value of unsigned integer type
/// @param s number of positions to shift
/// @return The result of bitwise left-rotating x by s positions.
template<typename T,
         std::enable_if_t<impl::is_really_unsigned_integral_v<T>, bool> = true>
[[nodiscard]] constexpr auto rotl(T x, int s) noexcept -> T {
    constexpr auto n{std::numeric_limits<T>::digits};
    const auto r{s % n};
    if (r > 0) {
        return (x << r) | (x >> (n - r));
    }
    if (r < 0) {
        return (x >> -r) | (x << (n + r));
    }
    return x; // r == 0
}

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <limits>
#include <type_traits>

namespace muc {

/// @brief Computes the result of bitwise right-rotating the value of x by s
/// positions. This overload participates in overload resolution only if T is an
/// unsigned integer type (that is, unsigned char, unsigned short, unsigned int,
/// unsigned long, unsigned long long, or an extended unsigned integer type).
/// @tparam T unsigned integer type
/// @param x value of unsigned integer type
/// @param s number of positions to shift
/// @return The result of bitwise right-rotating x by s positions.
template<typename T,
         std::enable_if_t<impl::is_really_unsigned_integral_v<T>, bool> = true>
[[nodiscard]] constexpr auto rotr(T x, int s) noexcept -> T {
    constexpr auto n{std::numeric_limits<T>::digits};
    const auto r{s % n};
    if (r > 0) {
        return (x >> r) | (x << (n - r));
    }
    if (r < 0) {
        return (x << -r) | (x >> (n + r));
    }
    return x; // r == 0
}

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_CETA_STRING_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_CETA_STRING_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 202002L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <algorithm>
#include <cstddef>
#include <string>
#include <string_view>

namespace muc {

/// @brief ceta_string for 'consteval, template applicable string'
/// @tparam N size of the string (include end '\0')
/// @note Should always be constructed from string literals or nullptr.
template<std::size_t N>
struct ceta_string {
private:
    using cstring = const char[N];

public:
    consteval ceta_string(const cstring& string) :
        m_private_string_data{string} {}

    constexpr auto c_str() const -> const auto& {
        return m_private_string_data.m_data;
    }

    constexpr auto sv() const -> std::string_view {
        return {c_str(), N - 1};
    }

    auto s() const -> std::string {
        return {c_str(), N - 1};
    }

    constexpr operator const cstring&() const {
        return c_str();
    }

    constexpr operator std::string_view() const {
        return sv();
    }

    explicit operator std::string() const {
        return s();
    }

    constexpr auto operator==(const char* rhs) const -> bool {
        return sv() == std::string_view{rhs};
    }

    constexpr auto operator<=>(const char* rhs) const -> auto {
        return sv() <=> std::string_view{rhs};
    }

    constexpr auto operator==(std::nullptr_t) const -> bool {
        return not has_value();
    }

    constexpr operator bool() const {
        return has_value();
    }

    static constexpr auto has_value() -> bool {
        return true;
    }

private:
    struct private_string_data {
        consteval private_string_data(const cstring& string) :
            m_data{} {
            std::ranges::copy(string, m_data);
        }

        char m_data[N];
    };

public:
    const private_string_data m_private_string_data; // private by semantic
};

template<std::size_t N>
ceta_string(const char (&)[N]) -> ceta_string<N>;

template<>
struct ceta_string<0> {
    consteval ceta_string(std::nullptr_t) {}

    constexpr auto operator=(const ceta_string&) -> ceta_string& = delete;

    constexpr operator bool() const {
        return has_value();
    }

    constexpr auto operator==(std::nullptr_t) const -> bool {
        return not has_value();
    }

    static constexpr auto has_value() -> bool {
        return false;
    }
};

ceta_string() -> ceta_string<0>;

ceta_string(std::nullptr_t) -> ceta_string<0>;

template<std::size_t M, std::size_t N>
constexpr auto operator==(const ceta_string<M>& lhs,
                          const ceta_string<N>& rhs) -> bool {
    return lhs.sv() == rhs.sv();
}

template<std::size_t M, std::size_t N>
constexpr auto operator<=>(const ceta_string<M>& lhs,
                           const ceta_string<N>& rhs) -> auto {
    return lhs.sv() <=> rhs.sv();
}

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_CONCEPTS_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_CONCEPTS_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 202002L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

template<typename T>
concept arithmetic = std::is_arithmetic_v<T>;

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <concepts>
#include <utility>

namespace muc {

template<typename B>
concept boolean_testable = requires(B&& b) {
    requires std::convertible_to<B, bool>;
    { not std::forward<B>(b) } -> std::convertible_to<bool>;
};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <concepts>

namespace muc {

/// @brief C++ named requirements: MoveAssignable. This is more strict than
/// std::is_move_assignable because it does check the type of the result of the
/// assignment (which, for a CopyAssignable type, must be an lvalue of type T).
/// See also: https://en.cppreference.com/w/cpp/named_req/move_assignable
template<typename T>
concept move_assignable = std::assignable_from<T&, T&&>;

template<typename T>
concept noexcept_move_assignable =
    std::assignable_from<T&, T&&> and std::is_nothrow_move_assignable_v<T>;

} // namespace muc

#include <concepts>

namespace muc {

/// @brief C++ named requirements: CopyAssignable. This is more strict than
/// std::is_copy_assignable because it does check the type of the result of the
/// assignment (which, for a CopyAssignable type, must be an lvalue of type T).
/// See also: https://en.cppreference.com/w/cpp/named_req/copy_assignable
template<typename T>
concept copy_assignable =
    move_assignable<T> and std::assignable_from<T&, T&> and
    std::assignable_from<T&, const T&> and std::assignable_from<T&, const T&&>;

template<typename T>
concept noexcept_copy_assignable =
    noexcept_move_assignable<T> and std::assignable_from<T&, T&> and
    std::assignable_from<T&, const T&> and
    std::assignable_from<T&, const T&&> and
    std::is_nothrow_move_assignable_v<T>;

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

template<typename T>
concept fundamental = std::is_fundamental_v<T>;

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>
#include <utility>

namespace muc::impl {

template<typename, typename, typename = void>
struct has_binary_arithmetic_with : std::false_type {};

template<typename T, typename U>
struct has_binary_arithmetic_with<
    T, U,
    std::void_t<
        // T +/- T
        decltype(std::declval<const T&>() + std::declval<const T&>()),
        decltype(std::declval<const T&>() - std::declval<const T&>()),
        // k * T
        /* decltype(+std::declval<const T&>()), */
        decltype(-std::declval<const T&>()),
        /* decltype(1 * std::declval<const T&>()),
        decltype(std::declval<const T&>() * 1),
        decltype(std::declval<const T&>() / 1), */
        // U +/- U
        decltype(std::declval<const U&>() + std::declval<const U&>()),
        decltype(std::declval<const U&>() - std::declval<const U&>()),
        // k * U
        /* decltype(+std::declval<const U&>()), */
        decltype(-std::declval<const U&>()),
        /* decltype(1 * std::declval<const U&>()),
        decltype(std::declval<const U&>() * 1),
        decltype(std::declval<const U&>() / 1), */
        // T +/- U
        decltype(std::declval<const T&>() + std::declval<const U&>()),
        decltype(std::declval<const T&>() - std::declval<const U&>()),
        // U +/- T
        decltype(std::declval<const U&>() + std::declval<const T&>()),
        decltype(std::declval<const U&>() - std::declval<const T&>()),
        // T x= X
        decltype(std::declval<T&>() += std::declval<const U&>()),
        decltype(std::declval<T&>() -= std::declval<const U&>())//,
        /* decltype(std::declval<T&>() *= 1), decltype(std::declval<T&>() /= 1) */>> :
    std::true_type {};

template<typename T, typename U>
inline constexpr bool has_binary_arithmetic_with_v{
    has_binary_arithmetic_with<T, U>::value};

} // namespace muc::impl

#include <type_traits>
#include <utility>

namespace muc {

template<typename T>
struct is_general_arithmetic :
    std::bool_constant<std::is_default_constructible_v<T> and
                       impl::has_binary_arithmetic_with_v<T, T> and
                       impl::has_binary_arithmetic_with_v<
                           T, decltype(std::declval<const T&>() +
                                       std::declval<const T&>())> and
                       impl::has_binary_arithmetic_with_v<
                           T, decltype(std::declval<const T&>() -
                                       std::declval<const T&>())> /* and
                       impl::has_binary_arithmetic_with_v<
                           T, decltype(1 * std::declval<const T&>())> and
                       impl::has_binary_arithmetic_with_v<
                           T, decltype(std::declval<const T&>() * 1)> and
                       impl::has_binary_arithmetic_with_v<
                           T, decltype(std::declval<const T&>() / 1)> */> {};

template<typename T>
inline constexpr bool is_general_arithmetic_v{is_general_arithmetic<T>::value};

} // namespace muc

namespace muc {

template<typename T>
concept general_arithmetic = is_general_arithmetic_v<T>;

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

template<template<typename...> typename, typename>
struct is_template_of : std::false_type {};

template<template<typename...> typename Template, typename... Args>
struct is_template_of<Template, Template<Args...>> : std::true_type {};

template<template<typename...> typename Template, typename T>
inline constexpr bool is_template_of_v{is_template_of<Template, T>::value};

} // namespace muc

namespace muc {

template<typename T, template<typename...> typename Template>
concept instantiated_from = is_template_of_v<Template, T>;

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_CTYPE_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_CTYPE_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <cctype>

namespace muc {

inline auto isalnum(char c) -> bool {
    return std::isalnum(static_cast<unsigned char>(c));
}

inline auto isalpha(char c) -> bool {
    return std::isalpha(static_cast<unsigned char>(c));
}

inline auto iscntrl(char c) -> bool {
    return std::iscntrl(static_cast<unsigned char>(c));
}

inline auto isdigit(char c) -> bool {
    return std::isdigit(static_cast<unsigned char>(c));
}

inline auto isgraph(char c) -> bool {
    return std::isgraph(static_cast<unsigned char>(c));
}

inline auto islower(char c) -> bool {
    return std::islower(static_cast<unsigned char>(c));
}

inline auto isprint(char c) -> bool {
    return std::isprint(static_cast<unsigned char>(c));
}

inline auto ispunct(char c) -> bool {
    return std::ispunct(static_cast<unsigned char>(c));
}

inline auto isspace(char c) -> bool {
    return std::isspace(static_cast<unsigned char>(c));
}

inline auto isupper(char c) -> bool {
    return std::isupper(static_cast<unsigned char>(c));
}

inline auto isxdigit(char c) -> bool {
    return std::isxdigit(static_cast<unsigned char>(c));
}

inline auto tolower(char c) -> char {
    return std::tolower(static_cast<unsigned char>(c));
}

inline auto toupper(char c) -> char {
    return std::toupper(static_cast<unsigned char>(c));
}

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_FUNCTIONAL_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_FUNCTIONAL_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <utility>

namespace muc {

/// @brief `muc::identity` is a function object type whose operator() returns
/// its argument unchanged. The effect is the same as It is a backport of
/// `std::identity`.
struct identity {
    using is_transparent = struct {};

    template<typename T>
    [[nodiscard]] constexpr auto operator()(T&& t) const noexcept -> T&& {
        return std::forward<T>(t);
    }
};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <tuple>
#include <type_traits>
#include <utility>

namespace muc {

/// @brief muc::multidentity is a function object type whose operator() returns
/// its arguments in a `std::tuple`. The effect is the same as
/// `std::forward_as_tuple`.
/// @warning Passing temporary objects as arguments is errorous and will produce
/// `std::tuple` holding dangling references.
struct multidentity {
    template<typename... Ts, std::enable_if_t<sizeof...(Ts) >= 1, bool> = true>
    [[nodiscard]] constexpr auto
    operator()(Ts&&... ts) const noexcept -> std::tuple<Ts&&...> {
        return std::forward_as_tuple<Ts...>(ts...);
    }
};

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_MATH_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_MATH_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 202002L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <cassert>
#include <cmath>
#include <concepts>
#include <type_traits>

namespace muc {

template<ceta_string<3> Mode, std::floating_point T1, std::floating_point T2,
         std::floating_point T3>
    requires(Mode == "[]" or Mode == "[)" or Mode == "(]" or Mode == "()")
constexpr auto clamp(T1 value, T2 low,
                     T3 high) -> std::common_type_t<T1, T2, T3> {
    const std::common_type_t<T1, T2, T3> v{value};
    const std::common_type_t<T1, T2, T3> lo{low};
    const std::common_type_t<T1, T2, T3> hi{high};
    assert(lo < hi);
    if constexpr (Mode == "[]") {
        return v < lo ? lo : hi < v ? hi : v;
    } else if constexpr (Mode == "[)") {
        return v < lo ? lo : hi <= v ? std::nexttoward(hi, lo) : v;
    } else if constexpr (Mode == "(]") {
        return v <= lo ? std::nexttoward(lo, hi) : hi < v ? hi : v;
    } else if constexpr (Mode == "()") {
        return v <= lo ? std::nexttoward(lo, hi) :
               hi <= v ? std::nexttoward(hi, lo) :
                         v;
    }
}

} // namespace muc
#endif

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <cinttypes>
#include <cstdlib>
#include <limits>
#include <type_traits>

#if __cplusplus >= 202002L // >= C++20
#include <version>
#ifdef __cpp_lib_constexpr_cmath // >= C++23
#define MUC_CPP_LIB_CONSTEXPR_CMATH
#endif
#endif

#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
#include <cmath>
#endif

namespace muc {

///////////////////////////////////////////////////////////////////////////////
// div
///////////////////////////////////////////////////////////////////////////////

constexpr auto div(int x, int y) -> std::div_t {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::div(x, y);
#else // backport
    std::div_t result{};
    result.quot = x / y;
    result.rem = x % y;
    return result;
#endif
}

constexpr auto div(long x, long y) -> std::ldiv_t {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::div(x, y);
#else // backport
    std::ldiv_t result{};
    result.quot = x / y;
    result.rem = x % y;
    return result;
#endif
}

constexpr auto div(long long x, long long y) -> std::lldiv_t {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::div(x, y);
#else // backport
    std::lldiv_t result{};
    result.quot = x / y;
    result.rem = x % y;
    return result;
#endif
}

constexpr auto ldiv(long x, long y) -> std::ldiv_t {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::ldiv(x, y);
#else // backport
    return muc::div(x, y);
#endif
}

constexpr auto lldiv(long long x, long long y) -> std::lldiv_t {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::lldiv(x, y);
#else // backport
    return muc::div(x, y);
#endif
}

constexpr auto imaxdiv(std::intmax_t x, std::intmax_t y) -> std::imaxdiv_t {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::imaxdiv(x, y);
#else // backport
    std::imaxdiv_t result{};
    result.quot = x / y;
    result.rem = x % y;
    return result;
#endif
}

template<typename IntMax,
         std::enable_if_t<std::is_same_v<IntMax, std::intmax_t> and
                              (sizeof(IntMax) > sizeof(long long)),
                          bool> = true>
constexpr auto div(IntMax x, IntMax y) -> std::imaxdiv_t {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::div(x, y);
#else // backport
    return muc::imaxdiv(x, y);
#endif
}

///////////////////////////////////////////////////////////////////////////////
// floating point abs
///////////////////////////////////////////////////////////////////////////////

template<typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
constexpr auto abs(T x) -> T {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::abs(x);
#else // backport
#if defined __clang__ or defined __GNUC__
    if constexpr (std::is_same_v<T, double>) {
        return __builtin_fabs(x);
    } else if constexpr (std::is_same_v<T, float>) {
        return __builtin_fabsf(x);
    } else if constexpr (std::is_same_v<T, long double>) {
        return __builtin_fabsl(x);
    }
#else
    return x >= 0 ? x : -x;
#endif
#endif
}

template<typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
constexpr auto fabs(T x) -> T {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::fabs(x);
#else // backport
    return muc::abs(x);
#endif
}

constexpr auto fabsf(float x) -> float {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::fabsf(x);
#else // backport
    return muc::abs(x);
#endif
}

constexpr auto fabsl(long double x) -> long double {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::fabsl(x);
#else // backport
    return muc::abs(x);
#endif
}

template<typename T, std::enable_if_t<std::is_integral_v<T>, bool> = true>
constexpr auto fabs(T n) -> double {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::fabs(n);
#else // backport
    return muc::abs(static_cast<double>(n));
#endif
}

///////////////////////////////////////////////////////////////////////////////
// integral abs
///////////////////////////////////////////////////////////////////////////////

constexpr auto abs(int n) -> int {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::abs(n);
#else // backport
    return n >= 0 ? n : -n;
#endif
}

constexpr auto abs(long n) -> long {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::abs(n);
#else // backport
    return n >= 0 ? n : -n;
#endif
}

constexpr auto abs(long long n) -> long long {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::abs(n);
#else // backport
    return n >= 0 ? n : -n;
#endif
}

constexpr auto labs(long n) -> long {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::labs(n);
#else // backport
    return muc::abs(n);
#endif
}

constexpr auto llabs(long long n) -> long long {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::llabs(n);
#else // backport
    return muc::abs(n);
#endif
}

constexpr auto imaxabs(std::intmax_t n) -> std::intmax_t {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::imaxabs(n);
#else // backport
    return n >= 0 ? n : -n;
#endif
}

template<typename IntMax,
         std::enable_if_t<std::is_same_v<IntMax, std::intmax_t> and
                              (sizeof(IntMax) > sizeof(long long)),
                          bool> = true>
constexpr auto abs(IntMax n) -> std::intmax_t {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::abs(n);
#else // backport
    return muc::imaxabs(n);
#endif
}

///////////////////////////////////////////////////////////////////////////////
// isnan
///////////////////////////////////////////////////////////////////////////////

template<typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
constexpr auto isnan(T x) -> bool {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::isnan(x);
#else // backport
    return x != x;
#endif
}

template<typename T, std::enable_if_t<std::is_integral_v<T>, bool> = true>
constexpr auto isnan(T n) -> bool {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::isnan(n);
#else // backport
    if constexpr (std::numeric_limits<double>::is_iec559) {
        return false;
    } else {
        return muc::isnan(static_cast<double>(n));
    }
#endif
}

} // namespace muc

#undef MUC_CPP_LIB_CONSTEXPR_CMATH

#include <cmath>
#include <type_traits>

namespace muc {

/// @brief Ceils a floating-point number to a specified number of decimal
/// places.
///
/// This function ceilings the input floating-point value `x` to `n` decimal
/// places. If `x` is zero, the function returns zero directly. The ceiling
/// operation is performed using a scaling method that adjusts for the magnitude
/// of `x` to maintain the desired number of decimal places.
///
/// @tparam T The type of the input value, which must be a floating point type
///           (e.g., float, double).
/// @param x The floating-point number to be ceiled.
/// @param n The number of decimal places to which `x` should be ceiled.
/// @return The ceiled value of `x`, with `n` decimal places.
template<typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
auto ceil_to(T x, int n) -> T {
    if (x == 0) {
        return 0;
    }
    const auto scale{std::pow(10, n - std::ceil(std::log10(muc::abs(x))))};
    return std::ceil(x * scale) / scale;
}

/// @brief Ceils an integral value to a specified number of decimal places as a
/// floating point.
///
/// This function converts the input integral value `x` to a floating-point type
/// `T` and then ceils it to `n` decimal places. It utilizes the `muc::ceil_to`
/// function defined for floating-point types to perform the ceiling operation.
///
/// @tparam T The type of the output value (default is double).
///            This should be a floating-point type (e.g., float, double).
/// @tparam U The type of the input value, which must be an integral type (e.g.,
/// int, long).
/// @param x The input integral value to be ceiled.
/// @param n The number of decimal places to which `x` should be ceiled.
/// @return The ceiled value of `x` as a floating-point number with `n` decimal
/// places.
template<typename T = double, typename U,
         std::enable_if_t<std::is_floating_point_v<T> && std::is_integral_v<U>,
                          bool> = true>
auto ceil_to(U x, int n) -> T {
    return muc::ceil_to(static_cast<T>(x), n);
}

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

/// @brief Get n-based digits of an integer.
/// @param m The integer.
/// @param base The base.
/// @param with_sign Set whether the digits in return includes "-" sign (true
/// means include, false means exclude).
/// @return The n-based digits.
template<typename T,
         std::enable_if_t<std::is_signed_v<T> and std::is_integral_v<T>, bool> =
             true>
constexpr auto digits_of(T m, int base, bool with_sign = false) -> int {
    if (base == 0) {
        return 0;
    }
    if (base < 0) {
        base = -base;
    }
    int d{};
    if (m < 0) {
        if (with_sign) {
            ++d;
        }
        m = -m;
    }
    do {
        m /= base;
        ++d;
    } while (m > 0);
    return d;
}

/// @brief Get n-based digits of an integer.
/// @tparam Base The base.
/// @param m The integer.
/// @param with_sign Set whether the digits in return includes "-" sign (true
/// means include, false means exclude).
/// @return The n-based digits.
template<unsigned Base, typename T,
         std::enable_if_t<std::is_signed_v<T> and std::is_integral_v<T>, bool> =
             true>
constexpr auto digits_of(T m, bool with_sign = false) -> int {
    return muc::digits_of(m, Base, with_sign);
}

/// @brief Get n-based digits of an integer.
/// @param m The integer.
/// @param base The base.
/// @return The n-based digits.
template<typename T,
         std::enable_if_t<std::is_unsigned_v<T> and std::is_integral_v<T>,
                          bool> = true>
constexpr auto digits_of(T m, int base) -> int {
    if (base == 0) {
        return 0;
    }
    if (base < 0) {
        base = -base;
    }
    int d{};
    do {
        m /= base;
        ++d;
    } while (m > 0);
    return d;
}

/// @brief Get n-based digits of an integer.
/// @tparam Base The base.
/// @param m The integer.
/// @return The n-based digits.
template<unsigned Base, typename T,
         std::enable_if_t<std::is_unsigned_v<T> and std::is_integral_v<T>,
                          bool> = true>
constexpr auto digits_of(T m) -> auto {
    return muc::digits_of(m, Base);
}

} // namespace muc

#ifdef MUC_STATIC_TEST

static_assert(muc::digits_of(0, 2) == 1);
static_assert(muc::digits_of(0u, 2) == 1);
static_assert(muc::digits_of(0b10100101000, 2) == 11);
static_assert(muc::digits_of(0b10100101000u, 2) == 11);
static_assert(muc::digits_of(-0b10100101000, 2) == 11);
static_assert(muc::digits_of(-0b10100101000, 2, true) == 12);
static_assert(muc::digits_of<2>(0) == 1);
static_assert(muc::digits_of<2>(0u) == 1);
static_assert(muc::digits_of<2>(0b10100101000) == 11);
static_assert(muc::digits_of<2>(0b10100101000u) == 11);
static_assert(muc::digits_of<2>(-0b10100101000) == 11);
static_assert(muc::digits_of<2>(-0b10100101000, true) == 12);

static_assert(muc::digits_of(0, 8) == 1);
static_assert(muc::digits_of(0u, 8) == 1);
static_assert(muc::digits_of(0123456, 8) == 6);
static_assert(muc::digits_of(0123456u, 8) == 6);
static_assert(muc::digits_of(-0123456, 8) == 6);
static_assert(muc::digits_of(-0123456, 8, true) == 7);
static_assert(muc::digits_of<8>(0) == 1);
static_assert(muc::digits_of<8>(0u) == 1);
static_assert(muc::digits_of<8>(0123456) == 6);
static_assert(muc::digits_of<8>(0123456u) == 6);
static_assert(muc::digits_of<8>(-0123456) == 6);
static_assert(muc::digits_of<8>(-0123456, true) == 7);

static_assert(muc::digits_of(0, 10) == 1);
static_assert(muc::digits_of(0u, 10) == 1);
static_assert(muc::digits_of(1, 10) == 1);
static_assert(muc::digits_of(1u, 10) == 1);
static_assert(muc::digits_of(99, 10) == 2);
static_assert(muc::digits_of(99u, 10) == 2);
static_assert(muc::digits_of(100, 10) == 3);
static_assert(muc::digits_of(100u, 10) == 3);
static_assert(muc::digits_of(123456, 10) == 6);
static_assert(muc::digits_of(123456u, 10) == 6);
static_assert(muc::digits_of(1919810, 10) == 7);
static_assert(muc::digits_of(1919810u, 10) == 7);
static_assert(muc::digits_of(-123456, 10) == 6);
static_assert(muc::digits_of(-123456, 10, true) == 7);
static_assert(muc::digits_of<10>(123456) == 6);
static_assert(muc::digits_of<10>(123456u) == 6);
static_assert(muc::digits_of<10>(-123456) == 6);
static_assert(muc::digits_of<10>(-123456, true) == 7);

static_assert(muc::digits_of(0, 16) == 1);
static_assert(muc::digits_of(0u, 16) == 1);
static_assert(muc::digits_of(0x123456, 16) == 6);
static_assert(muc::digits_of(0x123456u, 16) == 6);
static_assert(muc::digits_of(-0x123456, 16) == 6);
static_assert(muc::digits_of(-0x123456, 16, true) == 7);
static_assert(muc::digits_of<16>(0) == 1);
static_assert(muc::digits_of<16>(0u) == 1);
static_assert(muc::digits_of<16>(0x123456) == 6);
static_assert(muc::digits_of<16>(0x123456u) == 6);
static_assert(muc::digits_of<16>(-0x123456) == 6);
static_assert(muc::digits_of<16>(-0x123456, true) == 7);

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <cmath>
#include <type_traits>

namespace muc {

/// @brief Floors a floating-point number to a specified number of decimal
/// places.
///
/// This function floors the input floating-point value `x` to `n` decimal
/// places. If `x` is zero, the function returns zero directly. The flooring is
/// done using a scaling method that accounts for the magnitude of `x`, allowing
/// for correct decimal place adjustments.
///
/// @tparam T The type of the input value, which must be a floating point type
///           (e.g., float, double).
/// @param x The floating-point number to be floored.
/// @param n The number of decimal places to which `x` should be floored.
/// @return The floored value of `x`, with `n` decimal places.
template<typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
auto floor_to(T x, int n) -> T {
    if (x == 0) {
        return 0;
    }
    const auto scale{std::pow(10, n - std::ceil(std::log10(muc::abs(x))))};
    return std::floor(x * scale) / scale;
}

/// @brief Floors an integral value to a specified number of decimal places as a
/// floating point.
///
/// This function converts the input integral value `x` to a floating-point type
/// `T` and then floors it to `n` decimal places. It utilizes the
/// `muc::floor_to` function defined for floating-point types to perform the
/// flooring operation.
///
/// @tparam T The type of the output value (default is double).
///            This should be a floating-point type (e.g., float, double).
/// @tparam U The type of the input value, which must be an integral type (e.g.,
/// int, long).
/// @param x The input integral value to be floored.
/// @param n The number of decimal places to which `x` should be floored.
/// @return The floored value of `x` as a floating-point number with `n` decimal
/// places.
template<typename T = double, typename U,
         std::enable_if_t<std::is_floating_point_v<T> && std::is_integral_v<U>,
                          bool> = true>
auto floor_to(U x, int n) -> T {
    return muc::floor_to(static_cast<T>(x), n);
}

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <cmath>
#include <type_traits>

namespace muc {

template<typename... Ts, std::enable_if_t<((sizeof...(Ts) >= 2) and ... and
                                           std::is_floating_point_v<Ts>),
                                          bool> = true>
constexpr auto hypot2(Ts... x) -> auto {
    return (... + (x * x));
}

template<typename... Ts, std::enable_if_t<((sizeof...(Ts) >= 2) and ... and
                                           std::is_floating_point_v<Ts>),
                                          bool> = true>
auto hypot(Ts... x) -> auto {
    return std::sqrt(muc::hypot2(x...));
}

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <cassert>
#include <limits>
#include <type_traits>

namespace muc {

/// @brief A fast implementation of std::llround but never raise floating point
/// exceptions. Computes the nearest integer value to x (in floating-point
/// format), rounding halfway cases away from zero.
/// @tparam T floating-point type
/// @param x floating-point value
/// @return the nearest integer value to x, rounding halfway cases away from
/// zero
template<typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
constexpr auto llround(T x) -> long long {
    assert(static_cast<T>(std::numeric_limits<long long>::min()) < x and
           x < static_cast<T>(std::numeric_limits<long long>::max()));
    return x + (x >= 0 ? 0.5 : -0.5);
}

} // namespace muc

#ifdef MUC_STATIC_TEST

static_assert(muc::llround(-3.) == -3);
static_assert(muc::llround(-2.) == -2);
static_assert(muc::llround(-1.) == -1);
static_assert(muc::llround(+0.) == +0);
static_assert(muc::llround(+1.) == +1);
static_assert(muc::llround(+2.) == +2);
static_assert(muc::llround(+3.) == +3);

static_assert(muc::llround(-3.3) == -3);
static_assert(muc::llround(-2.3) == -2);
static_assert(muc::llround(-1.3) == -1);
static_assert(muc::llround(+0.3) == +0);
static_assert(muc::llround(+1.3) == +1);
static_assert(muc::llround(+2.3) == +2);
static_assert(muc::llround(+3.3) == +3);

static_assert(muc::llround(-3.5) == -4);
static_assert(muc::llround(-2.5) == -3);
static_assert(muc::llround(-1.5) == -2);
static_assert(muc::llround(+0.5) == +1);
static_assert(muc::llround(+1.5) == +2);
static_assert(muc::llround(+2.5) == +3);
static_assert(muc::llround(+3.5) == +4);

static_assert(muc::llround(-3.7) == -4);
static_assert(muc::llround(-2.7) == -3);
static_assert(muc::llround(-1.7) == -2);
static_assert(muc::llround(+0.7) == +1);
static_assert(muc::llround(+1.7) == +2);
static_assert(muc::llround(+2.7) == +3);
static_assert(muc::llround(+3.7) == +4);

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <cassert>
#include <limits>
#include <type_traits>

namespace muc {

/// @brief A fast implementation of std::trunc but never raise floating point
/// exceptions and returns a long long int. Computes the nearest integer not
/// greater in magnitude than x.
/// @tparam T floating-point type
/// @param x floating-point value
/// @return the nearest integer value not greater in magnitude than x
template<typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
constexpr auto lltrunc(T x) -> long long {
    assert(static_cast<T>(std::numeric_limits<long long>::min()) < x and
           x < static_cast<T>(std::numeric_limits<long long>::max()));
    return x;
}

} // namespace muc

#ifdef MUC_STATIC_TEST

static_assert(muc::lltrunc(-3.) == -3);
static_assert(muc::lltrunc(-2.) == -2);
static_assert(muc::lltrunc(-1.) == -1);
static_assert(muc::lltrunc(+0.) == +0);
static_assert(muc::lltrunc(+1.) == +1);
static_assert(muc::lltrunc(+2.) == +2);
static_assert(muc::lltrunc(+3.) == +3);

static_assert(muc::lltrunc(-3.3) == -3);
static_assert(muc::lltrunc(-2.3) == -2);
static_assert(muc::lltrunc(-1.3) == -1);
static_assert(muc::lltrunc(+0.3) == +0);
static_assert(muc::lltrunc(+1.3) == +1);
static_assert(muc::lltrunc(+2.3) == +2);
static_assert(muc::lltrunc(+3.3) == +3);

static_assert(muc::lltrunc(-3.5) == -3);
static_assert(muc::lltrunc(-2.5) == -2);
static_assert(muc::lltrunc(-1.5) == -1);
static_assert(muc::lltrunc(+0.5) == +0);
static_assert(muc::lltrunc(+1.5) == +1);
static_assert(muc::lltrunc(+2.5) == +2);
static_assert(muc::lltrunc(+3.5) == +3);

static_assert(muc::lltrunc(-3.7) == -3);
static_assert(muc::lltrunc(-2.7) == -2);
static_assert(muc::lltrunc(-1.7) == -1);
static_assert(muc::lltrunc(+0.7) == +0);
static_assert(muc::lltrunc(+1.7) == +1);
static_assert(muc::lltrunc(+2.7) == +2);
static_assert(muc::lltrunc(+3.7) == +3);

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

template<typename T, std::enable_if_t<std::is_integral_v<T>, bool> = true>
constexpr auto odd(T n) -> auto {
    return n & static_cast<decltype(n)>(1);
}

template<typename T, std::enable_if_t<std::is_integral_v<T>, bool> = true>
constexpr auto even(T n) -> auto {
    return not odd(n);
}

} // namespace muc

#ifdef MUC_STATIC_TEST

static_assert(not muc::odd(0));
static_assert(not muc::odd(2));
static_assert(muc::odd(1));
static_assert(muc::odd(3));

static_assert(muc::even(0));
static_assert(muc::even(2));
static_assert(not muc::even(1));
static_assert(not muc::even(3));

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

/// @brief Calculate m^N, where both m and N are integers.
/// @tparam T integral type
/// @tparam N power, N>=0
/// @param m base
/// @return m^N of type T.
template<int N, typename T,
         std::enable_if_t<N >= 0 and std::is_integral_v<T>, bool> = true>
constexpr auto ipow(T m) -> T {
    if constexpr (N == 0) {
        return 1;
    }
    if constexpr (N == 1) {
        return m;
    }
    if constexpr (N % 2 == 0) {
        const auto k{muc::ipow<N / 2>(m)};
        return k * k;
    }
    if constexpr (N % 3 == 0) {
        const auto k{muc::ipow<N / 3>(m)};
        return k * k * k;
    }
    const auto k{muc::ipow<(N - 1) / 2>(m)};
    return k * m * k;
}

/// @brief Calculate x^N, where x is an floating point and N is an integer.
/// @tparam T floating point type
/// @tparam N power
/// @param x base
/// @return x^N
template<int N, typename T,
         std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
constexpr auto pow(T x) -> T {
    if constexpr (N < 0) {
        return muc::pow<-N>(1 / x);
    }
    if constexpr (N == 0) {
        return 1;
    }
    if constexpr (N == 1) {
        return x;
    }
    if constexpr (N % 2 == 0) {
        const auto u{muc::pow<N / 2>(x)};
        return u * u;
    }
    if constexpr (N % 3 == 0) {
        const auto u{muc::pow<N / 3>(x)};
        return u * u * u;
    }
    const auto u{muc::pow<(N - 1) / 2>(x)};
    return u * x * u;
}

/// @brief Calculate x^N, where x is an integral converted to floating point, N
/// is an integer.
/// @tparam T floating point type
/// @tparam N power
/// @param x base
/// @return x^N
template<int N, typename T = double, typename U,
         std::enable_if_t<std::is_floating_point_v<T> and std::is_integral_v<U>,
                          bool> = true>
constexpr auto pow(U x) -> T {
    return muc::pow<N>(static_cast<T>(x));
}

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <algorithm>
#include <limits>
#include <type_traits>

namespace muc {

/// @brief Computes the ReLU (Rectified Linear Unit) of a given floating-point
/// value.
///
/// The ReLU function is defined as:
/// \f[ \text{ReLU}(x) = \max(0, x) \f]
/// It outputs the input value if it is positive; otherwise, it outputs 0.
/// If the input is NaN, the function also returns NaN.
///
/// @tparam T The type of the input value, which must be a floating point type
/// (e.g., float, double).
/// @param x The input value for which the ReLU function is to be computed.
///          It should be a floating-point number.
/// @return The computed ReLU value of the input `x`, which will be in the range
/// [0, inf).
template<typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
constexpr auto relu(T x) -> T {
    if (muc::isnan(x)) {
        return std::numeric_limits<T>::quiet_NaN();
    }
    return std::max({}, x);
}

/// @brief Computes the ReLU (Rectified Linear Unit) of an integral value and
/// returns it as a floating-point type.
///
/// This function takes an integral input value, converts it to a floating-point
/// type, and computes the ReLU function. If the floating-point type `T` is
/// compliant with IEEE 754 (as determined by
/// `std::numeric_limits<T>::is_iec559`), it uses `std::max` to compute the ReLU
/// value. Otherwise, it defaults to invoking the ReLU function defined for
/// floating-point types. The resulting value is in the range [0, inf).
///
/// @tparam T The type of the output value (default is double).
///            This should be a floating-point type (e.g., float, double).
/// @tparam U The type of the input value, which must be an integral type (e.g.,
/// int, long).
/// @param x The input integral value for which the ReLU function is to be
/// computed.
/// @return The computed ReLU value of the input `x`, converted to type `T`,
/// which
///         will be in the range [0, inf).
template<typename T = double, typename U,
         std::enable_if_t<std::is_floating_point_v<T> && std::is_integral_v<U>,
                          bool> = true>
constexpr auto relu(U x) -> T {
    if constexpr (std::numeric_limits<T>::is_iec559) {
        return std::max({}, x);
    } else {
        return muc::relu(static_cast<T>(x));
    }
}

} // namespace muc

#ifdef MUC_STATIC_TEST

static_assert(muc::relu(-3.3) == 0);
static_assert(muc::relu(-2.3) == 0);
static_assert(muc::relu(-1.3) == 0);
static_assert(muc::relu(0.3) == 0.3);
static_assert(muc::relu(1.3) == 1.3);
static_assert(muc::relu(2.3) == 2.3);
static_assert(muc::relu(3.3) == 3.3);

static_assert(muc::relu(-3) == 0);
static_assert(muc::relu(-2) == 0);
static_assert(muc::relu(-1) == 0);
static_assert(muc::relu(0) == 0);
static_assert(muc::relu(1) == +1);
static_assert(muc::relu(2) == +2);
static_assert(muc::relu(3) == +3);

static_assert(muc::relu(-std::numeric_limits<double>::infinity()) == 0);
static_assert(muc::relu(std::numeric_limits<double>::infinity()) ==
              std::numeric_limits<double>::infinity());
static_assert(muc::isnan(muc::relu(std::numeric_limits<double>::quiet_NaN())));

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <cmath>
#include <type_traits>

namespace muc {

/// @brief Rounds a floating-point number to a specified number of decimal
/// places.
///
/// This function rounds the input floating-point value `x` to `n` decimal
/// places. If `x` is zero, the function returns zero directly. The rounding is
/// performed using a scaling method which accounts for the magnitude of `x`,
/// ensuring correctness across a wide range of values.
///
/// @tparam T The type of the input value, which must be a floating point type
///           (e.g., float, double).
/// @param x The floating-point number to be rounded.
/// @param n The number of decimal places to which `x` should be rounded.
/// @return The rounded value of `x`, with `n` decimal places.
template<typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
auto round_to(T x, int n) -> T {
    if (x == 0) {
        return 0;
    }
    const auto scale{std::pow(10, n - std::ceil(std::log10(muc::abs(x))))};
    return std::round(x * scale) / scale;
}

/// @brief Rounds an integral value to a specified number of decimal places as a
/// floating-point type.
///
/// This function converts the input integral value `x` to a floating-point type
/// `T` and rounds it to `n` decimal places. It uses the `muc::round_to`
/// function defined for floating-point types to perform the rounding operation.
///
/// @tparam T The type of the output value (default is double).
///            This should be a floating-point type (e.g., float, double).
/// @tparam U The type of the input value, which must be an integral type (e.g.,
/// int, long).
/// @param x The input integral value to be rounded.
/// @param n The number of decimal places to which `x` should be rounded.
/// @return The rounded value of `x` as a floating-point number with `n` decimal
/// places.
template<typename T = double, typename U,
         std::enable_if_t<std::is_floating_point_v<T> && std::is_integral_v<U>,
                          bool> = true>
auto round_to(U x, int n) -> T {
    return muc::round_to(static_cast<T>(x), n);
}

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <cmath>
#include <type_traits>

namespace muc {

/// @brief Computes the sigmoid of a given value.
///
/// The sigmoid function is defined as:
/// \f[ \sigma(x) = \frac{1}{1 + e^{-x}} \f]
/// It maps any real-valued number into the range (0, 1). This is commonly used
/// in neural networks and logistic regression.
///
/// @tparam T The type of the input value, which must be a floating point type
/// (e.g., float, double).
/// @param x The input value for which the sigmoid function is to be computed.
///          It should be a floating point number.
/// @return The computed sigmoid value of the input `x`, which will be in the
/// range (0, 1).
template<typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
auto sigmoid(T x) -> T {
    return 1 / (1 + std::exp(-x));
}

/// @brief Computes the sigmoid of a given integral value and returns it as a
/// floating-point type.
///
/// This function takes an integral input value, converts it to a floating-point
/// type, and then computes the sigmoid using the `sigmoid` function template
/// for floating point types. The resulting value is within the range (0, 1), as
/// with the typical sigmoid function.
///
/// @tparam T The type of the output value (default is double).
///            This should be a floating point type (e.g., float, double).
/// @tparam U The type of the input value, which must be an integral type (e.g.,
/// int, long).
/// @param x The input value for which the sigmoid function is to be computed.
///          It should be an integral number that will be converted to type `T`.
/// @return The computed sigmoid value of the input `x`, converted to type `T`,
/// which will be in the range (0, 1).
template<typename T = double, typename U,
         std::enable_if_t<std::is_floating_point_v<T> and std::is_integral_v<U>,
                          bool> = true>
auto sigmoid(U x) -> T {
    return muc::sigmoid(static_cast<T>(x));
}

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <cmath>
#include <type_traits>

namespace muc {

/// @brief Truncates a floating-point number to a specified number of decimal
/// places.
///
/// This function truncates the input floating-point value `x` to `n` decimal
/// places. If `x` is zero, the function returns zero directly. The truncation
/// is performed using a scaling method that accounts for the magnitude of `x`,
/// ensuring that `n` decimal places are preserved.
///
/// @tparam T The type of the input value, which must be a floating point type
///           (e.g., float, double).
/// @param x The floating-point number to be truncated.
/// @param n The number of decimal places to which `x` should be truncated.
/// @return The truncated value of `x`, with `n` decimal places.
template<typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
auto trunc_to(T x, int n) -> T {
    if (x == 0) {
        return 0;
    }
    const auto scale{std::pow(10, n - std::ceil(std::log10(muc::abs(x))))};
    return std::trunc(x * scale) / scale;
}

/// @brief Truncates an integral value to a specified number of decimal places
/// as a floating point.
///
/// This function converts the input integral value `x` to a floating-point type
/// `T` and then truncates it to `n` decimal places. It calls the
/// `muc::trunc_to` function defined for floating-point types to perform the
/// truncation.
///
/// @tparam T The type of the output value (default is double).
///            This should be a floating-point type (e.g., float, double).
/// @tparam U The type of the input value, which must be an integral type (e.g.,
/// int, long).
/// @param x The input integral value to be truncated.
/// @param n The number of decimal places to which `x` should be truncated.
/// @return The truncated value of `x` as a floating-point number with `n`
/// decimal places.
template<typename T = double, typename U,
         std::enable_if_t<std::is_floating_point_v<T> && std::is_integral_v<U>,
                          bool> = true>
auto trunc_to(U x, int n) -> T {
    return muc::trunc_to(static_cast<T>(x), n);
}

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_MEMORY_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_MEMORY_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <new>
#include <utility>

namespace muc {

template<typename T, typename... Args>
auto construct_at(T* ptr, Args&&... args) -> T* {
    return ::new (static_cast<void*>(ptr)) T(std::forward<Args>(args)...);
}

} // namespace muc

#include <cstddef>
#include <cstring>
#include <memory>
#include <utility>

namespace muc {

template<typename T>
struct placement {
public:
    placement(const T& obj) :
        m_storage{} {
        muc::construct_at(pointer_to(m_storage), obj);
    }

    placement(T&& obj) :
        m_storage{} {
        muc::construct_at(pointer_to(m_storage), std::move(obj));
    }

    template<typename... Args>
    placement(Args&&... args) :
        m_storage{} {
        muc::construct_at(pointer_to(m_storage), std::forward<Args>(args)...);
    }

    placement(const placement& other) :
        placement{*other} {}

    placement(placement&& other) :
        placement{std::move(*other)} {}

    ~placement() {
        std::destroy_at(pointer_to(m_storage));
    }

    auto operator=(const placement& other) {
        alignas(T) std::byte buffer[sizeof(T)]{};
        muc::construct_at(pointer_to(buffer), *other);
        std::destroy_at(pointer_to(m_storage));
        std::memcpy(&m_storage, &buffer, sizeof(T));
    }

    auto operator=(placement&& other) {
        alignas(T) std::byte buffer[sizeof(T)]{};
        muc::construct_at(pointer_to(buffer), std::move(*other));
        std::destroy_at(pointer_to(m_storage));
        std::memcpy(&m_storage, &buffer, sizeof(T));
    }

    operator T&() & {
        return **this;
    }

    operator const T&() const& {
        return **this;
    }

    operator T&&() && {
        return std::move(**this);
    }

    operator const T&&() const&& {
        return std::move(**this);
    }

    auto operator*() & -> T& {
        return get();
    }

    auto operator*() const& -> const T& {
        return get();
    }

    auto operator*() && -> T&& {
        return std::move(get());
    }

    auto operator*() const&& -> const T&& {
        return std::move(get());
    }

    auto get() & -> T& {
        return *pointer_to(m_storage);
    }

    auto get() const& -> const T& {
        return *pointer_to(m_storage);
    }

    auto get() && -> T&& {
        return std::move(*pointer_to(m_storage));
    }

    auto get() const&& -> const T&& {
        return std::move(*pointer_to(m_storage));
    }

    auto operator->() -> T* {
        return pointer_to(m_storage);
    }

    auto operator->() const -> const T* {
        return pointer_to(m_storage);
    }

private:
    static auto pointer_to(std::byte* buffer) -> T* {
        return std::launder(reinterpret_cast<T*>(buffer));
    }

    static auto pointer_to(const std::byte* buffer) -> const T* {
        return std::launder(reinterpret_cast<const T*>(buffer));
    }

private:
    alignas(T) std::byte m_storage[sizeof(T)];
};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <memory>
#include <type_traits>
#include <utility>

namespace muc {

template<typename T>
constexpr auto to_address(T* ptr) noexcept -> T* {
    static_assert(not std::is_function_v<T>);
    return ptr;
}

namespace impl {

template<typename, typename = void>
struct has_pointer_traits_to_address : std::false_type {};

template<typename T>
struct has_pointer_traits_to_address<
    T, std::void_t<decltype(std::pointer_traits<T>::to_address(
           std::declval<const T&>()))>> : std::true_type {};

} // namespace impl

template<typename T>
constexpr auto to_address(const T& ptr) noexcept -> auto {
    if constexpr (impl::has_pointer_traits_to_address<T>::value) {
        return std::pointer_traits<T>::to_address(ptr);
    } else {
        return muc::to_address(ptr.operator->());
    }
}

} // namespace muc

#include <memory>
#include <stdexcept>
#include <type_traits>
#include <utility>

namespace muc {

template<typename Allocator>
struct allocator_delete : placement<Allocator> {
    allocator_delete() = default;

    explicit allocator_delete(const Allocator& alloc) :
        placement<Allocator>{alloc} {}

    explicit allocator_delete(Allocator&& alloc) :
        placement<Allocator>{std::move(alloc)} {}

    template<typename Alloc>
    allocator_delete(const allocator_delete<Alloc>& other) :
        Allocator{static_cast<const Alloc&>(other)} {}

    template<typename Alloc>
    allocator_delete(allocator_delete<Alloc>&& other) :
        Allocator{static_cast<Alloc&&>(other)} {}

    auto
    operator()(typename std::allocator_traits<Allocator>::pointer ptr) -> void {
        Allocator& alloc(*this);
        std::allocator_traits<Allocator>::destroy(alloc, muc::to_address(ptr));
        std::allocator_traits<Allocator>::deallocate(alloc, ptr, 1);
    }
};

template<typename T, typename Allocator, typename... Args>
auto allocate_unique(Allocator alloc, Args&&... args)
    -> std::unique_ptr<T, allocator_delete<Allocator>> {
    static_assert(
        std::is_same_v<typename std::allocator_traits<Allocator>::value_type,
                       std::remove_cv_t<T>>,
        "Allocator has the wrong value_type");
    const auto ptr{std::allocator_traits<Allocator>::allocate(alloc, 1)};
    const auto deallocate_when_failed{[&] {
        std::allocator_traits<Allocator>::deallocate(alloc, ptr, 1);
    }};
    try {
        std::allocator_traits<Allocator>::construct(
            alloc, muc::to_address(ptr), std::forward<Args>(args)...);
        return std::unique_ptr<T, allocator_delete<Allocator>>{
            ptr, allocator_delete<Allocator>{alloc}};
    } catch (const std::exception& e) {
        deallocate_when_failed();
        throw e;
    } catch (...) {
        deallocate_when_failed();
        throw;
    }
}

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_NUMERIC_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_NUMERIC_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 202002L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <concepts>
#include <initializer_list>
#include <limits>
#include <ranges>

namespace muc {

/// @brief Evaluates a polynomial at a given value using Qin Jiushao's method.
///
/// This function takes a collection of coefficients representing a polynomial,
/// and evaluates it at the specified point `x`. The coefficients should be
/// provided in standard order (i.e., starting from the constant term).
///
/// The polynomial is evaluated using Qin Jiushao's method for improved
/// numerical stability and efficiency. If the coefficients collection is empty,
/// the function returns NaN.
///
/// @tparam T The type of the polynomial evaluation, constrained to
/// floating-point types.
/// @tparam C The type of the coefficients collection, which defaults to an
/// initializer_list.
///            It must satisfy the requirements of a range.
/// @param coeff A collection of coefficients representing the polynomial. The
/// coefficients
///              should be specified in standard order, where the first element
///              is the coefficient of the constant term.
/// @param x The value at which the polynomial is to be evaluated.
/// @return The result of evaluating the polynomial at the point `x`.
///         If the coefficients are empty, returns NaN or 0 depending on the
///         type.
template<std::floating_point T, std::ranges::range C = std::initializer_list<T>>
constexpr auto polynomial(C&& coeff, T x) -> T {
    auto c{std::ranges::crbegin(coeff)};
    const auto end{std::ranges::crend(coeff)};
    if (c == end) {
        return std::numeric_limits<T>::quiet_NaN();
    }
    T p{*c++};
    while (c != end) {
        p = p * x + *c++;
    }
    return p;
}

/// @brief Evaluates a polynomial at a given integral value using Horner's
/// method.
///
/// This function acts as an overload for evaluating a polynomial at an integral
/// input value. It ensures that the coefficient collection is passed in its
/// appropriate type while converting the integral `x` to the specified
/// floating-point type for evaluation. The coefficients should be defined in
/// standard order, starting from the constant term.
///
/// @tparam T The type of the polynomial evaluation, constrained to
/// floating-point types.
///           The default type is double.
/// @tparam C The type of the coefficients collection, which defaults to an
/// initializer_list.
///            It must satisfy the requirements of a range.
/// @param coeff A collection of coefficients representing the polynomial.
///              The coefficients should be specified in standard order,
///              where the first element is the coefficient of the constant
///              term.
/// @param x The integral value at which the polynomial is to be evaluated.
/// @return The result of evaluating the polynomial at the point `x`.
///         The integral `x` is implicitly converted to type `T` for the
///         evaluation.
template<std::floating_point T = double,
         std::ranges::range C = std::initializer_list<T>>
constexpr auto polynomial(C&& coeff, std::integral auto x) -> T {
    return polynomial<T>(coeff, x);
}

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <ranges>
#include <utility>
#include <version>

#ifdef __cpp_lib_ranges_iota // C++23
#include <algorithm>
#include <numeric>
#else // backport
#include <iterator>
#endif

namespace muc::ranges {

#ifdef __cpp_lib_ranges_iota // C++23

struct iota_fn {
    template<std::input_or_output_iterator O, std::sentinel_for<O> S,
             std::weakly_incrementable T>
        requires std::indirectly_writable<O, const T&>
    constexpr auto operator()(O first, S last,
                              T value) const -> std::ranges::iota_result<O, T> {
        return std::ranges::iota(std::move(first), std::move(last),
                                 std::move(value));
    }

    template<std::weakly_incrementable T, std::ranges::output_range<const T&> R>
    constexpr auto operator()(R&& r, T value) const
        -> std::ranges::iota_result<std::ranges::borrowed_iterator_t<R>, T> {
        return std::ranges::iota(std::forward<decltype(r)>(r),
                                 std::move(value));
    }
};

#else // backport

template<typename O, typename T>
struct out_value_result {
    [[no_unique_address]] O out;
    [[no_unique_address]] T value;

    template<typename O2, typename T2>
        requires std::convertible_to<const O&, O2> and
                 std::convertible_to<const T&, T2>
    constexpr operator out_value_result<O2, T2>() const& {
        return {out, value};
    }

    template<typename O2, typename T2>
        requires std::convertible_to<O, O2> and std::convertible_to<T, T2>
    constexpr operator out_value_result<O2, T2>() && {
        return {std::move(out), std::move(value)};
    }
};

template<typename O, typename T>
using iota_result = out_value_result<O, T>;

struct iota_fn {
    template<std::input_or_output_iterator O, std::sentinel_for<O> S,
             std::weakly_incrementable T>
        requires std::indirectly_writable<O, const T&>
    constexpr auto operator()(O first, S last,
                              T value) const -> iota_result<O, T> {
        while (first != last) {
            *first++ = value++;
        }
        return {std::move(first), std::move(value)};
    }

    template<std::weakly_incrementable T, std::ranges::output_range<const T&> R>
    constexpr auto operator()(R&& r, T value) const
        -> iota_result<std::ranges::borrowed_iterator_t<R>, T> {
        return (*this)(std::ranges::begin(std::forward<decltype(r)>(r)),
                       std::ranges::end(std::forward<decltype(r)>(r)),
                       std::move(value));
    }
};

#endif

inline constexpr iota_fn iota{};

} // namespace muc::ranges
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <iterator>
#include <numeric>
#include <ranges>
#include <utility>

namespace muc::ranges {

constexpr struct {
    constexpr auto operator()(std::ranges::input_range auto&& r,
                              auto&&... args) const -> decltype(auto) {
        return std::accumulate(std::ranges::cbegin(r), std::ranges::cend(r),
                               std::forward<decltype(args)>(args)...);
    }
} accumulate{};

constexpr struct {
    constexpr auto operator()(std::ranges::input_range auto&& r,
                              auto&&... args) const -> decltype(auto) {
        return std::reduce(std::ranges::cbegin(r), std::ranges::cend(r),
                           std::forward<decltype(args)>(args)...);
    }

    auto operator()(auto&& policy, std::ranges::forward_range auto&& r,
                    auto&&... args) const -> decltype(auto) {
        return std::reduce(std::forward<decltype(policy)>(policy),
                           std::ranges::cbegin(r), std::ranges::cend(r),
                           std::forward<decltype(args)>(args)...);
    }
} reduce{};

constexpr struct {
    constexpr auto operator()(std::ranges::input_range auto&& r,
                              std::input_iterator auto i,
                              auto&&... args) const -> decltype(auto) {
        return std::transform_reduce(std::ranges::cbegin(r),
                                     std::ranges::cend(r), i,
                                     std::forward<decltype(args)>(args)...);
    }

    constexpr auto operator()(std::ranges::input_range auto&& r,
                              auto&&... args) const -> decltype(auto) {
        return std::transform_reduce(std::ranges::cbegin(r),
                                     std::ranges::cend(r),
                                     std::forward<decltype(args)>(args)...);
    }

    auto operator()(auto&& policy, std::ranges::forward_range auto&& r,
                    std::forward_iterator auto i,
                    auto&&... args) const -> decltype(auto) {
        return std::transform_reduce(
            std::forward<decltype(policy)>(policy), std::ranges::cbegin(r),
            std::ranges::cend(r), i, std::forward<decltype(args)>(args)...);
    }

    auto operator()(auto&& policy, std::ranges::forward_range auto&& r,
                    auto&&... args) const -> decltype(auto) {
        return std::transform_reduce(
            std::forward<decltype(policy)>(policy), std::ranges::cbegin(r),
            std::ranges::cend(r), std::forward<decltype(args)>(args)...);
    }
} transform_reduce{};

constexpr struct {
    constexpr auto operator()(std::ranges::input_range auto&& r,
                              std::input_iterator auto i,
                              auto&&... args) const -> decltype(auto) {
        return std::inner_product(std::ranges::cbegin(r), std::ranges::cend(r),
                                  i, std::forward<decltype(args)>(args)...);
    }
} inner_product{};

constexpr struct {
    constexpr auto operator()(std::ranges::input_range auto&& r,
                              /* std::output_iterator */ auto o,
                              auto&&... args) const -> decltype(auto) {
        return std::adjacent_difference(std::ranges::cbegin(r),
                                        std::ranges::cend(r), o,
                                        std::forward<decltype(args)>(args)...);
    }

    auto operator()(auto&& policy, std::ranges::forward_range auto&& r,
                    std::forward_iterator auto o,
                    auto&&... args) const -> decltype(auto) {
        return std::adjacent_difference(
            std::forward<decltype(policy)>(policy), std::ranges::cbegin(r),
            std::ranges::cend(r), o, std::forward<decltype(args)>(args)...);
    }
} adjacent_difference{};

constexpr struct {
    constexpr auto operator()(std::ranges::input_range auto&& r,
                              /* std::output_iterator */ auto o,
                              auto&&... args) const -> decltype(auto) {
        return std::partial_sum(std::ranges::cbegin(r), std::ranges::cend(r), o,
                                std::forward<decltype(args)>(args)...);
    }
} partial_sum{};

constexpr struct {
    constexpr auto operator()(std::ranges::input_range auto&& r,
                              /* std::output_iterator */ auto o,
                              auto&&... args) const -> decltype(auto) {
        return std::inclusive_scan(std::ranges::cbegin(r), std::ranges::cend(r),
                                   o, std::forward<decltype(args)>(args)...);
    }

    auto operator()(auto&& policy, std::ranges::forward_range auto&& r,
                    std::forward_iterator auto o,
                    auto&&... args) const -> decltype(auto) {
        return std::inclusive_scan(std::forward<decltype(policy)>(policy),
                                   std::ranges::cbegin(r), std::ranges::cend(r),
                                   o, std::forward<decltype(args)>(args)...);
    }
} inclusive_scan{};

constexpr struct {
    constexpr auto operator()(std::ranges::input_range auto&& r,
                              /* std::output_iterator */ auto o,
                              auto&&... args) const -> decltype(auto) {
        return std::exclusive_scan(std::ranges::cbegin(r), std::ranges::cend(r),
                                   o, std::forward<decltype(args)>(args)...);
    }

    auto operator()(auto&& policy, std::ranges::forward_range auto&& r,
                    std::forward_iterator auto o,
                    auto&&... args) const -> decltype(auto) {
        return std::exclusive_scan(std::forward<decltype(policy)>(policy),
                                   std::ranges::cbegin(r), std::ranges::cend(r),
                                   o, std::forward<decltype(args)>(args)...);
    }
} exclusive_scan{};

constexpr struct {
    constexpr auto operator()(std::ranges::input_range auto&& r,
                              /* std::output_iterator */ auto o,
                              auto&&... args) const -> decltype(auto) {
        return std::transform_inclusive_scan(
            std::ranges::cbegin(r), std::ranges::cend(r), o,
            std::forward<decltype(args)>(args)...);
    }

    auto operator()(auto&& policy, std::ranges::forward_range auto&& r,
                    std::forward_iterator auto o,
                    auto&&... args) const -> decltype(auto) {
        return std::transform_inclusive_scan(
            std::forward<decltype(policy)>(policy), std::ranges::cbegin(r),
            std::ranges::cend(r), o, std::forward<decltype(args)>(args)...);
    }
} transform_inclusive_scan{};

constexpr struct {
    constexpr auto operator()(std::ranges::input_range auto&& r,
                              /* std::output_iterator */ auto o,
                              auto&&... args) const -> decltype(auto) {
        return std::transform_exclusive_scan(
            std::ranges::cbegin(r), std::ranges::cend(r), o,
            std::forward<decltype(args)>(args)...);
    }

    auto operator()(auto&& policy, std::ranges::forward_range auto&& r,
                    std::forward_iterator auto o,
                    auto&&... args) const -> decltype(auto) {
        return std::transform_exclusive_scan(
            std::forward<decltype(policy)>(policy), std::ranges::cbegin(r),
            std::ranges::cend(r), o, std::forward<decltype(args)>(args)...);
    }
} transform_exclusive_scan{};

} // namespace muc::ranges
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <concepts>
#include <initializer_list>
#include <ranges>

namespace muc {

/// @brief Evaluates a rational function at a given point using polynomial
/// evaluation.
///
/// This function computes the value of a rational function defined by a
/// numerator and denominator, where both are represented as polynomial
/// coefficients. The function evaluates the numerator and denominator
/// polynomials at the specified floating-point value `x`, and returns the
/// result of the division.
///
/// @tparam T The type of the polynomial evaluation, constrained to
/// floating-point types.
/// @tparam A The type of the coefficients collection for the numerator, which
/// defaults to an
///            initializer_list. It must satisfy the requirements of a range.
/// @tparam B The type of the coefficients collection for the denominator, which
/// defaults to an
///            initializer_list. It must satisfy the requirements of a range.
/// @param numer A collection of coefficients representing the numerator
/// polynomial.
///              The coefficients should be specified in standard order,
///              starting from the constant term.
/// @param denom A collection of coefficients representing the denominator
/// polynomial.
///              The coefficients should also be specified in standard order,
///              starting from the constant term.
/// @param x The floating-point value at which the rational function is to be
/// evaluated.
/// @return The result of evaluating the rational function at the point `x`,
/// which is the
///         quotient of the evaluated numerator and denominator polynomials.
///         Note: The function does not check for division by zero.
template<std::floating_point T, std::ranges::range A = std::initializer_list<T>,
         std::ranges::range B = std::initializer_list<T>>
constexpr auto rational(A&& numer, B&& denom, T x) -> T {
    return polynomial(numer, x) / polynomial(denom, x);
}

/// @brief Evaluates a rational function at a given integral point using
/// polynomial evaluation.
///
/// This function serves as an overload for evaluating a rational function with
/// integral input. It takes a numerator and denominator represented as
/// polynomial coefficients and evaluates the rational function at the integral
/// point `x`. The integral `x` is implicitly converted to the specified
/// floating-point type `T` for evaluation.
///
/// @tparam T The type of the polynomial evaluation, constrained to
/// floating-point types.
///           The default type is double.
/// @tparam A The type of the coefficients collection for the numerator, which
/// defaults to an
///            initializer_list. It must satisfy the requirements of a range.
/// @tparam B The type of the coefficients collection for the denominator, which
/// defaults to an
///            initializer_list. It must satisfy the requirements of a range.
/// @param numer A collection of coefficients representing the numerator
/// polynomial.
///              The coefficients should be specified in standard order,
///              starting from the constant term.
/// @param denom A collection of coefficients representing the denominator
/// polynomial.
///              The coefficients should also be specified in standard order,
///              starting from the constant term.
/// @param x The integral value at which the rational function is to be
/// evaluated.
/// @return The result of evaluating the rational function at the point `x`,
/// which is the
///         quotient of the evaluated numerator and denominator polynomials.
///         Note: The function does not check for division by zero.
template<std::floating_point T = double,
         std::ranges::range A = std::initializer_list<T>,
         std::ranges::range B = std::initializer_list<T>>
constexpr auto rational(A&& numer, B&& denom, std::integral auto x) -> T {
    return rational<T>(numer, denom, x);
}

} // namespace muc
#endif

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <type_traits>

namespace muc {

/// @brief Performs linear interpolation.
/// @tparam T value type, can be a scalar or vector or something.
/// @tparam U scalar type
/// @param c values on endpoints
/// @param t interpolation parameter. 0<t<1 implies interpolation, otherwise
/// extrapolation.
/// @return interpolated value.
template<typename T, typename U,
         std::enable_if_t<is_general_arithmetic_v<T>, bool> = true,
         std::enable_if_t<std::is_floating_point_v<U>, bool> = true>
constexpr auto lerp(const T& a, const T& b, U t) -> T {
    if constexpr (std::is_integral_v<T>) {
        return (1 - t) * a + t * b;
    } else {
        return a + t * (b - a);
    }
}

} // namespace muc

#include <type_traits>

namespace muc {

/// @brief Performs bilinear interpolation.
/// @tparam T value type, can be a scalar or vector or something.
/// @tparam U scalar type
/// @param c values on square grid. See note for details.
/// @param u interpolation parameter. 0<u<1 implies interpolation, otherwise
/// extrapolation.
/// @param v interpolation parameter. 0<v<1 implies interpolation, otherwise
/// extrapolation.
/// @return interpolated value.
/// @note For parameter c:
///
///      c01      c11
///         +----+
///         |    |
/// v       +----+
/// ^    c00      c10
/// |
/// +----> u
template<typename T, typename U,
         std::enable_if_t<is_general_arithmetic_v<T>, bool> = true,
         std::enable_if_t<std::is_floating_point_v<U>, bool> = true>
constexpr auto bilerp(const T& c00, const T& c01, const T& c10, const T& c11,
                      U u, U v) -> T {
    return muc::lerp(muc::lerp(c00, c01, v), muc::lerp(c10, c11, v), u);
}

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <limits>
#include <type_traits>

namespace muc {

/// @brief Default tolerance value for floating-point type.
/// This constexpr variable provides a default tolerance value for
/// floating-points. It is calculated as half of the number of significant
/// digits of the floating-point type T.
/// @tparam T The floating-point type.
template<typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
inline constexpr auto default_tolerance{
    muc::pow<std::numeric_limits<T>::digits / 2, T>(2) *
    std::numeric_limits<T>::epsilon()};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <type_traits>

namespace muc {

template<typename T, std::enable_if_t<is_general_arithmetic_v<T>, bool> = true>
constexpr auto midpoint(const T& a, const T& b) -> T {
    return a + (b - a) / 2;
}

} // namespace muc

#include <algorithm>
#include <limits>
#include <optional>
#include <type_traits>
#include <utility>

namespace muc::find_root {

/// @brief Newton-Raphson method for finding roots of a function.
/// This function implements the Newton-Raphson method for finding roots of a
/// function. It iteratively calculates the next value using the function and
/// its derivative until convergence.
/// @tparam T The type of the input value.
/// @tparam F The type of the function to evaluate.
/// @tparam DF The type of the derivative function.
/// @param f The function to evaluate.
/// @param df The derivative function.
/// @param x0 The initial guess for the root.
/// @param max_iter The maximum number of iterations allowed (default is 1000).
/// @param tolerance The tolerance value for convergence (default is
/// default_tolerance<T>).
/// @return A pair containing the root value and a boolean indicating if
/// convergence was achieved.
template<typename T, typename F, typename DF,
         std::enable_if_t<std::is_floating_point_v<T> and
                              std::is_invocable_r_v<T, F, T> and
                              std::is_invocable_r_v<T, DF, T>,
                          bool> = true>
constexpr auto
newton_raphson(F&& f, DF&& df, T x0, int max_iter = 1000,
               T tolerance = muc::default_tolerance<T>) -> std::pair<T, bool> {
    auto x1{x0 - f(x0) / df(x0)};
    for (int i{}; i < max_iter; ++i) {
        if (muc::isnan(x1)) {
            break;
        }
        if (muc::abs(x1 - x0) <= muc::abs(muc::midpoint(x1, x0)) * tolerance) {
            return {x1, true};
        }
        x0 = x1;
        x1 = x0 - f(x0) / df(x0);
    }
    return {x1, false};
}

/// @brief Secant method for finding roots of a function.
/// This function implements the secant method for finding roots of a function.
/// It iteratively calculates the next value using two initial guesses until
/// convergence.
/// @tparam T The type of the input value.
/// @tparam F The type of the function to evaluate.
/// @param f The function to evaluate.
/// @param x0 The first initial guess for the root.
/// @param x1O The optional second initial guess for the root (default is
/// empty).
/// @param max_iter The maximum number of iterations allowed (default is 1000).
/// @param tolerance The tolerance value for convergence (default is
/// default_tolerance<T>).
/// @return A pair containing the root value and a boolean indicating if
/// convergence was achieved.
template<typename T, typename F,
         std::enable_if_t<std::is_floating_point_v<T> and
                              std::is_invocable_r_v<T, F, T>,
                          bool> = true>
constexpr auto
secant(F&& f, T x0, std::optional<T> x1O = {}, int max_iter = 1000,
       T tolerance = muc::default_tolerance<T>) -> std::pair<T, bool> {
    auto fx0{f(x0)};
    if (fx0 == 0) {
        return {x0, true};
    }
    auto x1{x1O.value_or(x0 + fx0 * 2 * tolerance /
                                  (f(x0 - tolerance) - f(x0 + tolerance)))};
    auto fx1{f(x1)};
    auto x2{(x0 * fx1 - x1 * fx0) / (fx1 - fx0)};
    for (int i{}; i < max_iter; ++i) {
        if (muc::isnan(x2)) {
            break;
        }
        if (muc::abs(x2 - x1) <= muc::abs(muc::midpoint(x2, x1)) * tolerance) {
            return {x2, true};
        }
        x0 = x1;
        fx0 = fx1;
        x1 = x2;
        fx1 = f(x2);
        x2 = (x0 * fx1 - x1 * fx0) / (fx1 - fx0);
    }
    return {x2, false};
}

/// @brief Brent's method for finding roots of a function.
/// This function implements Brent's method for finding roots of a function.
/// It iteratively narrows down the root using a combination of bisection,
/// secant, and inverse quadratic interpolation.
/// @tparam T The type of the input value.
/// @tparam F The type of the function to evaluate.
/// @param f The function to evaluate.
/// @param x1 The first initial guess for the root.
/// @param x2 The second initial guess for the root.
/// @param max_iter The maximum number of iterations allowed (default is
/// 100000).
/// @param tolerance The tolerance value for convergence (default is
/// default_tolerance<T>).
/// @return A pair containing the root value and a boolean indicating if
/// convergence was achieved.
template<typename T, typename F,
         std::enable_if_t<std::is_floating_point_v<T> and
                              std::is_invocable_r_v<T, F, T>,
                          bool> = true>
constexpr auto
zbrent(F&& f, T x1, T x2, int max_iter = 100000,
       T tolerance = muc::default_tolerance<T>) -> std::pair<T, bool> {
    auto a{x1};
    auto b{x2};
    auto c{x2};
    auto d{x2 - x1};
    auto e{x2 - x1};
    auto fa{f(a)};
    auto fb{f(b)};
    auto fc{fb};
    // Check if there is a single zero in range
    if (fa * fb > 0) {
        return {b, false};
    }
    // Start search
    for (auto iter{0ll}; iter < max_iter; ++iter) {
        if ((fb > 0 and fc > 0) or (fb < 0 and fc < 0)) {
            c = a;
            fc = fa;
            d = b - a;
            e = d;
        }
        if (muc::abs(fc) < muc::abs(fb)) {
            a = b;
            b = c;
            c = a;
            fa = fb;
            fb = fc;
            fc = fa;
        }
        if (muc::isnan(fb)) {
            break;
        }
        const auto tol{2 * std::numeric_limits<T>::epsilon() * muc::abs(b) +
                       tolerance / 2};
        const auto xm{(c - b) / 2};
        if (muc::abs(xm) <= tol or fb == 0) {
            return {b, true};
        }
        if (muc::abs(e) >= tol and muc::abs(fa) > muc::abs(fb)) {
            T p;
            T q;
            const auto s{fb / fa};
            if (a == c) {
                p = 2 * xm * s;
                q = 1 - s;
            } else {
                q = fa / fc;
                const auto r1{fb / fc};
                p = s * (2 * xm * q * (q - r1) - (b - a) * (r1 - 1));
                q = (q - 1) * (r1 - 1) * (s - 1);
            }
            if (p > 0) {
                q = -q;
            }
            p = muc::abs(p);
            if (2 * p <
                std::min(3 * xm * q - muc::abs(tol * q), muc::abs(e * q))) {
                e = d;
                d = p / q;
            } else {
                d = xm;
                e = d;
            }
        } else {
            d = xm;
            e = d;
        }
        a = b;
        fa = fb;
        if (muc::abs(d) > tol) {
            b += d;
        } else {
            b += (xm > 1) ? tol : -tol;
        }
        fb = f(b);
    }
    // nan or max_iter reached
    return {b, false};
}

} // namespace muc::find_root

#ifdef MUC_STATIC_TEST

static_assert([] {
    const auto [x, converged]{muc::find_root::newton_raphson(
        [](auto x) {
            return x * x - 1;
        },
        [](auto x) {
            return 2 * x;
        },
        0.5)};
    return converged and muc::abs(x - 1) < 2 * muc::default_tolerance<double>;
}());

static_assert([] {
    const auto [x, converged]{muc::find_root::secant(
        [](auto x) {
            return x * x - 1;
        },
        0.5)};
    return converged and muc::abs(x - 1) < 2 * muc::default_tolerance<double>;
}());

// static_assert([] {
//     const auto [x, converged]{muc::find_root::zbrent(
//         [](auto x) {
//             return x * x - 1;
//         },
//         0.5, 2.5)};
//     return converged and muc::abs(x - 1) < 2 * muc::default_tolerance<double>;
// }());

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <algorithm>
#include <type_traits>

namespace muc {

/// @brief A class to perform soft comparisons between floating-point values.
///
/// This class uses a softening factor to create a non-binary comparison
/// between two floating-point values, allowing for smooth transitions. The
/// comparisons are based on sigmoid functions to provide soft decision
/// boundaries.
///
/// @tparam T The type of the floating-point values. It should be a
/// floating-point type.
template<typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
class soft_cmp {
private:
    class value;

    /// @brief Represents the result of a soft comparison operation.
    class result {
        friend class value;

    private:
        constexpr result(T result) :
            m_result{result} {}

    public:
        /// @brief Converts the result to the underlying type T.
        constexpr operator T() const {
            return m_result;
        }

        /// @brief Dereference operator to access the underlying result.
        /// @return The underlying result value.
        constexpr auto operator*() const -> T {
            return m_result;
        }

        /// @brief Negation operator to invert the result.
        /// @return A new result object representing 1 - m_result.
        constexpr auto operator not() const -> result {
            return 1 - m_result;
        }

        /// @brief Logical AND operation between two soft comparison results.
        /// @param other Another result to compare against.
        /// @return The result of the logical AND operation.
        constexpr auto operator and(result other) const -> result {
            return m_result * other.m_result;
        }

        /// @brief Logical OR operation between two soft comparison results.
        /// @param other Another result to compare against.
        /// @return The result of the logical OR operation.
        constexpr auto operator or(result other) const -> result {
            return std::min(m_result + other.m_result, static_cast<T>(1));
        }

    private:
        T m_result;
    };

    /// @brief Represents a value with an associated softening factor.
    class value {
        friend class soft_cmp;

    private:
        constexpr value(T value, T soft) :
            m_value{value},
            m_soft{soft} {}

    public:
        /// @brief Greater-than operator comparing two soft values.
        /// @param other The other value to compare against.
        /// @return The result of the soft comparison.
        auto operator>(value other) const -> result {
            return muc::sigmoid((m_value - other.m_value) / m_soft);
        }

        /// @brief Less-than operator comparing two soft values.
        /// @param other The other value to compare against.
        /// @return The result of the soft comparison.
        auto operator<(value other) const -> result {
            return muc::sigmoid((other.m_value - m_value) / m_soft);
        }

        /// @brief Equality operator comparing two soft values.
        /// @param other The other value to compare against.
        /// @return The result of the equality comparison.
        auto operator==(value other) const -> result {
            const auto x{(m_value - other.m_value) / m_soft};
            return 4 * muc::sigmoid(x) * (1 - muc::sigmoid(x));
        }

        /// @brief Inequality operator comparing two soft values.
        /// @param other The other value to compare against.
        /// @return The result of the inequality comparison.
        auto operator!=(value other) const -> result {
            const auto x{(m_value - other.m_value) / m_soft};
            return 1 - 4 * muc::sigmoid(x) * (1 - muc::sigmoid(x));
        }

        /// @brief Greater than or equal is same as greater-than.
        auto operator>=(value) const -> result = delete;
        /// @brief Less than or equal is same as less-than.
        auto operator<=(value) const -> result = delete;
#if __cplusplus >= 202002L
        /// @brief Three-way comparison is not well-defined.
        auto operator<=>(value) const -> result = delete;
#endif

    private:
        T m_value;
        T m_soft;
    };

public:
    /// @brief Constructs a soft_cmp object with a given softening factor.
    /// @param soft The softening factor to use in comparisons.
    constexpr explicit soft_cmp(T soft) :
        m_soft{soft} {}

    /// @brief Sets a new softening factor for the comparisons.
    /// @param soft The new softening factor.
    constexpr auto soft(T soft) -> void {
        m_soft = soft;
    }

    /// @brief Gets the current softening factor.
    /// @return The current softening factor.
    constexpr auto soft() const -> T {
        return m_soft;
    }

    /// @brief Creates a value for comparison using the current softening
    /// parameter.
    /// @param val The value to be wrapped with the current softening factor.
    /// @return A value object containing the given value and the softening
    /// parameter.
    constexpr auto operator()(T val) const -> value {
        return {val, m_soft};
    }

private:
    T m_soft;
};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <type_traits>

namespace muc {

/// @brief Performs trilinear interpolation.
/// @tparam T value type, can be a scalar or vector or something.
/// @tparam U scalar type
/// @param c values on square grid. See note for details.
/// @param u interpolation parameter. 0<u<1 implies interpolation, otherwise
/// extrapolation.
/// @param v interpolation parameter. 0<v<1 implies interpolation, otherwise
/// extrapolation.
/// @return interpolated value.
/// @note For parameter c:
///
///         c011    c111
///            +----+
///      c010 /|   /|
///          +----+ + c101
///          |c001|/
/// v w      +----+
/// ^ ^  c000     c100
/// |/
/// +----> u
template<typename T, typename U,
         std::enable_if_t<is_general_arithmetic_v<T>, bool> = true,
         std::enable_if_t<std::is_floating_point_v<U>, bool> = true>
constexpr auto trilerp(const T& c000, const T& c001, const T& c010,
                       const T& c011, const T& c100, const T& c101,
                       const T& c110, const T& c111, U u, U v, U w) -> T {
    return muc::bilerp(muc::lerp(c000, c001, w), muc::lerp(c010, c011, w),
                       muc::lerp(c100, c101, w), muc::lerp(c110, c111, w), u,
                       v);
}

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_PTR_SPAN_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_PTR_SPAN_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <cassert>
#include <cstddef>
#include <iterator>
#include <memory>
#include <sstream>
#include <stdexcept>
#include <type_traits>
#include <utility>

namespace muc {

template<typename T,
         typename =
             std::void_t<decltype(*std::declval<typename T::value_type>())>>
class ptr_span {
private:
    using raw_ptr_vector = T;

public:
    using value_type = typename std::pointer_traits<
        typename raw_ptr_vector::value_type>::element_type;
    using size_type = typename raw_ptr_vector::size_type;
    using difference_type = typename raw_ptr_vector::difference_type;
    using reference = value_type&;
    using const_reference = const value_type&;
    using pointer = value_type*;             // TODO: Do we need traits?
    using const_pointer = const value_type*; // TODO: Do we need traits?

private:
    template<typename RawIterator>
    class basic_iterator {
        friend class ptr_span;

    public:
        using difference_type = typename ptr_span::difference_type;
        using value_type = std::conditional_t<
            std::is_const_v<
                typename std::iterator_traits<RawIterator>::value_type>,
            const typename ptr_span::value_type, typename ptr_span::value_type>;
        using pointer = std::conditional_t<
            std::is_const_v<
                typename std::iterator_traits<RawIterator>::value_type>,
            typename ptr_span::const_pointer, typename ptr_span::pointer>;
        using reference = std::conditional_t<
            std::is_const_v<
                typename std::iterator_traits<RawIterator>::value_type>,
            typename ptr_span::const_reference, typename ptr_span::reference>;
        using iterator_category = std::random_access_iterator_tag;

    public:
        basic_iterator() :
            m_iter{} {}

    private:
        explicit basic_iterator(RawIterator iter) :
            m_iter{iter} {}

    public:
        operator basic_iterator<typename raw_ptr_vector::const_iterator>() {
            return basic_iterator<typename raw_ptr_vector::const_iterator>{
                m_iter};
        }

        auto operator*() const -> reference {
            return **m_iter;
        }

        auto operator->() const -> pointer {
            return muc::to_address(*m_iter);
        }

        auto operator[](std::size_t index) const -> reference {
            return *m_iter[index];
        }

        auto operator-(basic_iterator other) const -> difference_type {
            return m_iter - other.m_iter;
        }

        auto operator++() -> basic_iterator& {
            m_iter++;
            return *this;
        }

        auto operator++(int) -> basic_iterator {
            auto next{*this};
            ++(*this);
            return next;
        }

        auto operator--() -> basic_iterator& {
            m_iter--;
            return *this;
        }

        auto operator--(int) -> basic_iterator {
            auto prev{*this};
            --(*this);
            return prev;
        }

        auto operator+=(difference_type n) -> basic_iterator& {
            m_iter += n;
            return *this;
        }

        auto operator-=(difference_type n) -> basic_iterator& {
            m_iter -= n;
            return *this;
        }

        auto operator+(difference_type n) const -> basic_iterator {
            return basic_iterator{m_iter + n};
        }

        auto operator-(difference_type n) const -> basic_iterator {
            return basic_iterator{m_iter - n};
        }

        auto operator==(const basic_iterator& other) const -> bool {
            return m_iter == other.m_iter;
        }
#if __cplusplus >= 202002L
        auto operator<=>(const basic_iterator& other) const -> auto {
            return m_iter <=> other.m_iter;
        }
#else
        auto operator!=(const basic_iterator& other) const -> bool {
            return m_iter != other.m_iter;
        }

        auto operator<(const basic_iterator& other) const -> bool {
            return m_iter < other.m_iter;
        }

        auto operator<=(const basic_iterator& other) const -> bool {
            return m_iter <= other.m_iter;
        }

        auto operator>(const basic_iterator& other) const -> bool {
            return m_iter > other.m_iter;
        }

        auto operator>=(const basic_iterator& other) const -> bool {
            return m_iter >= other.m_iter;
        }
#endif
    private:
        RawIterator m_iter;
    };

public:
    using iterator = basic_iterator<typename raw_ptr_vector::iterator>;
    using const_iterator =
        basic_iterator<typename raw_ptr_vector::const_iterator>;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

public:
    ptr_span() noexcept :
        m_ptr_vector{} {}

    ptr_span(T& ptr_vector) noexcept :
        m_ptr_vector{&ptr_vector} {}

    ptr_span(T&& ptr_vector) = delete;

    //
    // Element access
    //

    auto at(size_type pos) -> reference {
        range_check(pos);
        return (*this)[pos];
    }

    auto at(size_type pos) const -> const_reference {
        range_check(pos);
        return (*this)[pos];
    }

    auto operator[](size_type pos) -> reference {
        assert(pos < size());
        return *m_ptr_vector[pos];
    }

    auto operator[](size_type pos) const -> const_reference {
        assert(pos < size());
        return *m_ptr_vector[pos];
    }

    auto front() -> reference {
        assert(not empty());
        return *m_ptr_vector->front();
    }

    auto front() const -> const_reference {
        assert(not empty());
        return *m_ptr_vector->front();
    }

    auto back() -> reference {
        assert(not empty());
        return *m_ptr_vector->back();
    }

    auto back() const -> const_reference {
        assert(not empty());
        return *m_ptr_vector->back();
    }

    auto underlying() -> raw_ptr_vector& {
        return *m_ptr_vector;
    }

    auto underlying() const -> const raw_ptr_vector& {
        return *m_ptr_vector;
    }

    //
    // Iterators
    //

    auto begin() const noexcept -> const_iterator {
        return const_iterator{m_ptr_vector->begin()};
    }

    auto cbegin() const noexcept -> const_iterator {
        return begin();
    }

    auto end() const noexcept -> const_iterator {
        return const_iterator{m_ptr_vector->end()};
    }

    auto cend() const noexcept -> const_iterator {
        return end();
    }

    auto rbegin() const noexcept -> const_reverse_iterator {
        return const_reverse_iterator{end()};
    }

    auto crbegin() const noexcept -> const_reverse_iterator {
        return rbegin();
    }

    auto rend() const noexcept -> const_reverse_iterator {
        return const_reverse_iterator{begin()};
    }

    auto crend() const noexcept -> const_reverse_iterator {
        return rend();
    }

    //
    // Pointer vector iterator
    //

    auto pbegin() noexcept -> typename raw_ptr_vector::iterator {
        return m_ptr_vector->begin();
    }

    auto pbegin() const noexcept -> typename raw_ptr_vector::const_iterator {
        return m_ptr_vector->begin();
    }

    auto pcbegin() const noexcept -> typename raw_ptr_vector::const_iterator {
        return m_ptr_vector->cbegin();
    }

    auto pend() noexcept -> typename raw_ptr_vector::iterator {
        return m_ptr_vector->end();
    }

    auto pend() const noexcept -> typename raw_ptr_vector::const_iterator {
        return m_ptr_vector->end();
    }

    auto pcend() const noexcept -> typename raw_ptr_vector::const_iterator {
        return m_ptr_vector->cend();
    }

    auto prbegin() noexcept -> typename raw_ptr_vector::reverse_iterator {
        return m_ptr_vector->rbegin();
    }

    auto prbegin() const noexcept ->
        typename raw_ptr_vector::const_reverse_iterator {
        return m_ptr_vector->rbegin();
    }

    auto pcrbegin() const noexcept ->
        typename raw_ptr_vector::const_reverse_iterator {
        return m_ptr_vector->crbegin();
    }

    auto prend() noexcept -> typename raw_ptr_vector::reverse_iterator {
        return m_ptr_vector->rend();
    }

    auto prend() const noexcept ->
        typename raw_ptr_vector::const_reverse_iterator {
        return m_ptr_vector->rend();
    }

    auto pcrend() const noexcept ->
        typename raw_ptr_vector::const_reverse_iterator {
        return m_ptr_vector->crend();
    }

    //
    // Writable iterators & range
    //

    auto vbegin() noexcept -> iterator {
        return iterator{m_ptr_vector->begin()};
    }

    auto vend() noexcept -> iterator {
        return iterator{m_ptr_vector->end()};
    }

    auto vrbegin() noexcept -> reverse_iterator {
        return reverse_iterator{vend()};
    }

    auto vrend() noexcept -> reverse_iterator {
        return reverse_iterator{vbegin()};
    }

    class vrange_type {
        friend auto ptr_span::vrange() const noexcept -> vrange_type;

    public:
        auto begin() const noexcept -> iterator {
            return iterator{m_ptr_vector->begin()};
        }

        auto end() const noexcept -> iterator {
            return iterator{m_ptr_vector->end()};
        }

        auto rbegin() const noexcept -> reverse_iterator {
            return reverse_iterator{end()};
        }

        auto rend() const noexcept -> reverse_iterator {
            return reverse_iterator{begin()};
        }

    private:
        raw_ptr_vector* m_ptr_vector;
    };

    auto vrange() const noexcept -> vrange_type {
        return m_ptr_vector;
    }

    //
    // Capacity
    //

    [[nodiscard]] auto empty() const noexcept -> bool {
        return m_ptr_vector ? m_ptr_vector->empty() : true;
    }

    auto size() const noexcept -> size_type {
        return m_ptr_vector ? m_ptr_vector->size() : 0;
    }

    auto max_size() const noexcept -> size_type {
        return m_ptr_vector->max_size();
    }

    auto reserve(size_type new_capacity) -> void {
        return m_ptr_vector->reserve(new_capacity);
    }

    auto capacity() const noexcept -> size_type {
        return m_ptr_vector->capacity();
    }

    auto shrink_to_fit() -> void {
        return m_ptr_vector->shrink_to_fit();
    }

    //
    // Modifier
    //

    auto clear() -> void {
        m_ptr_vector->clear();
    }

    auto erase(const_iterator pos) -> iterator {
        return iterator{m_ptr_vector->erase(pos.m_iter)};
    }

    auto erase(const_iterator first, const_iterator last) -> iterator {
        return iterator{m_ptr_vector->erase(first.m_iter, last.m_iter)};
    }

    auto pop_back() -> void {
        m_ptr_vector->pop_back();
    }

    auto swap(ptr_span& other) noexcept -> void {
        std::swap(m_ptr_vector, other.m_ptr_vector);
    }

    //
    // Compare
    //

    auto operator==(const ptr_span& other) const -> bool {
        return *m_ptr_vector == *other.m_ptr_vector;
    }
#if __cplusplus >= 202002L
    auto operator<=>(const ptr_span& other) const -> auto {
        return *m_ptr_vector <=> *other.m_ptr_vector;
    }
#else
    auto operator!=(const ptr_span& other) const -> bool {
        return *m_ptr_vector != *other.m_ptr_vector;
    }

    auto operator<(const ptr_span& other) const -> bool {
        return *m_ptr_vector < *other.m_ptr_vector;
    }

    auto operator<=(const ptr_span& other) const -> bool {
        return *m_ptr_vector <= *other.m_ptr_vector;
    }

    auto operator>(const ptr_span& other) const -> bool {
        return *m_ptr_vector > *other.m_ptr_vector;
    }

    auto operator>=(const ptr_span& other) const -> bool {
        return *m_ptr_vector >= *other.m_ptr_vector;
    }
#endif

private:
    auto range_check(size_type pos) const -> void {
        if (pos >= size()) {
            std::stringstream ss;
            ss << "muc::ptr_span::range_check: pos >= size() [" << pos
               << " >= " << size() << ']';
            throw std::out_of_range{ss.str()};
        }
    }

private:
    raw_ptr_vector* m_ptr_vector;
};

template<typename T>
auto swap(ptr_span<T>& lhs,
          ptr_span<T>& rhs) noexcept(noexcept(lhs.swap(rhs))) -> void {
    lhs.swap(rhs);
}

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_PTR_VECTOR_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_PTR_VECTOR_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <algorithm>
#include <cassert>
#include <cstddef>
#include <initializer_list>
#include <iterator>
#include <memory>
#include <sstream>
#include <stdexcept>
#include <type_traits>
#include <utility>

namespace muc::impl {
#if false
namespace impl {

template<typename T>
struct as_pointer {
    struct type : T {
    public:
        using T::T;

        auto operator*() noexcept -> T& {
            return *this;
        }

        auto operator*() const noexcept -> const T& {
            return *this;
        }

        auto operator->() noexcept -> T* {
            return this;
        }

        auto operator->() const noexcept -> const T* {
            return this;
        }
    };
};

template<typename T>
struct as_pointer<T*> {
    using type = T*;
};

template<typename T>
using as_pointer_t = typename as_pointer<T>::type;

} // namespace impl
#endif
template<typename Derived, typename RawPtrVector>
class ptr_vector_base {
protected:
    using raw_ptr_vector = RawPtrVector;

public:
    using value_type = typename std::pointer_traits<
        typename raw_ptr_vector::value_type>::element_type;
    using allocator_type = typename std::allocator_traits<
        typename raw_ptr_vector::allocator_type>::
        template rebind_alloc<value_type>;
    using size_type = typename raw_ptr_vector::size_type;
    using difference_type = typename raw_ptr_vector::difference_type;
    using reference = value_type&;
    using const_reference = const value_type&;
    using pointer = typename std::allocator_traits<allocator_type>::pointer;
    using const_pointer =
        typename std::allocator_traits<allocator_type>::const_pointer;

private:
    template<typename RawIterator>
    class basic_iterator {
        friend class ptr_vector_base;

    public:
        using difference_type = typename ptr_vector_base::difference_type;
        using value_type =
            std::conditional_t<std::is_const_v<typename std::iterator_traits<
                                   RawIterator>::value_type>,
                               const typename ptr_vector_base::value_type,
                               typename ptr_vector_base::value_type>;
        using pointer =
            std::conditional_t<std::is_const_v<typename std::iterator_traits<
                                   RawIterator>::value_type>,
                               typename ptr_vector_base::const_pointer,
                               typename ptr_vector_base::pointer>;
        using reference =
            std::conditional_t<std::is_const_v<typename std::iterator_traits<
                                   RawIterator>::value_type>,
                               typename ptr_vector_base::const_reference,
                               typename ptr_vector_base::reference>;
        using iterator_category = std::random_access_iterator_tag;

    public:
        basic_iterator() :
            m_iter{} {}

    private:
        explicit basic_iterator(RawIterator iter) :
            m_iter{iter} {}

    public:
        operator basic_iterator<typename raw_ptr_vector::const_iterator>() {
            return basic_iterator<typename raw_ptr_vector::const_iterator>{
                m_iter};
        }

        auto operator*() const -> reference {
            return **m_iter;
        }

        auto operator->() const -> pointer {
            return muc::to_address(*m_iter);
        }

        auto operator[](std::size_t index) const -> reference {
            return *m_iter[index];
        }

        auto operator-(basic_iterator other) const -> difference_type {
            return m_iter - other.m_iter;
        }

        auto operator++() -> basic_iterator& {
            m_iter++;
            return *this;
        }

        auto operator++(int) -> basic_iterator {
            auto next{*this};
            ++(*this);
            return next;
        }

        auto operator--() -> basic_iterator& {
            m_iter--;
            return *this;
        }

        auto operator--(int) -> basic_iterator {
            auto prev{*this};
            --(*this);
            return prev;
        }

        auto operator+=(difference_type n) -> basic_iterator& {
            m_iter += n;
            return *this;
        }

        auto operator-=(difference_type n) -> basic_iterator& {
            m_iter -= n;
            return *this;
        }

        auto operator+(difference_type n) const -> basic_iterator {
            return basic_iterator{m_iter + n};
        }

        auto operator-(difference_type n) const -> basic_iterator {
            return basic_iterator{m_iter - n};
        }

        auto operator==(const basic_iterator& other) const -> bool {
            return m_iter == other.m_iter;
        }
#if __cplusplus >= 202002L
        auto operator<=>(const basic_iterator& other) const -> auto {
            return m_iter <=> other.m_iter;
        }
#else
        auto operator!=(const basic_iterator& other) const -> bool {
            return m_iter != other.m_iter;
        }

        auto operator<(const basic_iterator& other) const -> bool {
            return m_iter < other.m_iter;
        }

        auto operator<=(const basic_iterator& other) const -> bool {
            return m_iter <= other.m_iter;
        }

        auto operator>(const basic_iterator& other) const -> bool {
            return m_iter > other.m_iter;
        }

        auto operator>=(const basic_iterator& other) const -> bool {
            return m_iter >= other.m_iter;
        }
#endif
    private:
        RawIterator m_iter;
    };

public:
    using iterator = basic_iterator<typename raw_ptr_vector::iterator>;
    using const_iterator =
        basic_iterator<typename raw_ptr_vector::const_iterator>;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

protected:
    ptr_vector_base() :
        m_ptr_vector{} {}

    ptr_vector_base(const raw_ptr_vector& ptr_vec) :
        m_ptr_vector{ptr_vec} {}

    ptr_vector_base(raw_ptr_vector&& ptr_vec) :
        m_ptr_vector{std::move(ptr_vec)} {}

    template<typename... Args>
    ptr_vector_base(Args&&... args) :
        m_ptr_vector{std::forward<Args>(args)...} {}

    ptr_vector_base(const ptr_vector_base&) = default;

    ptr_vector_base(ptr_vector_base&&) noexcept = default;

    ~ptr_vector_base() = default;

public:
    //
    // Assignment
    //

    auto operator=(const ptr_vector_base& other) -> ptr_vector_base& = default;

    auto operator=(ptr_vector_base&& other) noexcept(
        std::is_nothrow_move_constructible_v<raw_ptr_vector>)
        -> ptr_vector_base& = default;
#if false
    auto
    operator=(std::initializer_list<value_type> ilist) -> ptr_vector_base& {
        m_ptr_vector.clear();
        insert(cend(), std::move(ilist));
        return *this;
    }

    auto assign(size_type count, const value_type& value) -> void {
        m_ptr_vector.clear();
        insert(cend(), count, value);
    }

    template<typename InputIt>
    auto assign(InputIt first, InputIt last) -> void {
        m_ptr_vector.clear();
        insert(cend(), first, last);
    }

    auto assign(std::initializer_list<value_type> ilist) -> void {
        m_ptr_vector.clear();
        insert(cend(), std::move(ilist));
    }
#endif
    auto get_allocator() const -> allocator_type {
        return allocator_type{m_ptr_vector.get_allocator()};
    }

    //
    // Element access
    //

    auto at(size_type pos) -> reference {
        range_check(pos);
        return (*this)[pos];
    }

    auto at(size_type pos) const -> const_reference {
        range_check(pos);
        return (*this)[pos];
    }

    auto operator[](size_type pos) -> reference {
        assert(pos < size());
        return *m_ptr_vector[pos];
    }

    auto operator[](size_type pos) const -> const_reference {
        assert(pos < size());
        return *m_ptr_vector[pos];
    }

    auto front() -> reference {
        assert(not empty());
        return *m_ptr_vector.front();
    }

    auto front() const -> const_reference {
        assert(not empty());
        return *m_ptr_vector.front();
    }

    auto back() -> reference {
        assert(not empty());
        return *m_ptr_vector.back();
    }

    auto back() const -> const_reference {
        assert(not empty());
        return *m_ptr_vector.back();
    }

    auto underlying() -> raw_ptr_vector& {
        return m_ptr_vector;
    }

    auto underlying() const -> const raw_ptr_vector& {
        return m_ptr_vector;
    }

    //
    // Iterators
    //

    auto begin() const noexcept -> const_iterator {
        return const_iterator{m_ptr_vector.begin()};
    }

    auto cbegin() const noexcept -> const_iterator {
        return begin();
    }

    auto end() const noexcept -> const_iterator {
        return const_iterator{m_ptr_vector.end()};
    }

    auto cend() const noexcept -> const_iterator {
        return end();
    }

    auto rbegin() const noexcept -> const_reverse_iterator {
        return const_reverse_iterator{end()};
    }

    auto crbegin() const noexcept -> const_reverse_iterator {
        return rbegin();
    }

    auto rend() const noexcept -> const_reverse_iterator {
        return const_reverse_iterator{begin()};
    }

    auto crend() const noexcept -> const_reverse_iterator {
        return rend();
    }

    //
    // Pointer vector iterator
    //

    auto pbegin() noexcept -> typename raw_ptr_vector::iterator {
        return m_ptr_vector.begin();
    }

    auto pbegin() const noexcept -> typename raw_ptr_vector::const_iterator {
        return m_ptr_vector.begin();
    }

    auto pcbegin() const noexcept -> typename raw_ptr_vector::const_iterator {
        return m_ptr_vector.cbegin();
    }

    auto pend() noexcept -> typename raw_ptr_vector::iterator {
        return m_ptr_vector.end();
    }

    auto pend() const noexcept -> typename raw_ptr_vector::const_iterator {
        return m_ptr_vector.end();
    }

    auto pcend() const noexcept -> typename raw_ptr_vector::const_iterator {
        return m_ptr_vector.cend();
    }

    auto prbegin() noexcept -> typename raw_ptr_vector::reverse_iterator {
        return m_ptr_vector.rbegin();
    }

    auto prbegin() const noexcept ->
        typename raw_ptr_vector::const_reverse_iterator {
        return m_ptr_vector.rbegin();
    }

    auto pcrbegin() const noexcept ->
        typename raw_ptr_vector::const_reverse_iterator {
        return m_ptr_vector.crbegin();
    }

    auto prend() noexcept -> typename raw_ptr_vector::reverse_iterator {
        return m_ptr_vector.rend();
    }

    auto prend() const noexcept ->
        typename raw_ptr_vector::const_reverse_iterator {
        return m_ptr_vector.rend();
    }

    auto pcrend() const noexcept ->
        typename raw_ptr_vector::const_reverse_iterator {
        return m_ptr_vector.crend();
    }

    //
    // Writable iterators & range
    //

    auto vbegin() noexcept -> iterator {
        return iterator{m_ptr_vector.begin()};
    }

    auto vend() noexcept -> iterator {
        return iterator{m_ptr_vector.end()};
    }

    auto vrbegin() noexcept -> reverse_iterator {
        return reverse_iterator{vend()};
    }

    auto vrend() noexcept -> reverse_iterator {
        return reverse_iterator{vbegin()};
    }

    class vrange_type {
        friend auto ptr_vector_base::vrange() const noexcept -> vrange_type;

    public:
        auto begin() const noexcept -> iterator {
            return iterator{m_ptr_vector->begin()};
        }

        auto end() const noexcept -> iterator {
            return iterator{m_ptr_vector->end()};
        }

        auto rbegin() const noexcept -> reverse_iterator {
            return reverse_iterator{end()};
        }

        auto rend() const noexcept -> reverse_iterator {
            return reverse_iterator{begin()};
        }

    private:
        raw_ptr_vector* m_ptr_vector;
    };

    auto vrange() const noexcept -> vrange_type {
        return m_ptr_vector;
    }

    //
    // Capacity
    //

    [[nodiscard]] auto empty() const noexcept -> bool {
        return m_ptr_vector.empty();
    }

    auto size() const noexcept -> size_type {
        return m_ptr_vector.size();
    }

    auto max_size() const noexcept -> size_type {
        return m_ptr_vector.max_size();
    }

    auto reserve(size_type new_capacity) -> void {
        return m_ptr_vector.reserve(new_capacity);
    }

    auto capacity() const noexcept -> size_type {
        return m_ptr_vector.capacity();
    }

    auto shrink_to_fit() -> void {
        return m_ptr_vector.shrink_to_fit();
    }

    //
    // Modifier
    //

    auto clear() -> void {
        m_ptr_vector.clear();
    }

    auto insert(const_iterator pos, const value_type& value) -> iterator {
        return emplace(pos, value);
    }

    auto insert(const_iterator pos, value_type&& value) -> iterator {
        return emplace(pos, std::move(value));
    }
#if false
    auto insert(const_iterator pos, size_type count,
                const value_type& value) -> iterator {
        const auto i_pos{pos - cbegin()};

        m_ptr_vector.resize(size() + count);
        const auto first{pbegin() + i_pos};
        const auto last{first + count};

        std::move_backward(first, last, pend());
        std::generate(first, last, [&]() {
            return allocate_ptr(value);
        });

        return iterator{first};
    }

    template<typename InputIt>
    auto insert(const_iterator pos, InputIt first, InputIt last) -> iterator {
        const auto i_pos{pos - cbegin()};
        const auto count{std::distance(first, last)};

        m_ptr_vector.resize(size() + count);
        const auto dst_first{pbegin() + i_pos};
        const auto dst_last{dst_first + count};

        std::move_backward(dst_first, dst_last, pend());
        std::generate(dst_first, dst_last, [&]() {
            return allocate_ptr(*first++);
        });

        return iterator{dst_first};
    }

    auto insert(const_iterator pos,
                std::initializer_list<value_type> ilist) -> iterator {
        return insert(pos, ilist.begin(), ilist.end());
    }
#endif
    template<typename... Args>
    auto emplace(const_iterator pos, Args&&... args) -> iterator {
        return iterator{m_ptr_vector.emplace(
            pos.m_iter, allocate_ptr(std::forward<Args>(args)...))};
    }

    auto erase(const_iterator pos) -> iterator {
        return iterator{m_ptr_vector.erase(pos.m_iter)};
    }

    auto erase(const_iterator first, const_iterator last) -> iterator {
        return iterator{m_ptr_vector.erase(first.m_iter, last.m_iter)};
    }

    auto push_back(const value_type& value) -> void {
        emplace_back(value);
    }

    auto push_back(value_type&& value) -> void {
        emplace_back(std::move(value));
    }

    template<typename... Args>
    auto emplace_back(Args&&... args) -> reference {
        return *m_ptr_vector.emplace_back(
            allocate_ptr(std::forward<Args>(args)...));
    }

    auto pop_back() -> void {
        m_ptr_vector.pop_back();
    }
#if false
    auto resize(size_type count) -> void {
        if (size() >= count) {
            erase(cbegin() + count, cend());
        } else {
            const auto first{
                m_ptr_vector.insert(m_ptr_vector.cend(), count - size(), {})};
            const auto last{m_ptr_vector.end()};
            for (auto i{first}; i != last; ++i) {
                *i = allocate_ptr();
            }
        }
    }

    auto resize(size_type count, const value_type& value) -> void {
        if (size() >= count) {
            erase(cbegin() + count, cend());
        } else {
            const auto first{
                m_ptr_vector.insert(m_ptr_vector.cend(), count - size(), {})};
            const auto last{m_ptr_vector.end()};
            for (auto i{first}; i != last; ++i) {
                *i = allocate_ptr(value);
            }
        }
    }
#endif
    auto swap(ptr_vector_base& other) noexcept -> void {
        m_ptr_vector.swap(other.m_ptr_vector);
    }

    //
    // Compare
    //

    auto operator==(const ptr_vector_base& other) const -> bool {
        return m_ptr_vector == other.m_ptr_vector;
    }
#if __cplusplus >= 202002L
    auto operator<=>(const ptr_vector_base& other) const -> auto {
        return m_ptr_vector <=> other.m_ptr_vector;
    }
#else
    auto operator!=(const ptr_vector_base& other) const -> bool {
        return m_ptr_vector != other.m_ptr_vector;
    }

    auto operator<(const ptr_vector_base& other) const -> bool {
        return m_ptr_vector < other.m_ptr_vector;
    }

    auto operator<=(const ptr_vector_base& other) const -> bool {
        return m_ptr_vector <= other.m_ptr_vector;
    }

    auto operator>(const ptr_vector_base& other) const -> bool {
        return m_ptr_vector > other.m_ptr_vector;
    }

    auto operator>=(const ptr_vector_base& other) const -> bool {
        return m_ptr_vector >= other.m_ptr_vector;
    }
#endif

private:
    auto range_check(size_type pos) const -> void {
        if (pos >= size()) {
            std::stringstream ss;
            ss << "muc::impl::ptr_vector_base::range_check: pos >= size() "
               << '[' << pos << " >= " << size() << ']';
            throw std::out_of_range{ss.str()};
        }
    }

    template<typename... Args>
    auto allocate_ptr(Args&&... args) const ->
        typename raw_ptr_vector::value_type {
        return static_cast<const Derived*>(this)->allocate_ptr(
            std::forward<Args>(args)...);
    }

protected:
    raw_ptr_vector m_ptr_vector;
};

} // namespace muc::impl

#include <initializer_list>
#include <iterator>
#include <memory>
#include <memory_resource>
#include <type_traits>
#include <utility>
#include <vector>

namespace muc {

template<typename T, typename Allocator = typename std::allocator<T>>
class shared_ptr_vector :
    public impl::ptr_vector_base<
        shared_ptr_vector<T, Allocator>,
        std::vector<std::shared_ptr<T>,
                    typename std::allocator_traits<Allocator>::
                        template rebind_alloc<std::shared_ptr<T>>>> {
    static_assert(not std::is_reference_v<T>,
                  "value type of muc::shared_ptr_vector cannot be a reference");
    static_assert(not std::is_array_v<T>,
                  "value type of muc::shared_ptr_vector cannot be an array");
    static_assert(std::is_same_v<typename Allocator::value_type, T>,
                  "muc::shared_ptr_vector must have the same value_type as its "
                  "allocator");

private:
    using base = impl::ptr_vector_base<
        shared_ptr_vector<T, Allocator>,
        std::vector<std::shared_ptr<T>,
                    typename std::allocator_traits<
                        Allocator>::template rebind_alloc<std::shared_ptr<T>>>>;

    friend base; // for access allocate_ptr

public:
    shared_ptr_vector() noexcept(noexcept(Allocator{})) = default;

    explicit shared_ptr_vector(const Allocator& alloc) noexcept :
        base{typename base::raw_ptr_vector::allocator_type{alloc}} {}
#if false
    shared_ptr_vector(size_type count, const T& value,
                      const Allocator& alloc = {}) :
        base{count, alloc} {
        for (auto&& ptr : this->m_ptr_vector) {
            ptr = allocate_ptr(value);
        }
    }

    shared_ptr_vector(size_type count, const Allocator& alloc = {}) :
        base{count, alloc} {
        for (auto&& ptr : this->m_ptr_vector) {
            ptr = allocate_ptr();
        }
    }

    template<typename InputIt>
    shared_ptr_vector(InputIt first, InputIt last,
                      const Allocator& alloc = {}) :
        base{alloc} {
        this->insert(this->cend(), first, last);
    }
#endif
    shared_ptr_vector(const shared_ptr_vector&) = default;

    shared_ptr_vector(shared_ptr_vector&&) noexcept = default;

    shared_ptr_vector(const shared_ptr_vector& other, const Allocator& alloc) :
        base{other.m_ptr_vector,
             typename base::raw_ptr_vector::allocator_type{alloc}} {}

    shared_ptr_vector(shared_ptr_vector&& other, const Allocator& alloc) :
        base{std::move(other.m_ptr_vector),
             typename base::raw_ptr_vector::allocator_type{alloc}} {}

    shared_ptr_vector(const typename base::raw_ptr_vector& ptr_vector,
                      const Allocator& alloc = {}) :
        base{ptr_vector, typename base::raw_ptr_vector::allocator_type{alloc}} {
    }

    shared_ptr_vector(typename base::raw_ptr_vector&& ptr_vector,
                      const Allocator& alloc = {}) :
        base{std::move(ptr_vector),
             typename base::raw_ptr_vector::allocator_type{alloc}} {}

    template<
        typename C,
        std::enable_if_t<std::is_lvalue_reference_v<const C&>, bool> = true,
        typename = std::void_t<decltype(std::begin(std::declval<const C&>()))>,
        typename = std::void_t<decltype(std::end(std::declval<const C&>()))>,
        std::enable_if_t<
            std::is_constructible_v<typename base::raw_ptr_vector::value_type,
                                    decltype(*std::begin(std::declval<C>())++)>,
            bool> = true>
    shared_ptr_vector(const C& ptr_vector, const Allocator& alloc = {}) :
        shared_ptr_vector{alloc} {
        auto first{std::begin(ptr_vector)};
        const auto last{std::end(ptr_vector)};
        this->reserve(std::distance(first, last));
        while (first != last) {
            this->m_ptr_vector.push_back(
                typename base::raw_ptr_vector::value_type{*first++});
        }
    }

    template<typename C,
             std::enable_if_t<std::is_rvalue_reference_v<C&&>, bool> = true,
             typename = std::void_t<decltype(std::begin(std::declval<C>()))>,
             typename = std::void_t<decltype(std::end(std::declval<C>()))>,
             std::enable_if_t<
                 std::is_constructible_v<
                     typename base::raw_ptr_vector::value_type,
                     decltype(std::move(*std::begin(std::declval<C>())++))>,
                 bool> = true>
    shared_ptr_vector(C&& ptr_vector, const Allocator& alloc = {}) :
        shared_ptr_vector{alloc} {
        auto first{std::begin(ptr_vector)};
        const auto last{std::end(ptr_vector)};
        this->reserve(std::distance(first, last));
        while (first != last) {
            this->m_ptr_vector.push_back(
                typename base::raw_ptr_vector::value_type{std::move(*first++)});
        }
    }
#if false
    shared_ptr_vector(std::initializer_list<T> init,
                      const Allocator& alloc = {}) :
        base{alloc} {
        this->insert(this->cend(), std::move(init));
    }
#endif
private:
    template<typename... Args>
    auto allocate_ptr(Args&&... args) const -> std::shared_ptr<T> {
        return std::allocate_shared<T>(this->get_allocator(),
                                       std::forward<Args>(args)...);
    }
};

template<typename T, typename Allocator>
auto swap(shared_ptr_vector<T, Allocator>& lhs,
          shared_ptr_vector<T, Allocator>&
              rhs) noexcept(noexcept(lhs.swap(rhs))) -> void {
    lhs.swap(rhs);
}

namespace pmr {

template<typename T>
using shared_ptr_vector =
    ::muc::shared_ptr_vector<T, std::pmr::polymorphic_allocator<T>>;

} // namespace pmr

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <initializer_list>
#include <iterator>
#include <memory>
#include <memory_resource>
#include <type_traits>
#include <utility>
#include <vector>

namespace muc {

template<typename T, typename Allocator = typename std::allocator<T>>
class unique_ptr_vector :
    public impl::ptr_vector_base<
        unique_ptr_vector<T, Allocator>,
        std::vector<
            std::unique_ptr<T, allocator_delete<Allocator>>,
            typename std::allocator_traits<Allocator>::template rebind_alloc<
                std::unique_ptr<T, allocator_delete<Allocator>>>>> {
    static_assert(not std::is_reference_v<T>,
                  "value type of muc::unique_ptr_vector cannot be a reference");
    static_assert(not std::is_array_v<T>,
                  "value type of muc::unique_ptr_vector cannot be an array");
    static_assert(std::is_same_v<typename Allocator::value_type, T>,
                  "muc::shared_ptr_vector must have the same value_type as its "
                  "allocator");

private:
    using base = impl::ptr_vector_base<
        unique_ptr_vector<T, Allocator>,
        std::vector<
            std::unique_ptr<T, allocator_delete<Allocator>>,
            typename std::allocator_traits<Allocator>::template rebind_alloc<
                std::unique_ptr<T, allocator_delete<Allocator>>>>>;

    friend base; // for access allocate_ptr

public:
    unique_ptr_vector() noexcept(noexcept(Allocator{})) = default;

    explicit unique_ptr_vector(const Allocator& alloc) noexcept :
        base{typename base::raw_ptr_vector::allocator_type{alloc}} {}
#if false
    unique_ptr_vector(size_type count, const T& value,
                      const Allocator& alloc = {}) :
        base{count, alloc} {
        for (auto&& ptr : this->m_ptr_vector) {
            ptr = allocate_ptr(value);
        }
    }

    explicit unique_ptr_vector(size_type count, const Allocator& alloc = {}) :
        base{count, alloc} {
        for (auto&& ptr : this->m_ptr_vector) {
            ptr = allocate_ptr();
        }
    }

    template<typename InputIt>
    unique_ptr_vector(InputIt first, InputIt last,
                      const Allocator& alloc = {}) :
        base{alloc} {
        this->insert(this->cend(), first, last);
    }
#endif
    unique_ptr_vector(const unique_ptr_vector&) = default;

    unique_ptr_vector(unique_ptr_vector&&) noexcept = default;

    unique_ptr_vector(const unique_ptr_vector& other, const Allocator& alloc) :
        base{other.m_ptr_vector,
             typename base::raw_ptr_vector::allocator_type{alloc}} {}

    unique_ptr_vector(unique_ptr_vector&& other, const Allocator& alloc) :
        base{std::move(other.m_ptr_vector),
             typename base::raw_ptr_vector::allocator_type{alloc}} {}

    unique_ptr_vector(const typename base::raw_ptr_vector& ptr_vector,
                      const Allocator& alloc = {}) :
        base{ptr_vector, typename base::raw_ptr_vector::allocator_type{alloc}} {
    }

    unique_ptr_vector(typename base::raw_ptr_vector&& ptr_vector,
                      const Allocator& alloc = {}) :
        base{std::move(ptr_vector),
             typename base::raw_ptr_vector::allocator_type{alloc}} {}

    template<
        typename C,
        std::enable_if_t<std::is_lvalue_reference_v<const C&>, bool> = true,
        typename = std::void_t<decltype(std::begin(std::declval<const C&>()))>,
        typename = std::void_t<decltype(std::end(std::declval<const C&>()))>,
        std::enable_if_t<
            std::is_constructible_v<typename base::raw_ptr_vector::value_type,
                                    decltype(*std::begin(std::declval<C>())++)>,
            bool> = true>
    unique_ptr_vector(const C& ptr_vector, const Allocator& alloc = {}) :
        unique_ptr_vector{alloc} {
        auto first{std::begin(ptr_vector)};
        const auto last{std::end(ptr_vector)};
        this->reserve(std::distance(first, last));
        while (first != last) {
            this->m_ptr_vector.push_back(
                typename base::raw_ptr_vector::value_type{*first++});
        }
    }

    template<typename C,
             std::enable_if_t<std::is_rvalue_reference_v<C&&>, bool> = true,
             typename = std::void_t<decltype(std::begin(std::declval<C>()))>,
             typename = std::void_t<decltype(std::end(std::declval<C>()))>,
             std::enable_if_t<
                 std::is_constructible_v<
                     typename base::raw_ptr_vector::value_type,
                     decltype(std::move(*std::begin(std::declval<C>())++))>,
                 bool> = true>
    unique_ptr_vector(C&& ptr_vector, const Allocator& alloc = {}) :
        unique_ptr_vector{alloc} {
        auto first{std::begin(ptr_vector)};
        const auto last{std::end(ptr_vector)};
        this->reserve(std::distance(first, last));
        while (first != last) {
            this->m_ptr_vector.push_back(
                typename base::raw_ptr_vector::value_type{std::move(*first++)});
        }
    }
#if false
    unique_ptr_vector(std::initializer_list<T> init,
                      const Allocator& alloc = {}) :
        base{alloc} {
        this->insert(this->cend(), std::move(init));
    }
#endif
private:
    template<typename... Args>
    auto allocate_ptr(Args&&... args) const
        -> std::unique_ptr<T, allocator_delete<Allocator>> {
        return allocate_unique<T>(this->get_allocator(),
                                  std::forward<Args>(args)...);
    }
};

template<typename T, typename Allocator>
auto swap(unique_ptr_vector<T, Allocator>& lhs,
          unique_ptr_vector<T, Allocator>&
              rhs) noexcept(noexcept(lhs.swap(rhs))) -> void {
    lhs.swap(rhs);
}

namespace pmr {

template<typename T>
using unique_ptr_vector =
    ::muc::unique_ptr_vector<T, std::pmr::polymorphic_allocator<T>>;

} // namespace pmr

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_TIME_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_TIME_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// Linux/BSD implementation:
#if (defined linux or defined __linux__ or defined __linux) or             \
    (defined __DragonFly__ or defined __FreeBSD__ or defined __NetBSD__ or \
     defined __OpenBSD__)
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <ctime>
#include <sys/time.h>

namespace muc::impl {

template<typename Time>
class cpu_time_stopwatch {
public:
    cpu_time_stopwatch() noexcept :
        m_t0{} {
        clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &m_t0);
    }

    auto s_used() const noexcept -> Time {
        return ns_used() / 1'000'000'000;
    }

    auto ms_used() const noexcept -> Time {
        return ns_used() / 1'000'000;
    }

    auto us_used() const noexcept -> Time {
        return ns_used() / 1'000;
    }

    auto ns_used() const noexcept -> Time {
        std::timespec t;
        clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &t);
        return static_cast<Time>(t.tv_sec - m_t0.tv_sec) * 1'000'000'000 +
               static_cast<Time>(t.tv_nsec - m_t0.tv_nsec);
    }

private:
    std::timespec m_t0;
};

} // namespace muc::impl
// Windows implementation:
#elif defined _WIN32
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#if defined _MSC_VER and not defined __clang__ and not defined __GNUC__ and \
    not defined NOMINMAX
#define NOMINMAX // Otherwise MS compilers act like idiots when using
                 // std::numeric_limits<>::max() and including windows.h
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#undef WIN32_LEAN_AND_MEAN
#else
#include <windows.h>
#endif

#include <cstring>
#include <type_traits>

namespace muc::impl {

template<typename Time>
class cpu_time_stopwatch {
public:
    cpu_time_stopwatch() noexcept :
        m_current_process{GetCurrentProcess()},
        m_t0{clock_in_100ns()} {}

    auto s_used() const noexcept -> Time {
        return hecto_ns_used() / 10'000'000;
    }

    auto ms_used() const noexcept -> Time {
        return hecto_ns_used() / 10'000;
    }

    auto us_used() const noexcept -> Time {
        return hecto_ns_used() / 10;
    }

    auto ns_used() const noexcept -> Time {
        return hecto_ns_used() * 100;
    }

private:
    auto hecto_ns_used() const noexcept -> Time {
        return static_cast<Time>(clock_in_100ns().QuadPart - m_t0.QuadPart);
    }

    auto clock_in_100ns() const noexcept -> ULARGE_INTEGER {
        FILETIME t_creation;
        FILETIME t_exit;
        FILETIME t_kernel;
        FILETIME t_user;
        GetProcessTimes(m_current_process, &t_creation, &t_exit, &t_kernel,
                        &t_user);
        ULARGE_INTEGER t;
        static_assert(sizeof(FILETIME) == sizeof(ULARGE_INTEGER));
        static_assert(std::is_trivially_copyable_v<FILETIME>);
        static_assert(std::is_trivially_copyable_v<ULARGE_INTEGER>);
        std::memcpy(&t, &t_user, sizeof(FILETIME));
        return t;
    }

private:
    HANDLE m_current_process;
    ULARGE_INTEGER m_t0;
};

} // namespace muc::impl
// Fallback implementation:
#else
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <ctime>

namespace muc::impl {

template<typename Time>
class cpu_time_stopwatch {
public:
    cpu_time_stopwatch() noexcept :
        m_t0{std::clock()} {}

    auto s_used() const noexcept -> Time {
        static_cast<Time>(std::clock() - m_t0) / CLOCKS_PER_SEC;
    }

    auto ms_used() const noexcept -> Time {
        return s_used() * 1'000;
    }

    auto us_used() const noexcept -> Time {
        return s_used() * 1'000'000;
    }

    auto ns_used() const noexcept -> Time {
        return s_used() * 1'000'000'000;
    }

private:
    std::clock_t m_t0;
};

} // namespace muc::impl
#endif

#include <limits>
#include <type_traits>

namespace muc {

/// @brief CPU stopwatch better than std::clock() when available.
template<typename Time = double>
class cpu_time_stopwatch final : protected impl::cpu_time_stopwatch<Time> {
    static_assert(std::is_floating_point_v<Time>,
                  "the value type for stopwatch should be a floating point");
    static_assert(std::numeric_limits<Time>::digits >=
                      std::numeric_limits<double>::digits,
                  "stopwatch value type should be at least as long as double");

public:
    using value_type = Time;

public:
    auto s_used() const noexcept -> value_type {
        return impl::cpu_time_stopwatch<Time>::s_used();
    }

    auto ms_used() const noexcept -> value_type {
        return impl::cpu_time_stopwatch<Time>::ms_used();
    }

    auto us_used() const noexcept -> value_type {
        return impl::cpu_time_stopwatch<Time>::us_used();
    }

    auto ns_used() const noexcept -> value_type {
        return impl::cpu_time_stopwatch<Time>::ns_used();
    }
};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// Copyright (c) 2022, Matthew Bentley (mattreecebentley@gmail.com)
// www.plflib.org

// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgement in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.


// Linux/BSD implementation:
#if (defined linux or defined __linux__ or defined __linux) or             \
    (defined __DragonFly__ or defined __FreeBSD__ or defined __NetBSD__ or \
     defined __OpenBSD__)
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// Copyright (c) 2022, Matthew Bentley (mattreecebentley@gmail.com)
// www.plflib.org

// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgement in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.


#include <ctime>
#include <sys/time.h>

namespace muc::impl {

template<typename Time>
class wall_time_stopwatch {
public:
    wall_time_stopwatch() noexcept :
        m_t0{} {
        clock_gettime(CLOCK_MONOTONIC, &m_t0);
    }

    auto s_elapsed() const noexcept -> Time {
        return ns_elapsed() / 1'000'000'000;
    }

    auto ms_elapsed() const noexcept -> Time {
        return ns_elapsed() / 1'000'000;
    }

    auto us_elapsed() const noexcept -> Time {
        return ns_elapsed() / 1'000;
    }

    auto ns_elapsed() const noexcept -> Time {
        std::timespec t;
        clock_gettime(CLOCK_MONOTONIC, &t);
        return static_cast<Time>(t.tv_sec - m_t0.tv_sec) * 1'000'000'000 +
               static_cast<Time>(t.tv_nsec - m_t0.tv_nsec);
    }

private:
    std::timespec m_t0;
};

} // namespace muc::impl
// Windows implementation:
#elif defined _WIN32
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// Copyright (c) 2022, Matthew Bentley (mattreecebentley@gmail.com)
// www.plflib.org

// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgement in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.


#if defined _MSC_VER and not defined __clang__ and not defined __GNUC__ and \
    not defined NOMINMAX
#define NOMINMAX // Otherwise MS compilers act like idiots when using
                 // std::numeric_limits<>::max() and including windows.h
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#undef WIN32_LEAN_AND_MEAN
#else
#include <windows.h>
#endif

namespace muc::impl {

template<typename Time>
class wall_time_stopwatch {
public:
    wall_time_stopwatch() noexcept :
        m_frequency{},
        m_t0{} {
        QueryPerformanceFrequency(&m_frequency);
        QueryPerformanceCounter(&m_t0);
    }

    auto s_elapsed() const noexcept -> Time {
        LARGE_INTEGER t;
        QueryPerformanceCounter(&t);
        return static_cast<Time>(t.QuadPart - m_t0.QuadPart) /
               m_frequency.QuadPart;
    }

    auto ms_elapsed() const noexcept -> Time {
        return s_elapsed() * 1'000;
    }

    auto us_elapsed() const noexcept -> Time {
        return s_elapsed() * 1'000'000;
    }

    auto ns_elapsed() const noexcept -> Time {
        return s_elapsed() * 1'000'000'000;
    }

private:
    LARGE_INTEGER m_frequency;
    LARGE_INTEGER m_t0;
};

} // namespace muc::impl
// Fallback implementation:
#else
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <chrono>

namespace muc::impl {

template<typename Time>
class wall_time_stopwatch {
private:
    using sc = std::chrono::steady_clock;
    using s = std::chrono::duration<Time, std::ratio<1>>;
    using ms = std::chrono::duration<Time, std::milli>;
    using us = std::chrono::duration<Time, std::micro>;
    using ns = std::chrono::duration<Time, std::nano>;

public:
    wall_time_stopwatch() noexcept :
        m_t0{sc::now()} {}

    auto s_elapsed() const noexcept -> Time {
        s{sc::now() - m_t0}.count();
    }

    auto ms_elapsed() const noexcept -> Time {
        ms{sc::now() - m_t0}.count();
    }

    auto us_elapsed() const noexcept -> Time {
        us{sc::now() - m_t0}.count();
    }

    auto ns_elapsed() const noexcept -> Time {
        ns{sc::now() - m_t0}.count();
    }

private:
    sc::time_point m_t0;
};

} // namespace muc::impl
#endif

#include <limits>
#include <type_traits>

namespace muc {

/// @brief high-precision cross-platform (linux/bsd/windows/etc.) simple
/// stopwatch class
template<typename Time = double>
class wall_time_stopwatch : protected impl::wall_time_stopwatch<Time> {
    static_assert(std::is_floating_point_v<Time>,
                  "the value type for stopwatch should be a floating point");
    static_assert(std::numeric_limits<Time>::digits >=
                      std::numeric_limits<double>::digits,
                  "stopwatch value type should be at least as long as double");

public:
    using value_type = Time;

public:
    auto s_elapsed() const noexcept -> value_type {
        return impl::wall_time_stopwatch<Time>::s_elapsed();
    }

    auto ms_elapsed() const noexcept -> value_type {
        return impl::wall_time_stopwatch<Time>::ms_elapsed();
    }

    auto us_elapsed() const noexcept -> value_type {
        return impl::wall_time_stopwatch<Time>::us_elapsed();
    }

    auto ns_elapsed() const noexcept -> value_type {
        return impl::wall_time_stopwatch<Time>::ns_elapsed();
    }
};

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_TUPLE_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_TUPLE_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 202002L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <concepts>
#include <type_traits>
#include <utility>

namespace muc {

namespace impl {

template<typename T, std::size_t I>
concept has_tuple_element_and_get = requires(T t) {
    typename std::tuple_element_t<I, T>;
    { get<I>(t) } -> std::convertible_to<const std::tuple_element_t<I, T>&>;
};

} // namespace impl

template<typename T>
concept tuple_like = requires {
    requires not std::is_reference_v<T>;
    typename std::tuple_size<T>::type;
    requires std::derived_from<
        std::tuple_size<T>,
        std::integral_constant<std::size_t, std::tuple_size_v<T>>>;
    requires([]<std::size_t... Is>(std::index_sequence<Is...>) {
        return (... and impl::has_tuple_element_and_get<T, Is>);
    }(std::make_index_sequence<std::tuple_size_v<T>>()));
};

} // namespace muc

#include <functional>
#include <utility>

namespace muc {

namespace impl {

template<typename F, typename T, std::size_t... Is>
    requires tuple_like<std::decay_t<T>>
constexpr auto apply(F&& f, T&& t, std::index_sequence<Is...>) noexcept(
    noexcept(std::invoke(std::forward<F>(f),
                         get<Is>(std::forward<T>(t))...))) -> decltype(auto) {
    return std::invoke(std::forward<F>(f), get<Is>(std::forward<T>(t))...);
}

} // namespace impl

template<typename F, typename T>
    requires tuple_like<std::decay_t<T>>
constexpr auto apply(F&& f, T&& t) noexcept(noexcept(impl::apply(
    std::forward<F>(f), std::forward<T>(t),
    std::make_index_sequence<std::tuple_size_v<std::decay_t<T>>>{})))
    -> decltype(auto) {
    return impl::apply(
        std::forward<F>(f), std::forward<T>(t),
        std::make_index_sequence<std::tuple_size_v<std::decay_t<T>>>{});
}

} // namespace muc

#include <utility>

namespace muc {

template<typename F, typename T>
concept applicable_on = requires(F&& Func, T&& t) {
    requires tuple_like<T>;
    { apply(std::forward<F>(Func), std::forward<T>(t)) };
};

template<typename F, typename T>
concept predicate_applicable_on = requires(F&& Func, T&& t) {
    requires tuple_like<T>;
    { apply(std::forward<F>(Func), std::forward<T>(t)) } -> boolean_testable;
};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



namespace muc {

template<typename T>
concept pair_like = requires {
    requires tuple_like<T>;
    requires std::tuple_size_v<T> == 2;
};

} // namespace muc

#ifdef MUS_STATIC_TEST

static_assert(muc::pair_like<std::pair<int, double>>);
static_assert(muc::pair_like<std::tuple<int, double>>);
static_assert(not muc::pair_like<std::tuple<double>>);
static_assert(not muc::pair_like<int>);

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <tuple>

namespace muc {

namespace impl {

template<tuple_like, std::size_t, std::size_t, tuple_like>
struct to_std_tuple_helper;

template<tuple_like T, std::size_t I, std::size_t N, typename... Ts>
struct to_std_tuple_helper<T, I, N, std::tuple<Ts...>> :
    to_std_tuple_helper<T, I + 1, N,
                        std::tuple<Ts..., std::tuple_element_t<I, T>>> {};

template<tuple_like T, std::size_t N, typename... Ts>
struct to_std_tuple_helper<T, N, N, std::tuple<Ts...>> {
    using type = std::tuple<Ts...>;
};

} // namespace impl

template<tuple_like T>
struct to_std_tuple :
    impl::to_std_tuple_helper<T, 0, std::tuple_size_v<T>, std::tuple<>> {};

template<tuple_like T>
using to_std_tuple_t = typename to_std_tuple<T>::type;

} // namespace muc

#ifdef MUC_STATIC_TEST

#include <concepts>

static_assert(
    std::same_as<muc::to_std_tuple_t<std::tuple<int>>, std::tuple<int>>);
static_assert(
    std::same_as<muc::to_std_tuple_t<std::tuple<int>>, std::tuple<int>>);
static_assert(
    std::same_as<muc::to_std_tuple_t<std::pair<int, int>>, std::tuple<int, int>>);
static_assert(std::same_as<muc::to_std_tuple_t<std::pair<int, double>>,
                           std::tuple<int, double>>);
static_assert(std::same_as<muc::to_std_tuple_t<std::tuple<int, double>>,
                           std::tuple<int, double>>);
static_assert(std::same_as<muc::to_std_tuple_t<std::tuple<>>, std::tuple<>>);

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <tuple>

namespace muc {

namespace impl {

template<tuple_like...>
struct std_tuple_concat;

template<>
struct std_tuple_concat<> {
    using type = std::tuple<>;
};

template<typename... Ts>
struct std_tuple_concat<std::tuple<Ts...>> {
    using type = std::tuple<Ts...>;
};

template<typename... Ts, typename... Us, typename... Vs>
struct std_tuple_concat<std::tuple<Ts...>, std::tuple<Us...>, Vs...> :
    std_tuple_concat<std::tuple<Ts..., Us...>, Vs...> {};

template<tuple_like... Ts>
using std_tuple_concat_t = typename std_tuple_concat<Ts...>::type;

} // namespace impl

template<tuple_like... Ts>
struct tuple_concat : impl::std_tuple_concat<to_std_tuple_t<Ts>...> {};

template<tuple_like... Ts>
using tuple_concat_t = typename tuple_concat<Ts...>::type;

} // namespace muc

#ifdef MUC_STATIC_TEST

#include <concepts>

static_assert(std::same_as<muc::tuple_concat_t<std::tuple<double, int>,
                                               std::tuple<float, short>>,
                           std::tuple<double, int, float, short>>);
static_assert(std::same_as<muc::tuple_concat_t<std::tuple<double, int>,
                                               std::pair<float, short>>,
                           std::tuple<double, int, float, short>>);
static_assert(std::same_as<muc::tuple_concat_t<std::pair<double, int>,
                                               std::tuple<float, short>>,
                           std::tuple<double, int, float, short>>);
static_assert(std::same_as<muc::tuple_concat_t<std::pair<double, int>,
                                               std::pair<float, short>>,
                           std::tuple<double, int, float, short>>);
static_assert(
    std::same_as<muc::tuple_concat_t<std::tuple<double, int>, std::tuple<>>,
                 std::tuple<double, int>>);
static_assert(
    std::same_as<muc::tuple_concat_t<std::tuple<>, std::tuple<double, int>>,
                 std::tuple<double, int>>);
static_assert(std::same_as<muc::tuple_concat_t<std::tuple<int>, std::tuple<>>,
                           std::tuple<int>>);
static_assert(std::same_as<muc::tuple_concat_t<std::tuple<>, std::tuple<int>>,
                           std::tuple<int>>);
static_assert(std::same_as<muc::tuple_concat_t<std::tuple<>, std::tuple<>>,
                           std::tuple<>>);

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <concepts>
#include <tuple>
#include <type_traits>

namespace muc {

namespace impl {

template<tuple_like, typename>
struct std_tuple_count;

template<typename... Ts, typename T>
struct std_tuple_count<std::tuple<Ts...>, T> :
    std::integral_constant<std::size_t,
                           (0 + ... +
                            static_cast<std::size_t>(std::same_as<T, Ts>))> {};

} // namespace impl

template<tuple_like T, typename U>
struct tuple_count : impl::std_tuple_count<to_std_tuple_t<T>, U> {};

template<tuple_like T, typename U>
inline constexpr auto tuple_count_v{tuple_count<T, U>::value};

} // namespace muc

#ifdef MUC_STATIC_TEST

static_assert(muc::tuple_count_v<std::tuple<int, double>, int> == 1);
static_assert(muc::tuple_count_v<std::tuple<int, int>, int> == 2);
static_assert(muc::tuple_count_v<std::tuple<int, double>, float> == 0);
static_assert(muc::tuple_count_v<std::tuple<>, float> == 0);

#endif

#include <type_traits>

namespace muc {

template<tuple_like T, typename U>
struct tuple_contains :
    std::conditional_t<tuple_count_v<T, U> >= 1, std::true_type,
                       std::false_type> {};

template<tuple_like T, typename U>
inline constexpr auto tuple_contains_v = tuple_contains<T, U>::value;

template<tuple_like T, typename U>
struct tuple_contains_unique :
    std::conditional_t<tuple_count_v<T, U> == 1, std::true_type,
                       std::false_type> {};

template<tuple_like T, typename U>
inline constexpr auto tuple_contains_unique_v{
    tuple_contains_unique<T, U>::value};

} // namespace muc

#ifdef MUC_STATIC_TEST

static_assert(muc::tuple_contains_v<std::pair<double, int>, int>);
static_assert(muc::tuple_contains_v<std::tuple<int, double, int>, int>);
static_assert(not muc::tuple_contains_v<std::tuple<>, int>);

static_assert(muc::tuple_contains_unique_v<std::pair<double, int>, int>);
static_assert(
    not muc::tuple_contains_unique_v<std::tuple<int, double, int>, int>);
static_assert(not muc::tuple_contains_unique_v<std::tuple<>, int>);

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <tuple>
#include <type_traits>

namespace muc {

namespace impl {

template<typename, typename>
struct tuple_unique;

template<typename... Us>
struct tuple_unique<std::tuple<>, std::tuple<Us...>> {
    using type = std::tuple<Us...>;
};

template<typename T, typename... Ts, typename... Us>
    requires tuple_contains_v<std::tuple<Us...>, T>
struct tuple_unique<std::tuple<T, Ts...>, std::tuple<Us...>> {
    using type =
        typename tuple_unique<std::tuple<Ts...>, std::tuple<Us...>>::type;
};

template<typename T, typename... Ts, typename... Us>
struct tuple_unique<std::tuple<T, Ts...>, std::tuple<Us...>> {
    using type =
        typename tuple_unique<std::tuple<Ts...>, std::tuple<Us..., T>>::type;
};

} // namespace impl

template<tuple_like T>
struct tuple_unique {
    using type =
        typename impl::tuple_unique<to_std_tuple_t<T>, std::tuple<>>::type;
};

template<tuple_like T>
using tuple_unique_t = typename tuple_unique<T>::type;

} // namespace muc

#ifdef MUC_STATIC_TEST

#include <concepts>

static_assert(std::same_as<muc::tuple_unique_t<std::tuple<>>, std::tuple<>>);
static_assert(
    std::same_as<muc::tuple_unique_t<std::tuple<int>>, std::tuple<int>>);
static_assert(
    std::same_as<muc::tuple_unique_t<std::tuple<int, int>>, std::tuple<int>>);
static_assert(std::same_as<muc::tuple_unique_t<std::tuple<int, int, int>>,
                           std::tuple<int>>);
static_assert(
    std::same_as<muc::tuple_unique_t<std::tuple<int, double, short, short>>,
                 std::tuple<int, double, short>>);
static_assert(std::same_as<
              muc::tuple_unique_t<std::tuple<short, int, short, long, short>>,
              std::tuple<short, int, long>>);

#endif
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_TYPE_TRAITS_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_TYPE_TRAITS_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 202002L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <tuple>
#include <type_traits>

namespace muc {

template<typename... Ts>
struct is_type_set :
    std::bool_constant<(... and tuple_contains_unique_v<std::tuple<Ts...>, Ts>)> {
};

template<typename... Ts>
inline constexpr auto is_type_set_v = is_type_set<Ts...>::value;

} // namespace muc

#ifdef MUC_STATIC_TEST

static_assert(muc::is_type_set_v<>);
static_assert(muc::is_type_set_v<int>);
static_assert(muc::is_type_set_v<int, double>);
static_assert(not muc::is_type_set_v<int, int>);
static_assert(not muc::is_type_set_v<int, int, double>);

#endif
#endif

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <type_traits>
#include <utility>

namespace muc {

template<typename T, typename U>
struct is_arithmetic_operable_with :
    std::bool_constant<
        is_general_arithmetic_v<T> and is_general_arithmetic_v<U> and
        // T <-> {U}
        impl::has_binary_arithmetic_with_v<T, U> and
        impl::has_binary_arithmetic_with_v<
            T,
            decltype(std::declval<const U&>() + std::declval<const U&>())> and
        impl::has_binary_arithmetic_with_v<
            T,
            decltype(std::declval<const U&>() - std::declval<const U&>())> and
        /* impl::has_binary_arithmetic_with_v<
            U, decltype(+std::declval<const U&>())> and */
        impl::has_binary_arithmetic_with_v<
            U, decltype(-std::declval<const U&>())> and
        impl::has_binary_arithmetic_with_v<
            T, decltype(1 * std::declval<const U&>())> and
        /* impl::has_binary_arithmetic_with_v<
            T, decltype(std::declval<const U&>() * 1)> and
        impl::has_binary_arithmetic_with_v<
            T, decltype(std::declval<const U&>() / 1)> and */
        // T <-> {T <-> U}
        impl::has_binary_arithmetic_with_v<
            T,
            decltype(std::declval<const T&>() + std::declval<const U&>())> and
        impl::has_binary_arithmetic_with_v<
            T,
            decltype(std::declval<const T&>() - std::declval<const U&>())> and
        impl::has_binary_arithmetic_with_v<
            T,
            decltype(std::declval<const U&>() + std::declval<const T&>())> and
        impl::has_binary_arithmetic_with_v<
            T,
            decltype(std::declval<const U&>() - std::declval<const T&>())> and
        // U <-> {T}
        impl::has_binary_arithmetic_with_v<U, T> and
        impl::has_binary_arithmetic_with_v<
            U,
            decltype(std::declval<const T&>() + std::declval<const T&>())> and
        impl::has_binary_arithmetic_with_v<
            U,
            decltype(std::declval<const T&>() - std::declval<const T&>())> and
        /* impl::has_binary_arithmetic_with_v<
            U, decltype(+std::declval<const T&>())> and */
        impl::has_binary_arithmetic_with_v<
            U, decltype(-std::declval<const T&>())> and
        impl::has_binary_arithmetic_with_v<
            U, decltype(1 * std::declval<const T&>())> and
        /* impl::has_binary_arithmetic_with_v<
            U, decltype(std::declval<const T&>() * 1)> and
        impl::has_binary_arithmetic_with_v<
            U, decltype(std::declval<const T&>() / 1)> and */
        // U <-> {T <-> U}
        impl::has_binary_arithmetic_with_v<
            U,
            decltype(std::declval<const T&>() + std::declval<const U&>())> and
        impl::has_binary_arithmetic_with_v<
            U,
            decltype(std::declval<const T&>() - std::declval<const U&>())> and
        impl::has_binary_arithmetic_with_v<
            U,
            decltype(std::declval<const U&>() + std::declval<const T&>())> and
        impl::has_binary_arithmetic_with_v<
            U, decltype(std::declval<const U&>() - std::declval<const T&>())>> {
};

template<typename T, typename U>
inline constexpr bool is_arithmetic_operable_with_v{
    is_arithmetic_operable_with<T, U>::value};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <cstddef>
#include <type_traits>

namespace muc {

template<typename T>
struct is_bounded_array : std::false_type {};

template<typename T, std::size_t N>
struct is_bounded_array<T[N]> : std::true_type {};

template<typename T>
inline constexpr bool is_bounded_array_v{is_bounded_array<T>::value};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

template<typename T>
struct is_scoped_enum :
    std::bool_constant<
        std::is_enum_v<T> and
        not std::is_convertible_v<T, std::underlying_type_t<T>>> {};

template<typename T>
inline constexpr bool is_scoped_enum_v{is_scoped_enum<T>::value};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

template<class T>
struct is_unbounded_array : std::false_type {};

template<class T>
struct is_unbounded_array<T[]> : std::true_type {};

template<typename T>
inline constexpr bool is_unbounded_array_v{is_unbounded_array<T>::value};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

template<typename T>
struct remove_cref : std::remove_const<std::remove_reference_t<T>> {};

template<typename T>
using remove_cref_t = typename remove_cref<T>::type;

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

template<typename T>
struct remove_cvref {
    using type = std::remove_cv_t<std::remove_reference_t<T>>;
};

template<typename T>
using remove_cvref_t = typename remove_cvref<T>::type;

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

template<typename T>
struct remove_vref : std::remove_volatile<std::remove_reference_t<T>> {};

template<typename T>
using remove_vref_t = typename remove_vref<T>::type;

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


namespace muc {

template<typename T>
struct type_identity {
    using type = T;
};

template<typename T>
using type_identity_t = typename type_identity<T>::type;

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_UTILITY_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_UTILITY_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 202002L
#endif

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#if not __has_cpp_attribute(assume) and \
    not(defined __clang__ or defined __GNUC__ or defined _MSC_VER)
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#if __cplusplus >= 202002L // >= C++20
#include <version>
#ifdef __cpp_lib_unreachable // >= C++23
#define MUC_CPP_LIB_UNREACHABLE
#endif
#endif

#ifdef MUC_CPP_LIB_UNREACHABLE
#include <utility>
#endif

namespace muc {

[[noreturn]] inline auto unreachable() -> void {
#ifdef MUC_CPP_LIB_UNREACHABLE
    std::unreachable(); // C++23
#elif defined __clang__ or defined __GNUC__
    __builtin_unreachable();
#elif defined _MSC_VER
    __assume(false);
#endif
}

} // namespace muc

#undef MUC_CPP_LIB_UNREACHABLE
#endif

namespace muc {

constexpr auto assume(bool condition) noexcept -> void {
#if __has_cpp_attribute(assume)
    [[assume(condition)]]; // C++23
#elif defined __clang__
    __builtin_assume(condition);
#elif defined __GNUC__
    if (not condition) {
        __builtin_unreachable();
    }
#elif defined _MSC_VER
    __assume(condition);
#else
    if (not condition) {
        unreachable();
    }
#endif
}

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


namespace muc {

template<typename>
inline constexpr bool dependent_true{true};

template<typename>
inline constexpr bool dependent_false{false};

template<auto A, typename>
inline constexpr auto dependent_constexpr{A};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#if __cplusplus >= 202002L // >= C++20
#include <version>
#ifdef __cpp_lib_forward_like // >= C++23
#define MUC_CPP_LIB_FORWARD_LIKE
#endif
#endif

#include <utility>

#ifndef MUC_CPP_LIB_FORWARD_LIKE // backport
#include <type_traits>
#endif

namespace muc {

template<typename T, typename U>
[[nodiscard]] constexpr auto forward_like(U&& x) noexcept -> auto&& {
#ifdef MUC_CPP_LIB_FORWARD_LIKE // C++23
    return std::forward_like<T, U>(x);
#else // backport
    constexpr bool is_adding_const =
        std::is_const_v<std::remove_reference_t<T>>;
    if constexpr (std::is_lvalue_reference_v<T&&>) {
        if constexpr (is_adding_const) {
            return std::as_const(x);
        } else {
            return static_cast<U&>(x);
        }
    } else {
        if constexpr (is_adding_const) {
            return std::move(std::as_const(x));
        } else {
            return std::move(x);
        }
    }
#endif
}

} // namespace muc

#undef MUC_CPP_LIB_FORWARD_LIKE
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

template<typename T, std::enable_if_t<std::is_integral_v<T>, bool> = true>
constexpr auto to_signed(T k) -> std::make_signed_t<T> {
    return k;
}

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#if __cplusplus >= 202002L // >= C++20
#include <version>
#ifdef __cpp_lib_to_underlying // >= C++23
#define MUC_CPP_LIB_TO_UNDERLYING
#endif
#endif

#ifdef MUC_CPP_LIB_TO_UNDERLYING
#include <utility>
#else // backport
#include <type_traits>
#endif

namespace muc {

template<typename E>
constexpr auto to_underlying(E value) noexcept -> std::underlying_type_t<E> {
#ifdef MUC_CPP_LIB_TO_UNDERLYING
    return std::to_underlying<E>(value);
#else // backport
    return static_cast<typename std::underlying_type_t<E>>(value);
#endif
}

} // namespace muc

#undef MUC_CPP_LIB_TO_UNDERLYING
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

template<typename T, std::enable_if_t<std::is_integral_v<T>, bool> = true>
constexpr auto to_unsigned(T k) -> std::make_unsigned_t<T> {
    return k;
}

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <cstdlib>
#include <stdexcept>
#include <string>
#if __has_include(<cxxabi.h>)
#include <cxxabi.h>
#endif

namespace muc {

inline auto try_demangle(const char* name, int& status) -> std::string {
    status = 0;
    if constexpr (requires(int status) {
                      abi::__cxa_demangle(name, nullptr, nullptr, &status);
                  }) {
        const auto c_result{
            abi::__cxa_demangle(name, nullptr, nullptr, &status)};
        const std::string result{c_result};
        std::free(c_result);
        return result;
    } else {
        return name;
    }
}

inline auto try_demangle(const char* name) -> std::string {
    int status;
    const auto result{try_demangle(name, status)};
    if constexpr (requires(int status) {
                      abi::__cxa_demangle(name, nullptr, nullptr, &status);
                  }) {
        switch (status) {
        case 0:
            break;
        case 1:
            throw std::runtime_error{
                "abi::__cxa_demangle: A memory allocation failure occurred"};
        case 2:
            throw std::runtime_error{
                "abi::__cxa_demangle: mangled_name is not a valid name under "
                "the C++ ABI mangling rules"};
        case 3:
            throw std::runtime_error{
                "abi::__cxa_demangle: One of the arguments is invalid"};
        }
    }
    return result;
}

} // namespace muc
#endif

#endif
