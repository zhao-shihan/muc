#pragma once

// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_ARRAY_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_ARRAY_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <array>
#include <complex>
#include <cstdint>

namespace muc {

template<typename T>
using array2 = std::array<T, 2>;
template<typename T>
using array3 = std::array<T, 3>;
template<typename T>
using array4 = std::array<T, 4>;

template<std::size_t N>
using arrayi = std::array<int, N>;
template<std::size_t N>
using arrayl = std::array<long, N>;
template<std::size_t N>
using arrayll = std::array<long long, N>;
template<std::size_t N>
using arrayu = std::array<unsigned, N>;
template<std::size_t N>
using arrayul = std::array<unsigned long, N>;
template<std::size_t N>
using arrayull = std::array<unsigned long long, N>;
template<std::size_t N>
using arrayi8 = std::array<std::int8_t, N>;
template<std::size_t N>
using arrayi16 = std::array<std::int16_t, N>;
template<std::size_t N>
using arrayi32 = std::array<std::int32_t, N>;
template<std::size_t N>
using arrayi64 = std::array<std::int64_t, N>;
template<std::size_t N>
using arrayu8 = std::array<std::uint8_t, N>;
template<std::size_t N>
using arrayu16 = std::array<std::uint16_t, N>;
template<std::size_t N>
using arrayu32 = std::array<std::uint32_t, N>;
template<std::size_t N>
using arrayu64 = std::array<std::uint64_t, N>;
template<std::size_t N>
using arrayf = std::array<float, N>;
template<std::size_t N>
using arrayd = std::array<double, N>;
template<std::size_t N>
using arrayld = std::array<long double, N>;
template<std::size_t N>
using arraycf = std::array<std::complex<float>, N>;
template<std::size_t N>
using arraycd = std::array<std::complex<double>, N>;
template<std::size_t N>
using arraycld = std::array<std::complex<long double>, N>;

using array2i = arrayi<2>;
using array2l = arrayl<2>;
using array2ll = arrayll<2>;
using array2u = arrayu<2>;
using array2ul = arrayul<2>;
using array2ull = arrayull<2>;
using array2i8 = arrayi8<2>;
using array2i16 = arrayi16<2>;
using array2i32 = arrayi32<2>;
using array2i64 = arrayi64<2>;
using array2u8 = arrayu8<2>;
using array2u16 = arrayu16<2>;
using array2u32 = arrayu32<2>;
using array2u64 = arrayu64<2>;
using array2f = arrayf<2>;
using array2d = arrayd<2>;
using array2ld = arrayld<2>;
using array2cf = arraycf<2>;
using array2cd = arraycd<2>;
using array2cld = arraycld<2>;

using array3i = arrayi<3>;
using array3l = arrayl<3>;
using array3ll = arrayll<3>;
using array3u = arrayu<3>;
using array3ul = arrayul<3>;
using array3ull = arrayull<3>;
using array3i8 = arrayi8<3>;
using array3i16 = arrayi16<3>;
using array3i32 = arrayi32<3>;
using array3i64 = arrayi64<3>;
using array3u8 = arrayu8<3>;
using array3u16 = arrayu16<3>;
using array3u32 = arrayu32<3>;
using array3u64 = arrayu64<3>;
using array3f = arrayf<3>;
using array3d = arrayd<3>;
using array3ld = arrayld<3>;
using array3cf = arraycf<3>;
using array3cd = arraycd<3>;
using array3cld = arraycld<3>;

using array4i = arrayi<4>;
using array4l = arrayl<4>;
using array4ll = arrayll<4>;
using array4u = arrayu<4>;
using array4ul = arrayul<4>;
using array4ull = arrayull<4>;
using array4i8 = arrayi8<4>;
using array4i16 = arrayi16<4>;
using array4i32 = arrayi32<4>;
using array4i64 = arrayi64<4>;
using array4u8 = arrayu8<4>;
using array4u16 = arrayu16<4>;
using array4u32 = arrayu32<4>;
using array4u64 = arrayu64<4>;
using array4f = arrayf<4>;
using array4d = arrayd<4>;
using array4ld = arrayld<4>;
using array4cf = arraycf<4>;
using array4cd = arraycd<4>;
using array4cld = arraycld<4>;

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_BIT_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_BIT_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

#if __cplusplus >= 202002L // >= C++20
#include <bit>
#else // <= C++17
#include <cstring>
#endif

namespace muc {

#if __cplusplus >= 202002L // >= C++20

/// @brief A backport of std::bit_cast. Obtain a value of type To by
/// reinterpreting the object representation of From. Every bit in the value
/// representation of the returned To object is equal to the corresponding bit
/// in the object representation of from. The values of padding bits in the
/// returned To object are unspecified.
/// @note This implementation in C++17 additionally requires destination type to
/// be trivially constructible.
/// @tparam To destination type
/// @tparam From source type
/// @param src the source of bits for the return value
/// @return An object of type To whose value representation is as described
/// above.
template<typename To, typename From>
constexpr auto bit_cast(const From& src) noexcept -> To {
    return std::bit_cast<To>(src);
}

#else // <= C++17

/// @brief A backport of std::bit_cast. Obtain a value of type To by
/// reinterpreting the object representation of From. Every bit in the value
/// representation of the returned To object is equal to the corresponding bit
/// in the object representation of from. The values of padding bits in the
/// returned To object are unspecified.
/// @note This implementation in C++17 additionally requires destination type to
/// be trivially constructible.
/// @tparam To destination type
/// @tparam From source type
/// @param src the source of bits for the return value
/// @return An object of type To whose value representation is as described
/// above.
template<typename To, typename From>
auto bit_cast(const From& src) noexcept
    -> std::enable_if_t<sizeof(To) == sizeof(From) and
                            std::is_trivially_copyable_v<From> and
                            std::is_trivially_copyable_v<To>,
                        To> {
    static_assert(std::is_trivially_constructible_v<To>,
                  "This implementation additionally requires destination type "
                  "to be trivially constructible");
    To dst;
    std::memcpy(&dst, &src, sizeof(To));
    return dst;
}

#endif

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <climits>
#include <cstddef>

namespace muc {

template<typename T>
inline constexpr std::size_t bit_size{CHAR_BIT * sizeof(T)};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <algorithm>
#include <array>
#include <cstddef>
#include <type_traits>

namespace muc {

/// @brief Reverses the bytes in the given integer value.
/// @tparam T value type
/// @param value integer value
/// @return An integer value of type T whose object representation comprises the
/// bytes of that of value in reversed order.
template<typename T, std::enable_if_t<std::is_integral_v<T>, bool> = true>
auto byteswap(T value) noexcept -> T {
    static_assert(std::has_unique_object_representations_v<T>,
                  "T may not have padding bits");
    auto bit{muc::bit_cast<std::array<std::byte, sizeof(T)>>(value)};
    std::reverse(bit.begin(), bit.end());
    return muc::bit_cast<T>(bit);
}

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc::impl {

template<typename T>
struct is_really_unsigned_integral :
    std::bool_constant<std::is_unsigned_v<T> and not std::is_same_v<T, bool> and
                       not std::is_same_v<T, char> and
#if __cplusplus >= 202002L
                       not std::is_same_v<T, char8_t> and
#endif
                       not std::is_same_v<T, char16_t> and
                       not std::is_same_v<T, char32_t> and
                       not std::is_same_v<T, wchar_t>> {
};

template<typename T>
inline constexpr auto is_really_unsigned_integral_v{
    is_really_unsigned_integral<T>::value};

} // namespace muc::impl

#include <type_traits>

namespace muc {

/// @brief Checks if x is an integral power of two. This participates in
/// overload resolution only if T is an unsigned integer type (that is, unsigned
/// char, unsigned short, unsigned int, unsigned long, unsigned long long, or an
/// extended unsigned integer type).
/// @tparam T unsigned integer type
/// @param x value of unsigned integer type
/// @return true if x is an integral power of two; otherwise false.
template<typename T,
         std::enable_if_t<impl::is_really_unsigned_integral_v<T>, bool> = true>
constexpr auto has_single_bit(T x) noexcept -> bool {
    return x && !(x & (x - 1u));
}

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <limits>
#include <type_traits>

namespace muc {

/// @brief Computes the result of bitwise left-rotating the value of x by s
/// positions. This overload participates in overload resolution only if T is an
/// unsigned integer type (that is, unsigned char, unsigned short, unsigned int,
/// unsigned long, unsigned long long, or an extended unsigned integer type).
/// @tparam T unsigned integer type
/// @param x value of unsigned integer type
/// @param s number of positions to shift
/// @return The result of bitwise left-rotating x by s positions.
template<typename T,
         std::enable_if_t<impl::is_really_unsigned_integral_v<T>, bool> = true>
[[nodiscard]] constexpr auto rotl(T x, int s) noexcept -> T {
    constexpr auto n{std::numeric_limits<T>::digits};
    const auto r{s % n};
    if (r > 0) {
        return (x << r) | (x >> (n - r));
    }
    if (r < 0) {
        return (x >> -r) | (x << (n + r));
    }
    return x; // r == 0
}

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <limits>
#include <type_traits>

namespace muc {

/// @brief Computes the result of bitwise right-rotating the value of x by s
/// positions. This overload participates in overload resolution only if T is an
/// unsigned integer type (that is, unsigned char, unsigned short, unsigned int,
/// unsigned long, unsigned long long, or an extended unsigned integer type).
/// @tparam T unsigned integer type
/// @param x value of unsigned integer type
/// @param s number of positions to shift
/// @return The result of bitwise right-rotating x by s positions.
template<typename T,
         std::enable_if_t<impl::is_really_unsigned_integral_v<T>, bool> = true>
[[nodiscard]] constexpr auto rotr(T x, int s) noexcept -> T {
    constexpr auto n{std::numeric_limits<T>::digits};
    const auto r{s % n};
    if (r > 0) {
        return (x >> r) | (x << (n - r));
    }
    if (r < 0) {
        return (x << -r) | (x >> (n + r));
    }
    return x; // r == 0
}

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_CETA_STRING_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_CETA_STRING_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 202002L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <algorithm>
#include <cstddef>
#include <string>
#include <string_view>

namespace muc {

/// @brief ceta_string for 'consteval, template applicable string'
/// @tparam N size of the string (include end '\0')
/// @note Should always be constructed from string literals or nullptr.
template<std::size_t N>
struct ceta_string {
private:
    using cstring = const char[N];

public:
    consteval ceta_string(const cstring& string) :
        m_private_string_data{string} {}

    constexpr auto c_str() const -> const auto& {
        return m_private_string_data.m_data;
    }

    constexpr auto sv() const -> std::string_view {
        return {c_str(), N - 1};
    }

    auto s() const -> std::string {
        return {c_str(), N - 1};
    }

    constexpr operator const cstring&() const {
        return c_str();
    }

    constexpr operator std::string_view() const {
        return sv();
    }

    explicit operator std::string() const {
        return s();
    }

    constexpr auto operator==(const char* rhs) const -> bool {
        return sv() == std::string_view{rhs};
    }

    constexpr auto operator<=>(const char* rhs) const -> auto {
        return sv() <=> std::string_view{rhs};
    }

    constexpr auto operator==(std::nullptr_t) const -> bool {
        return not has_value();
    }

    constexpr operator bool() const {
        return has_value();
    }

    static constexpr auto has_value() -> bool {
        return true;
    }

private:
    struct private_string_data {
        consteval private_string_data(const cstring& string) :
            m_data{} {
            std::ranges::copy(string, m_data);
        }

        char m_data[N];
    };

public:
    const private_string_data m_private_string_data; // private by semantic
};

template<std::size_t N>
ceta_string(const char (&)[N]) -> ceta_string<N>;

template<>
struct ceta_string<0> {
    consteval ceta_string(std::nullptr_t) {}

    constexpr auto operator=(const ceta_string&) -> ceta_string& = delete;

    constexpr operator bool() const {
        return has_value();
    }

    constexpr auto operator==(std::nullptr_t) const -> bool {
        return not has_value();
    }

    static constexpr auto has_value() -> bool {
        return false;
    }
};

ceta_string() -> ceta_string<0>;

ceta_string(std::nullptr_t) -> ceta_string<0>;

template<std::size_t M, std::size_t N>
constexpr auto operator==(const ceta_string<M>& lhs,
                          const ceta_string<N>& rhs) -> bool {
    return lhs.sv() == rhs.sv();
}

template<std::size_t M, std::size_t N>
constexpr auto operator<=>(const ceta_string<M>& lhs,
                           const ceta_string<N>& rhs) -> auto {
    return lhs.sv() <=> rhs.sv();
}

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_CONCEPTS_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_CONCEPTS_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 202002L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <concepts>
#include <utility>

namespace muc {

template<typename B>
concept boolean_testable = requires(B&& b) {
    requires std::convertible_to<B, bool>;
    { not std::forward<B>(b) } -> std::convertible_to<bool>;
};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <concepts>

namespace muc {

/// @brief C++ named requirements: MoveAssignable. This is more strict than
/// std::is_move_assignable because it does check the type of the result of the
/// assignment (which, for a CopyAssignable type, must be an lvalue of type T).
/// See also: https://en.cppreference.com/w/cpp/named_req/move_assignable
template<typename T>
concept move_assignable = std::assignable_from<T&, T&&>;

template<typename T>
concept noexcept_move_assignable =
    std::assignable_from<T&, T&&> and std::is_nothrow_move_assignable_v<T>;

} // namespace muc

#include <concepts>

namespace muc {

/// @brief C++ named requirements: CopyAssignable. This is more strict than
/// std::is_copy_assignable because it does check the type of the result of the
/// assignment (which, for a CopyAssignable type, must be an lvalue of type T).
/// See also: https://en.cppreference.com/w/cpp/named_req/copy_assignable
template<typename T>
concept copy_assignable =
    move_assignable<T> and std::assignable_from<T&, T&> and
    std::assignable_from<T&, const T&> and std::assignable_from<T&, const T&&>;

template<typename T>
concept noexcept_copy_assignable =
    noexcept_move_assignable<T> and std::assignable_from<T&, T&> and
    std::assignable_from<T&, const T&> and
    std::assignable_from<T&, const T&&> and
    std::is_nothrow_move_assignable_v<T>;

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

template<template<typename...> typename, typename>
struct is_template_of : std::false_type {};

template<template<typename...> typename Template, typename... Args>
struct is_template_of<Template, Template<Args...>> : std::true_type {};

template<template<typename...> typename Template, typename T>
inline constexpr bool is_template_of_v{is_template_of<Template, T>::value};

} // namespace muc

namespace muc {

template<typename T, template<typename...> typename Template>
concept instantiated_from = is_template_of_v<Template, T>;

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_FUNCTIONAL_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_FUNCTIONAL_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <utility>

namespace muc {

/// @brief `muc::identity` is a function object type whose operator() returns
/// its argument unchanged. The effect is the same as It is a backport of
/// `std::identity`.
struct identity {
    using is_transparent = struct {};

    template<typename T>
    [[nodiscard]] constexpr auto operator()(T&& t) const noexcept -> T&& {
        return std::forward<T>(t);
    }
};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <tuple>
#include <type_traits>
#include <utility>

namespace muc {

/// @brief muc::multidentity is a function object type whose operator() returns
/// its arguments in a `std::tuple`. The effect is the same as
/// `std::forward_as_tuple`.
/// @warning Passing temporary objects as arguments is errorous and will produce
/// `std::tuple` holding dangling references.
struct multidentity {
    template<typename... Ts, std::enable_if_t<sizeof...(Ts) >= 1, bool> = true>
    [[nodiscard]] constexpr auto
    operator()(Ts&&... ts) const noexcept -> std::tuple<Ts&&...> {
        return std::forward_as_tuple<Ts...>(ts...);
    }
};

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_MATH_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_MATH_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 202002L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <cassert>
#include <cmath>
#include <concepts>
#include <type_traits>

namespace muc {

template<ceta_string<3> Mode, std::floating_point T1, std::floating_point T2,
         std::floating_point T3>
    requires(Mode == "[]" or Mode == "[)" or Mode == "(]" or Mode == "()")
constexpr auto clamp(T1 value, T2 low,
                     T3 high) -> std::common_type_t<T1, T2, T3> {
    const std::common_type_t<T1, T2, T3> v{value};
    const std::common_type_t<T1, T2, T3> lo{low};
    const std::common_type_t<T1, T2, T3> hi{high};
    assert(lo < hi);
    if constexpr (Mode == "[]") {
        return v < lo ? lo : hi < v ? hi : v;
    } else if constexpr (Mode == "[)") {
        return v < lo ? lo : hi <= v ? std::nexttoward(hi, lo) : v;
    } else if constexpr (Mode == "(]") {
        return v <= lo ? std::nexttoward(lo, hi) : hi < v ? hi : v;
    } else if constexpr (Mode == "()") {
        return v <= lo ? std::nexttoward(lo, hi) :
               hi <= v ? std::nexttoward(hi, lo) :
                         v;
    }
}

} // namespace muc
#endif

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <cinttypes>
#include <cstdlib>
#include <limits>
#include <type_traits>

#if __cplusplus >= 202002L // >= C++20
#include <version>
#ifdef __cpp_lib_constexpr_cmath // >= C++23
#define MUC_CPP_LIB_CONSTEXPR_CMATH
#endif
#endif

#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
#include <cmath>
#endif

namespace muc {

///////////////////////////////////////////////////////////////////////////////
// div
///////////////////////////////////////////////////////////////////////////////

constexpr auto div(int x, int y) -> std::div_t {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::div(x, y);
#else // backport
    std::div_t result{};
    result.quot = x / y;
    result.rem = x % y;
    return result;
#endif
}

constexpr auto div(long x, long y) -> std::ldiv_t {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::div(x, y);
#else // backport
    std::ldiv_t result{};
    result.quot = x / y;
    result.rem = x % y;
    return result;
#endif
}

constexpr auto div(long long x, long long y) -> std::lldiv_t {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::div(x, y);
#else // backport
    std::lldiv_t result{};
    result.quot = x / y;
    result.rem = x % y;
    return result;
#endif
}

constexpr auto ldiv(long x, long y) -> std::ldiv_t {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::ldiv(x, y);
#else // backport
    return muc::div(x, y);
#endif
}

constexpr auto lldiv(long long x, long long y) -> std::lldiv_t {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::lldiv(x, y);
#else // backport
    return muc::div(x, y);
#endif
}

constexpr auto imaxdiv(std::intmax_t x, std::intmax_t y) -> std::imaxdiv_t {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::imaxdiv(x, y);
#else // backport
    std::imaxdiv_t result{};
    result.quot = x / y;
    result.rem = x % y;
    return result;
#endif
}

template<typename IntMax,
         std::enable_if_t<std::is_same_v<IntMax, std::intmax_t> and
                              (sizeof(IntMax) > sizeof(long long)),
                          bool> = true>
constexpr auto div(IntMax x, IntMax y) -> std::imaxdiv_t {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::div(x, y);
#else // backport
    return muc::imaxdiv(x, y);
#endif
}

///////////////////////////////////////////////////////////////////////////////
// floating point abs
///////////////////////////////////////////////////////////////////////////////

template<typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
constexpr auto abs(T x) -> T {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::abs(x);
#else // backport
#if defined __clang__ or defined __GNUC__
    if constexpr (std::is_same_v<T, double>) {
        return __builtin_fabs(x);
    } else if constexpr (std::is_same_v<T, float>) {
        return __builtin_fabsf(x);
    } else if constexpr (std::is_same_v<T, long double>) {
        return __builtin_fabsl(x);
    }
#else
    return x >= 0 ? x : -x;
#endif
#endif
}

template<typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
constexpr auto fabs(T x) -> T {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::fabs(x);
#else // backport
    return muc::abs(x);
#endif
}

constexpr auto fabsf(float x) -> float {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::fabsf(x);
#else // backport
    return muc::abs(x);
#endif
}

constexpr auto fabsl(long double x) -> long double {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::fabsl(x);
#else // backport
    return muc::abs(x);
#endif
}

template<typename T, std::enable_if_t<std::is_integral_v<T>, bool> = true>
constexpr auto fabs(T n) -> double {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::fabs(n);
#else // backport
    return muc::abs(static_cast<double>(n));
#endif
}

///////////////////////////////////////////////////////////////////////////////
// integral abs
///////////////////////////////////////////////////////////////////////////////

constexpr auto abs(int n) -> int {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::abs(n);
#else // backport
    return n >= 0 ? n : -n;
#endif
}

constexpr auto abs(long n) -> long {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::abs(n);
#else // backport
    return n >= 0 ? n : -n;
#endif
}

constexpr auto abs(long long n) -> long long {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::abs(n);
#else // backport
    return n >= 0 ? n : -n;
#endif
}

constexpr auto labs(long n) -> long {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::labs(n);
#else // backport
    return muc::abs(n);
#endif
}

constexpr auto llabs(long long n) -> long long {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::llabs(n);
#else // backport
    return muc::abs(n);
#endif
}

constexpr auto imaxabs(std::intmax_t n) -> std::intmax_t {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::imaxabs(n);
#else // backport
    return n >= 0 ? n : -n;
#endif
}

template<typename IntMax,
         std::enable_if_t<std::is_same_v<IntMax, std::intmax_t> and
                              (sizeof(IntMax) > sizeof(long long)),
                          bool> = true>
constexpr auto abs(IntMax n) -> std::intmax_t {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::abs(n);
#else // backport
    return muc::imaxabs(n);
#endif
}

///////////////////////////////////////////////////////////////////////////////
// isnan
///////////////////////////////////////////////////////////////////////////////

template<typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
constexpr auto isnan(T x) -> bool {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::isnan(x);
#else // backport
    return x != x;
#endif
}

template<typename T, std::enable_if_t<std::is_integral_v<T>, bool> = true>
constexpr auto isnan(T n) -> bool {
#ifdef MUC_CPP_LIB_CONSTEXPR_CMATH
    return std::isnan(n);
#else // backport
    if constexpr (std::numeric_limits<double>::is_iec559) {
        return false;
    } else {
        return muc::isnan(static_cast<double>(n));
    }
#endif
}

} // namespace muc

#undef MUC_CPP_LIB_CONSTEXPR_CMATH
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

/// @brief Get n-based digits of an integer.
/// @param m The integer.
/// @param base The base.
/// @param with_sign Set whether the digits in return includes "-" sign (true
/// means include, false means exclude).
/// @return The n-based digits.
template<typename T,
         std::enable_if_t<std::is_signed_v<T> and std::is_integral_v<T>, bool> =
             true>
constexpr auto digits_of(T m, int base, bool with_sign = false) -> int {
    if (base == 0) {
        return 0;
    }
    if (base < 0) {
        base = -base;
    }
    int d{};
    if (m < 0) {
        if (with_sign) {
            ++d;
        }
        m = -m;
    }
    do {
        m /= base;
        ++d;
    } while (m > 0);
    return d;
}

/// @brief Get n-based digits of an integer.
/// @tparam Base The base.
/// @param m The integer.
/// @param with_sign Set whether the digits in return includes "-" sign (true
/// means include, false means exclude).
/// @return The n-based digits.
template<unsigned Base, typename T,
         std::enable_if_t<std::is_signed_v<T> and std::is_integral_v<T>, bool> =
             true>
constexpr auto digits_of(T m, bool with_sign = false) -> int {
    return muc::digits_of(m, Base, with_sign);
}

/// @brief Get n-based digits of an integer.
/// @param m The integer.
/// @param base The base.
/// @return The n-based digits.
template<typename T,
         std::enable_if_t<std::is_unsigned_v<T> and std::is_integral_v<T>,
                          bool> = true>
constexpr auto digits_of(T m, int base) -> int {
    if (base == 0) {
        return 0;
    }
    if (base < 0) {
        base = -base;
    }
    int d{};
    do {
        m /= base;
        ++d;
    } while (m > 0);
    return d;
}

/// @brief Get n-based digits of an integer.
/// @tparam Base The base.
/// @param m The integer.
/// @return The n-based digits.
template<unsigned Base, typename T,
         std::enable_if_t<std::is_unsigned_v<T> and std::is_integral_v<T>,
                          bool> = true>
constexpr auto digits_of(T m) -> auto {
    return muc::digits_of(m, Base);
}

} // namespace muc

#ifdef MUC_STATIC_TEST

static_assert(muc::digits_of(0, 2) == 1);
static_assert(muc::digits_of(0u, 2) == 1);
static_assert(muc::digits_of(0b10100101000, 2) == 11);
static_assert(muc::digits_of(0b10100101000u, 2) == 11);
static_assert(muc::digits_of(-0b10100101000, 2) == 11);
static_assert(muc::digits_of(-0b10100101000, 2, true) == 12);
static_assert(muc::digits_of<2>(0) == 1);
static_assert(muc::digits_of<2>(0u) == 1);
static_assert(muc::digits_of<2>(0b10100101000) == 11);
static_assert(muc::digits_of<2>(0b10100101000u) == 11);
static_assert(muc::digits_of<2>(-0b10100101000) == 11);
static_assert(muc::digits_of<2>(-0b10100101000, true) == 12);

static_assert(muc::digits_of(0, 8) == 1);
static_assert(muc::digits_of(0u, 8) == 1);
static_assert(muc::digits_of(0123456, 8) == 6);
static_assert(muc::digits_of(0123456u, 8) == 6);
static_assert(muc::digits_of(-0123456, 8) == 6);
static_assert(muc::digits_of(-0123456, 8, true) == 7);
static_assert(muc::digits_of<8>(0) == 1);
static_assert(muc::digits_of<8>(0u) == 1);
static_assert(muc::digits_of<8>(0123456) == 6);
static_assert(muc::digits_of<8>(0123456u) == 6);
static_assert(muc::digits_of<8>(-0123456) == 6);
static_assert(muc::digits_of<8>(-0123456, true) == 7);

static_assert(muc::digits_of(0, 10) == 1);
static_assert(muc::digits_of(0u, 10) == 1);
static_assert(muc::digits_of(1, 10) == 1);
static_assert(muc::digits_of(1u, 10) == 1);
static_assert(muc::digits_of(99, 10) == 2);
static_assert(muc::digits_of(99u, 10) == 2);
static_assert(muc::digits_of(100, 10) == 3);
static_assert(muc::digits_of(100u, 10) == 3);
static_assert(muc::digits_of(123456, 10) == 6);
static_assert(muc::digits_of(123456u, 10) == 6);
static_assert(muc::digits_of(1919810, 10) == 7);
static_assert(muc::digits_of(1919810u, 10) == 7);
static_assert(muc::digits_of(-123456, 10) == 6);
static_assert(muc::digits_of(-123456, 10, true) == 7);
static_assert(muc::digits_of<10>(123456) == 6);
static_assert(muc::digits_of<10>(123456u) == 6);
static_assert(muc::digits_of<10>(-123456) == 6);
static_assert(muc::digits_of<10>(-123456, true) == 7);

static_assert(muc::digits_of(0, 16) == 1);
static_assert(muc::digits_of(0u, 16) == 1);
static_assert(muc::digits_of(0x123456, 16) == 6);
static_assert(muc::digits_of(0x123456u, 16) == 6);
static_assert(muc::digits_of(-0x123456, 16) == 6);
static_assert(muc::digits_of(-0x123456, 16, true) == 7);
static_assert(muc::digits_of<16>(0) == 1);
static_assert(muc::digits_of<16>(0u) == 1);
static_assert(muc::digits_of<16>(0x123456) == 6);
static_assert(muc::digits_of<16>(0x123456u) == 6);
static_assert(muc::digits_of<16>(-0x123456) == 6);
static_assert(muc::digits_of<16>(-0x123456, true) == 7);

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <cmath>
#include <type_traits>

namespace muc {

template<typename... Ts, std::enable_if_t<((sizeof...(Ts) >= 2) and ... and
                                           std::is_floating_point_v<Ts>),
                                          bool> = true>
constexpr auto hypot2(Ts... x) -> auto {
    return (... + (x * x));
}

template<typename... Ts, std::enable_if_t<((sizeof...(Ts) >= 2) and ... and
                                           std::is_floating_point_v<Ts>),
                                          bool> = true>
auto hypot(Ts... x) -> auto {
    return std::sqrt(muc::hypot2(x...));
}

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <cassert>
#include <limits>
#include <type_traits>

namespace muc {

/// @brief A fast implementation of std::llround but never raise floating point
/// exceptions. Computes the nearest integer value to x (in floating-point
/// format), rounding halfway cases away from zero.
/// @tparam T floating-point type
/// @param x floating-point value
/// @return the nearest integer value to x, rounding halfway cases away from
/// zero
template<typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
constexpr auto llround(T x) -> long long {
    assert(static_cast<T>(std::numeric_limits<long long>::min()) < x and
           x < static_cast<T>(std::numeric_limits<long long>::max()));
    return x + (x >= 0 ? 0.5 : -0.5);
}

} // namespace muc

#ifdef MUC_STATIC_TEST

static_assert(muc::llround(-3.) == -3);
static_assert(muc::llround(-2.) == -2);
static_assert(muc::llround(-1.) == -1);
static_assert(muc::llround(+0.) == +0);
static_assert(muc::llround(+1.) == +1);
static_assert(muc::llround(+2.) == +2);
static_assert(muc::llround(+3.) == +3);

static_assert(muc::llround(-3.3) == -3);
static_assert(muc::llround(-2.3) == -2);
static_assert(muc::llround(-1.3) == -1);
static_assert(muc::llround(+0.3) == +0);
static_assert(muc::llround(+1.3) == +1);
static_assert(muc::llround(+2.3) == +2);
static_assert(muc::llround(+3.3) == +3);

static_assert(muc::llround(-3.5) == -4);
static_assert(muc::llround(-2.5) == -3);
static_assert(muc::llround(-1.5) == -2);
static_assert(muc::llround(+0.5) == +1);
static_assert(muc::llround(+1.5) == +2);
static_assert(muc::llround(+2.5) == +3);
static_assert(muc::llround(+3.5) == +4);

static_assert(muc::llround(-3.7) == -4);
static_assert(muc::llround(-2.7) == -3);
static_assert(muc::llround(-1.7) == -2);
static_assert(muc::llround(+0.7) == +1);
static_assert(muc::llround(+1.7) == +2);
static_assert(muc::llround(+2.7) == +3);
static_assert(muc::llround(+3.7) == +4);

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <cassert>
#include <limits>
#include <type_traits>

namespace muc {

/// @brief A fast implementation of std::trunc but never raise floating point
/// exceptions and returns a long long int. Computes the nearest integer not
/// greater in magnitude than x.
/// @tparam T floating-point type
/// @param x floating-point value
/// @return the nearest integer value not greater in magnitude than x
template<typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
constexpr auto lltrunc(T x) -> long long {
    assert(static_cast<T>(std::numeric_limits<long long>::min()) < x and
           x < static_cast<T>(std::numeric_limits<long long>::max()));
    return x;
}

} // namespace muc

#ifdef MUC_STATIC_TEST

static_assert(muc::lltrunc(-3.) == -3);
static_assert(muc::lltrunc(-2.) == -2);
static_assert(muc::lltrunc(-1.) == -1);
static_assert(muc::lltrunc(+0.) == +0);
static_assert(muc::lltrunc(+1.) == +1);
static_assert(muc::lltrunc(+2.) == +2);
static_assert(muc::lltrunc(+3.) == +3);

static_assert(muc::lltrunc(-3.3) == -3);
static_assert(muc::lltrunc(-2.3) == -2);
static_assert(muc::lltrunc(-1.3) == -1);
static_assert(muc::lltrunc(+0.3) == +0);
static_assert(muc::lltrunc(+1.3) == +1);
static_assert(muc::lltrunc(+2.3) == +2);
static_assert(muc::lltrunc(+3.3) == +3);

static_assert(muc::lltrunc(-3.5) == -3);
static_assert(muc::lltrunc(-2.5) == -2);
static_assert(muc::lltrunc(-1.5) == -1);
static_assert(muc::lltrunc(+0.5) == +0);
static_assert(muc::lltrunc(+1.5) == +1);
static_assert(muc::lltrunc(+2.5) == +2);
static_assert(muc::lltrunc(+3.5) == +3);

static_assert(muc::lltrunc(-3.7) == -3);
static_assert(muc::lltrunc(-2.7) == -2);
static_assert(muc::lltrunc(-1.7) == -1);
static_assert(muc::lltrunc(+0.7) == +0);
static_assert(muc::lltrunc(+1.7) == +1);
static_assert(muc::lltrunc(+2.7) == +2);
static_assert(muc::lltrunc(+3.7) == +3);

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

/// @brief Calculate m^N, where both m and N are integers.
/// @tparam T integral type
/// @tparam N power, N>=0
/// @param m base
/// @return m^N of type T.
template<int N, typename T,
         std::enable_if_t<N >= 0 and std::is_integral_v<T>, bool> = true>
constexpr auto ipow(T m) -> T {
    if constexpr (N == 0) {
        return 1;
    }
    if constexpr (N == 1) {
        return m;
    }
    if constexpr (N % 2 == 0) {
        const auto k{muc::ipow<N / 2>(m)};
        return k * k;
    }
    if constexpr (N % 3 == 0) {
        const auto k{muc::ipow<N / 3>(m)};
        return k * k * k;
    }
    const auto k{muc::ipow<(N - 1) / 2>(m)};
    return k * m * k;
}

/// @brief Calculate x^N, where x is an floating point and N is an integer.
/// @tparam T floating point type
/// @tparam N power
/// @param x base
/// @return x^N
template<int N, typename T,
         std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
constexpr auto pow(T x) -> T {
    if constexpr (N < 0) {
        return muc::pow<-N>(1 / x);
    }
    if constexpr (N == 0) {
        return 1;
    }
    if constexpr (N == 1) {
        return x;
    }
    if constexpr (N % 2 == 0) {
        const auto u{muc::pow<N / 2>(x)};
        return u * u;
    }
    if constexpr (N % 3 == 0) {
        const auto u{muc::pow<N / 3>(x)};
        return u * u * u;
    }
    const auto u{muc::pow<(N - 1) / 2>(x)};
    return u * x * u;
}

/// @brief Calculate x^N, where x is an integral converted to floating point, N
/// is an integer.
/// @tparam T floating point type
/// @tparam N power
/// @param x base
/// @return x^N
template<int N, typename T = double, typename U,
         std::enable_if_t<std::is_floating_point_v<T> and std::is_integral_v<T>,
                          bool> = true>
constexpr auto pow(U x) -> T {
    return muc::pow<N>(static_cast<T>(x));
}

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_MEMORY_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_MEMORY_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <new>
#include <utility>

namespace muc {

template<typename T, typename... Args>
auto construct_at(T* ptr, Args&&... args) -> T* {
    return ::new (static_cast<void*>(ptr)) T(std::forward<Args>(args)...);
}

} // namespace muc

#include <cstddef>
#include <cstring>
#include <memory>
#include <utility>

namespace muc {

template<typename T>
struct placement {
public:
    placement(const T& obj) :
        m_storage{} {
        muc::construct_at(pointer_to(m_storage), obj);
    }

    placement(T&& obj) :
        m_storage{} {
        muc::construct_at(pointer_to(m_storage), std::move(obj));
    }

    template<typename... Args>
    placement(Args&&... args) :
        m_storage{} {
        muc::construct_at(pointer_to(m_storage), std::forward<Args>(args)...);
    }

    placement(const placement& other) :
        placement{*other} {}

    placement(placement&& other) :
        placement{std::move(*other)} {}

    ~placement() {
        std::destroy_at(pointer_to(m_storage));
    }

    auto operator=(const placement& other) {
        alignas(T) std::byte buffer[sizeof(T)]{};
        muc::construct_at(pointer_to(buffer), *other);
        std::destroy_at(pointer_to(m_storage));
        std::memcpy(&m_storage, &buffer, sizeof(T));
    }

    auto operator=(placement&& other) {
        alignas(T) std::byte buffer[sizeof(T)]{};
        muc::construct_at(pointer_to(buffer), std::move(*other));
        std::destroy_at(pointer_to(m_storage));
        std::memcpy(&m_storage, &buffer, sizeof(T));
    }

    operator T&() & {
        return **this;
    }

    operator const T&() const& {
        return **this;
    }

    operator T&&() && {
        return std::move(**this);
    }

    operator const T&&() const&& {
        return std::move(**this);
    }

    auto operator*() & -> T& {
        return get();
    }

    auto operator*() const& -> const T& {
        return get();
    }

    auto operator*() && -> T&& {
        return std::move(get());
    }

    auto operator*() const&& -> const T&& {
        return std::move(get());
    }

    auto get() & -> T& {
        return *pointer_to(m_storage);
    }

    auto get() const& -> const T& {
        return *pointer_to(m_storage);
    }

    auto get() && -> T&& {
        return std::move(*pointer_to(m_storage));
    }

    auto get() const&& -> const T&& {
        return std::move(*pointer_to(m_storage));
    }

    auto operator->() -> T* {
        return pointer_to(m_storage);
    }

    auto operator->() const -> const T* {
        return pointer_to(m_storage);
    }

private:
    static auto pointer_to(std::byte* buffer) -> T* {
        return std::launder(reinterpret_cast<T*>(buffer));
    }

    static auto pointer_to(const std::byte* buffer) -> const T* {
        return std::launder(reinterpret_cast<const T*>(buffer));
    }

private:
    alignas(T) std::byte m_storage[sizeof(T)];
};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <memory>
#include <type_traits>
#include <utility>

namespace muc {

template<typename T>
constexpr auto to_address(T* ptr) noexcept -> T* {
    static_assert(not std::is_function_v<T>);
    return ptr;
}

namespace impl {

template<typename, typename = void>
struct has_pointer_traits_to_address : std::false_type {};

template<typename T>
struct has_pointer_traits_to_address<
    T, std::void_t<decltype(std::pointer_traits<T>::to_address(
           std::declval<const T&>()))>> : std::true_type {};

} // namespace impl

template<typename T>
constexpr auto to_address(const T& ptr) noexcept -> auto {
    if constexpr (impl::has_pointer_traits_to_address<T>::value) {
        return std::pointer_traits<T>::to_address(ptr);
    } else {
        return muc::to_address(ptr.operator->());
    }
}

} // namespace muc

#include <memory>
#include <stdexcept>
#include <type_traits>
#include <utility>

namespace muc {

template<typename Allocator>
struct allocator_delete : placement<Allocator> {
    allocator_delete() = default;

    explicit allocator_delete(const Allocator& alloc) :
        placement<Allocator>{alloc} {}

    explicit allocator_delete(Allocator&& alloc) :
        placement<Allocator>{std::move(alloc)} {}

    template<typename Alloc>
    allocator_delete(const allocator_delete<Alloc>& other) :
        Allocator{static_cast<const Alloc&>(other)} {}

    template<typename Alloc>
    allocator_delete(allocator_delete<Alloc>&& other) :
        Allocator{static_cast<Alloc&&>(other)} {}

    auto
    operator()(typename std::allocator_traits<Allocator>::pointer ptr) -> void {
        Allocator& alloc(*this);
        std::allocator_traits<Allocator>::destroy(alloc, muc::to_address(ptr));
        std::allocator_traits<Allocator>::deallocate(alloc, ptr, 1);
    }
};

template<typename T, typename Allocator, typename... Args>
auto allocate_unique(Allocator alloc, Args&&... args)
    -> std::unique_ptr<T, allocator_delete<Allocator>> {
    static_assert(
        std::is_same_v<typename std::allocator_traits<Allocator>::value_type,
                       std::remove_cv_t<T>>,
        "Allocator has the wrong value_type");
    const auto ptr{std::allocator_traits<Allocator>::allocate(alloc, 1)};
    const auto deallocate_when_failed{[&] {
        std::allocator_traits<Allocator>::deallocate(alloc, ptr, 1);
    }};
    try {
        std::allocator_traits<Allocator>::construct(
            alloc, muc::to_address(ptr), std::forward<Args>(args)...);
        return std::unique_ptr<T, allocator_delete<Allocator>>{
            ptr, allocator_delete<Allocator>{alloc}};
    } catch (const std::exception& e) {
        deallocate_when_failed();
        throw e;
    } catch (...) {
        deallocate_when_failed();
        throw;
    }
}

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_NUMERIC_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_NUMERIC_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 202002L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <ranges>
#include <utility>
#include <version>

#ifdef __cpp_lib_ranges_iota // C++23
#include <algorithm>
#include <numeric>
#else // backport
#include <iterator>
#endif

namespace muc::ranges {

#ifdef __cpp_lib_ranges_iota // C++23

struct iota_fn {
    template<std::input_or_output_iterator O, std::sentinel_for<O> S,
             std::weakly_incrementable T>
        requires std::indirectly_writable<O, const T&>
    constexpr auto operator()(O first, S last,
                              T value) const -> std::ranges::iota_result<O, T> {
        return std::ranges::iota(std::move(first), std::move(last),
                                 std::move(value));
    }

    template<std::weakly_incrementable T, std::ranges::output_range<const T&> R>
    constexpr auto operator()(R&& r, T value) const
        -> std::ranges::iota_result<std::ranges::borrowed_iterator_t<R>, T> {
        return std::ranges::iota(std::forward<decltype(r)>(r),
                                 std::move(value));
    }
};

#else // backport

template<typename O, typename T>
struct out_value_result {
    [[no_unique_address]] O out;
    [[no_unique_address]] T value;

    template<typename O2, typename T2>
        requires std::convertible_to<const O&, O2> and
                 std::convertible_to<const T&, T2>
    constexpr operator out_value_result<O2, T2>() const& {
        return {out, value};
    }

    template<typename O2, typename T2>
        requires std::convertible_to<O, O2> and std::convertible_to<T, T2>
    constexpr operator out_value_result<O2, T2>() && {
        return {std::move(out), std::move(value)};
    }
};

template<typename O, typename T>
using iota_result = out_value_result<O, T>;

struct iota_fn {
    template<std::input_or_output_iterator O, std::sentinel_for<O> S,
             std::weakly_incrementable T>
        requires std::indirectly_writable<O, const T&>
    constexpr auto operator()(O first, S last,
                              T value) const -> iota_result<O, T> {
        while (first != last) {
            *first++ = value++;
        }
        return {std::move(first), std::move(value)};
    }

    template<std::weakly_incrementable T, std::ranges::output_range<const T&> R>
    constexpr auto operator()(R&& r, T value) const
        -> iota_result<std::ranges::borrowed_iterator_t<R>, T> {
        return (*this)(std::ranges::begin(std::forward<decltype(r)>(r)),
                       std::ranges::end(std::forward<decltype(r)>(r)),
                       std::move(value));
    }
};

#endif

inline constexpr iota_fn iota{};

} // namespace muc::ranges
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <iterator>
#include <numeric>
#include <ranges>
#include <utility>

namespace muc::ranges {

constexpr struct {
    constexpr auto operator()(std::ranges::input_range auto&& r,
                              auto&&... args) const -> decltype(auto) {
        return std::accumulate(std::ranges::cbegin(r), std::ranges::cend(r),
                               std::forward<decltype(args)>(args)...);
    }
} accumulate{};

constexpr struct {
    constexpr auto operator()(std::ranges::input_range auto&& r,
                              auto&&... args) const -> decltype(auto) {
        return std::reduce(std::ranges::cbegin(r), std::ranges::cend(r),
                           std::forward<decltype(args)>(args)...);
    }

    auto operator()(auto&& policy, std::ranges::forward_range auto&& r,
                    auto&&... args) const -> decltype(auto) {
        return std::reduce(std::forward<decltypr(policy)>(policy),
                           std::ranges::cbegin(r), std::ranges::cend(r),
                           std::forward<decltype(args)>(args)...);
    }
} reduce{};

constexpr struct {
    constexpr auto operator()(std::ranges::input_range auto&& r,
                              std::input_iterator auto i,
                              auto&&... args) const -> decltype(auto) {
        return std::transform_reduce(std::ranges::cbegin(r),
                                     std::ranges::cend(r), i,
                                     std::forward<decltype(args)>(args)...);
    }

    constexpr auto operator()(std::ranges::input_range auto&& r,
                              auto&&... args) const -> decltype(auto) {
        return std::transform_reduce(std::ranges::cbegin(r),
                                     std::ranges::cend(r),
                                     std::forward<decltype(args)>(args)...);
    }

    auto operator()(auto&& policy, std::ranges::forward_range auto&& r,
                    std::forward_iterator auto i,
                    auto&&... args) const -> decltype(auto) {
        return std::transform_reduce(
            std::forward<decltypr(policy)>(policy), std::ranges::cbegin(r),
            std::ranges::cend(r), i, std::forward<decltype(args)>(args)...);
    }

    auto operator()(auto&& policy, std::ranges::forward_range auto&& r,
                    auto&&... args) const -> decltype(auto) {
        return std::transform_reduce(
            std::forward<decltypr(policy)>(policy), std::ranges::cbegin(r),
            std::ranges::cend(r), std::forward<decltype(args)>(args)...);
    }
} transform_reduce{};

constexpr struct {
    constexpr auto operator()(std::ranges::input_range auto&& r,
                              std::input_iterator auto i,
                              auto&&... args) const -> decltype(auto) {
        return std::inner_product(std::ranges::cbegin(r), std::ranges::cend(r),
                                  i, std::forward<decltype(args)>(args)...);
    }
} inner_product{};

constexpr struct {
    constexpr auto operator()(std::ranges::input_range auto&& r,
                              /* std::output_iterator */ auto o,
                              auto&&... args) const -> decltype(auto) {
        return std::adjacent_difference(std::ranges::cbegin(r),
                                        std::ranges::cend(r), o,
                                        std::forward<decltype(args)>(args)...);
    }

    auto operator()(auto&& policy, std::ranges::forward_range auto&& r,
                    std::forward_iterator auto o,
                    auto&&... args) const -> decltype(auto) {
        return std::adjacent_difference(
            std::forward<decltypr(policy)>(policy), std::ranges::cbegin(r),
            std::ranges::cend(r), o, std::forward<decltype(args)>(args)...);
    }
} adjacent_difference{};

constexpr struct {
    constexpr auto operator()(std::ranges::input_range auto&& r,
                              /* std::output_iterator */ auto o,
                              auto&&... args) const -> decltype(auto) {
        return std::partial_sum(std::ranges::cbegin(r), std::ranges::cend(r), o,
                                std::forward<decltype(args)>(args)...);
    }
} partial_sum{};

constexpr struct {
    constexpr auto operator()(std::ranges::input_range auto&& r,
                              /* std::output_iterator */ auto o,
                              auto&&... args) const -> decltype(auto) {
        return std::inclusive_scan(std::ranges::cbegin(r), std::ranges::cend(r),
                                   o, std::forward<decltype(args)>(args)...);
    }

    auto operator()(auto&& policy, std::ranges::forward_range auto&& r,
                    std::forward_iterator auto o,
                    auto&&... args) const -> decltype(auto) {
        return std::inclusive_scan(std::forward<decltypr(policy)>(policy),
                                   std::ranges::cbegin(r), std::ranges::cend(r),
                                   o, std::forward<decltype(args)>(args)...);
    }
} inclusive_scan{};

constexpr struct {
    constexpr auto operator()(std::ranges::input_range auto&& r,
                              /* std::output_iterator */ auto o,
                              auto&&... args) const -> decltype(auto) {
        return std::exclusive_scan(std::ranges::cbegin(r), std::ranges::cend(r),
                                   o, std::forward<decltype(args)>(args)...);
    }

    auto operator()(auto&& policy, std::ranges::forward_range auto&& r,
                    std::forward_iterator auto o,
                    auto&&... args) const -> decltype(auto) {
        return std::exclusive_scan(std::forward<decltypr(policy)>(policy),
                                   std::ranges::cbegin(r), std::ranges::cend(r),
                                   o, std::forward<decltype(args)>(args)...);
    }
} exclusive_scan{};

constexpr struct {
    constexpr auto operator()(std::ranges::input_range auto&& r,
                              /* std::output_iterator */ auto o,
                              auto&&... args) const -> decltype(auto) {
        return std::transform_inclusive_scan(
            std::ranges::cbegin(r), std::ranges::cend(r), o,
            std::forward<decltype(args)>(args)...);
    }

    auto operator()(auto&& policy, std::ranges::forward_range auto&& r,
                    std::forward_iterator auto o,
                    auto&&... args) const -> decltype(auto) {
        return std::transform_inclusive_scan(
            std::forward<decltypr(policy)>(policy), std::ranges::cbegin(r),
            std::ranges::cend(r), o, std::forward<decltype(args)>(args)...);
    }
} transform_inclusive_scan{};

constexpr struct {
    constexpr auto operator()(std::ranges::input_range auto&& r,
                              /* std::output_iterator */ auto o,
                              auto&&... args) const -> decltype(auto) {
        return std::transform_exclusive_scan(
            std::ranges::cbegin(r), std::ranges::cend(r), o,
            std::forward<decltype(args)>(args)...);
    }

    auto operator()(auto&& policy, std::ranges::forward_range auto&& r,
                    std::forward_iterator auto o,
                    auto&&... args) const -> decltype(auto) {
        return std::transform_exclusive_scan(
            std::forward<decltypr(policy)>(policy), std::ranges::cbegin(r),
            std::ranges::cend(r), o, std::forward<decltype(args)>(args)...);
    }
} transform_exclusive_scan{};

} // namespace muc::ranges
#endif

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>
#include <utility>

namespace muc::impl {

template<typename, typename, typename = void>
struct has_binary_arithmetic_with : std::false_type {};

template<typename T, typename U>
struct has_binary_arithmetic_with<
    T, U,
    std::void_t<
        // T +/- T
        decltype(std::declval<const T&>() + std::declval<const T&>()),
        decltype(std::declval<const T&>() - std::declval<const T&>()),
        // k * T
        /* decltype(+std::declval<const T&>()), */
        decltype(-std::declval<const T&>()),
        /* decltype(1 * std::declval<const T&>()),
        decltype(std::declval<const T&>() * 1),
        decltype(std::declval<const T&>() / 1), */
        // U +/- U
        decltype(std::declval<const U&>() + std::declval<const U&>()),
        decltype(std::declval<const U&>() - std::declval<const U&>()),
        // k * U
        /* decltype(+std::declval<const U&>()), */
        decltype(-std::declval<const U&>()),
        /* decltype(1 * std::declval<const U&>()),
        decltype(std::declval<const U&>() * 1),
        decltype(std::declval<const U&>() / 1), */
        // T +/- U
        decltype(std::declval<const T&>() + std::declval<const U&>()),
        decltype(std::declval<const T&>() - std::declval<const U&>()),
        // U +/- T
        decltype(std::declval<const U&>() + std::declval<const T&>()),
        decltype(std::declval<const U&>() - std::declval<const T&>()),
        // T x= X
        decltype(std::declval<T&>() += std::declval<const U&>()),
        decltype(std::declval<T&>() -= std::declval<const U&>())//,
        /* decltype(std::declval<T&>() *= 1), decltype(std::declval<T&>() /= 1) */>> :
    std::true_type {};

template<typename T, typename U>
inline constexpr bool has_binary_arithmetic_with_v{
    has_binary_arithmetic_with<T, U>::value};

} // namespace muc::impl

#include <type_traits>
#include <utility>

namespace muc {

template<typename T>
struct is_general_arithmetic :
    std::bool_constant<std::is_default_constructible_v<T> and
                       impl::has_binary_arithmetic_with_v<T, T> and
                       impl::has_binary_arithmetic_with_v<
                           T, decltype(std::declval<const T&>() +
                                       std::declval<const T&>())> and
                       impl::has_binary_arithmetic_with_v<
                           T, decltype(std::declval<const T&>() -
                                       std::declval<const T&>())> /* and
                       impl::has_binary_arithmetic_with_v<
                           T, decltype(1 * std::declval<const T&>())> and
                       impl::has_binary_arithmetic_with_v<
                           T, decltype(std::declval<const T&>() * 1)> and
                       impl::has_binary_arithmetic_with_v<
                           T, decltype(std::declval<const T&>() / 1)> */> {};

template<typename T>
inline constexpr bool is_general_arithmetic_v{is_general_arithmetic<T>::value};

} // namespace muc

#include <type_traits>

namespace muc {

/// @brief Performs linear interpolation.
/// @tparam T value type, can be a scalar or vector or something.
/// @tparam U scalar type
/// @param c values on endpoints
/// @param t interpolation parameter. 0<t<1 implies interpolation, otherwise
/// extrapolation.
/// @return interpolated value.
template<typename T, typename U,
         std::enable_if_t<is_general_arithmetic_v<T>, bool> = true,
         std::enable_if_t<std::is_floating_point_v<U>, bool> = true>
constexpr auto lerp(const T& a, const T& b, U t) -> T {
    if constexpr (std::is_integral_v<T>) {
        return (1 - t) * a + t * b;
    } else {
        return a + t * (b - a);
    }
}

} // namespace muc

#include <type_traits>

namespace muc {

/// @brief Performs bilinear interpolation.
/// @tparam T value type, can be a scalar or vector or something.
/// @tparam U scalar type
/// @param c values on square grid. See note for details.
/// @param u interpolation parameter. 0<u<1 implies interpolation, otherwise
/// extrapolation.
/// @param v interpolation parameter. 0<v<1 implies interpolation, otherwise
/// extrapolation.
/// @return interpolated value.
/// @note For parameter c:
///
///      c01      c11
///         +----+
///         |    |
/// v       +----+
/// ^    c00      c10
/// |
/// +----> u
template<typename T, typename U,
         std::enable_if_t<is_general_arithmetic_v<T>, bool> = true,
         std::enable_if_t<std::is_floating_point_v<U>, bool> = true>
constexpr auto bilerp(const T& c00, const T& c01, const T& c10, const T& c11,
                      U u, U v) -> T {
    return muc::lerp(muc::lerp(c00, c01, v), muc::lerp(c10, c11, v), u);
}

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <limits>
#include <type_traits>

namespace muc {

/// @brief Default tolerance value for floating-point type.
/// This constexpr variable provides a default tolerance value for
/// floating-points. It is calculated as half of the number of significant
/// digits of the floating-point type T.
/// @tparam T The floating-point type.
template<typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true>
inline constexpr auto default_tolerance{
    muc::pow<std::numeric_limits<T>::digits / 2, T>(2) *
    std::numeric_limits<T>::epsilon()};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <type_traits>

namespace muc {

template<typename T, std::enable_if_t<is_general_arithmetic_v<T>, bool> = true>
constexpr auto midpoint(const T& a, const T& b) -> T {
    return a + (b - a) / 2;
}

} // namespace muc

#include <algorithm>
#include <limits>
#include <optional>
#include <type_traits>
#include <utility>

namespace muc::find_root {

/// @brief Newton-Raphson method for finding roots of a function.
/// This function implements the Newton-Raphson method for finding roots of a
/// function. It iteratively calculates the next value using the function and
/// its derivative until convergence.
/// @tparam T The type of the input value.
/// @tparam F The type of the function to evaluate.
/// @tparam DF The type of the derivative function.
/// @param f The function to evaluate.
/// @param df The derivative function.
/// @param x0 The initial guess for the root.
/// @param max_iter The maximum number of iterations allowed (default is 1000).
/// @param tolerance The tolerance value for convergence (default is
/// default_tolerance<T>).
/// @return A pair containing the root value and a boolean indicating if
/// convergence was achieved.
template<typename T, typename F, typename DF,
         std::enable_if_t<std::is_floating_point_v<T> and
                              std::is_invocable_r_v<T, F, T> and
                              std::is_invocable_r_v<T, DF, T>,
                          bool> = true>
constexpr auto
newton_raphson(F&& f, DF&& df, T x0, int max_iter = 1000,
               T tolerance = muc::default_tolerance<T>) -> std::pair<T, bool> {
    auto x1{x0 - f(x0) / df(x0)};
    for (int i{}; i < max_iter; ++i) {
        if (muc::isnan(x1)) {
            break;
        }
        if (muc::abs(x1 - x0) <= muc::abs(muc::midpoint(x1, x0)) * tolerance) {
            return {x1, true};
        }
        x0 = x1;
        x1 = x0 - f(x0) / df(x0);
    }
    return {x1, false};
}

/// @brief Secant method for finding roots of a function.
/// This function implements the secant method for finding roots of a function.
/// It iteratively calculates the next value using two initial guesses until
/// convergence.
/// @tparam T The type of the input value.
/// @tparam F The type of the function to evaluate.
/// @param f The function to evaluate.
/// @param x0 The first initial guess for the root.
/// @param x1O The optional second initial guess for the root (default is
/// empty).
/// @param max_iter The maximum number of iterations allowed (default is 1000).
/// @param tolerance The tolerance value for convergence (default is
/// default_tolerance<T>).
/// @return A pair containing the root value and a boolean indicating if
/// convergence was achieved.
template<typename T, typename F,
         std::enable_if_t<std::is_floating_point_v<T> and
                              std::is_invocable_r_v<T, F, T>,
                          bool> = true>
constexpr auto
secant(F&& f, T x0, std::optional<T> x1O = {}, int max_iter = 1000,
       T tolerance = muc::default_tolerance<T>) -> std::pair<T, bool> {
    auto fx0{f(x0)};
    if (fx0 == 0) {
        return {x0, true};
    }
    auto x1{x1O.value_or(x0 + fx0 * 2 * tolerance /
                                  (f(x0 - tolerance) - f(x0 + tolerance)))};
    auto fx1{f(x1)};
    auto x2{(x0 * fx1 - x1 * fx0) / (fx1 - fx0)};
    for (int i{}; i < max_iter; ++i) {
        if (muc::isnan(x2)) {
            break;
        }
        if (muc::abs(x2 - x1) <= muc::abs(muc::midpoint(x2, x1)) * tolerance) {
            return {x2, true};
        }
        x0 = x1;
        fx0 = fx1;
        x1 = x2;
        fx1 = f(x2);
        x2 = (x0 * fx1 - x1 * fx0) / (fx1 - fx0);
    }
    return {x2, false};
}

/// @brief Brent's method for finding roots of a function.
/// This function implements Brent's method for finding roots of a function.
/// It iteratively narrows down the root using a combination of bisection,
/// secant, and inverse quadratic interpolation.
/// @tparam T The type of the input value.
/// @tparam F The type of the function to evaluate.
/// @param f The function to evaluate.
/// @param x1 The first initial guess for the root.
/// @param x2 The second initial guess for the root.
/// @param max_iter The maximum number of iterations allowed (default is
/// 100000).
/// @param tolerance The tolerance value for convergence (default is
/// default_tolerance<T>).
/// @return A pair containing the root value and a boolean indicating if
/// convergence was achieved.
template<typename T, typename F,
         std::enable_if_t<std::is_floating_point_v<T> and
                              std::is_invocable_r_v<T, F, T>,
                          bool> = true>
constexpr auto
zbrent(F&& f, T x1, T x2, int max_iter = 100000,
       T tolerance = muc::default_tolerance<T>) -> std::pair<T, bool> {
    auto a{x1};
    auto b{x2};
    auto c{x2};
    auto d{x2 - x1};
    auto e{x2 - x1};
    auto fa{f(a)};
    auto fb{f(b)};
    auto fc{fb};
    // Check if there is a single zero in range
    if (fa * fb > 0) {
        return {b, false};
    }
    // Start search
    for (auto iter{0ll}; iter < max_iter; ++iter) {
        if ((fb > 0 and fc > 0) or (fb < 0 and fc < 0)) {
            c = a;
            fc = fa;
            d = b - a;
            e = d;
        }
        if (muc::abs(fc) < muc::abs(fb)) {
            a = b;
            b = c;
            c = a;
            fa = fb;
            fb = fc;
            fc = fa;
        }
        if (muc::isnan(fb)) {
            break;
        }
        const auto tol{2 * std::numeric_limits<T>::epsilon() * muc::abs(b) +
                       tolerance / 2};
        const auto xm{(c - b) / 2};
        if (muc::abs(xm) <= tol or fb == 0) {
            return {b, true};
        }
        if (muc::abs(e) >= tol and muc::abs(fa) > muc::abs(fb)) {
            T p;
            T q;
            const auto s{fb / fa};
            if (a == c) {
                p = 2 * xm * s;
                q = 1 - s;
            } else {
                q = fa / fc;
                const auto r1{fb / fc};
                p = s * (2 * xm * q * (q - r1) - (b - a) * (r1 - 1));
                q = (q - 1) * (r1 - 1) * (s - 1);
            }
            if (p > 0) {
                q = -q;
            }
            p = muc::abs(p);
            if (2 * p <
                std::min(3 * xm * q - muc::abs(tol * q), muc::abs(e * q))) {
                e = d;
                d = p / q;
            } else {
                d = xm;
                e = d;
            }
        } else {
            d = xm;
            e = d;
        }
        a = b;
        fa = fb;
        if (muc::abs(d) > tol) {
            b += d;
        } else {
            b += (xm > 1) ? tol : -tol;
        }
        fb = f(b);
    }
    // nan or max_iter reached
    return {b, false};
}

} // namespace muc::find_root

#ifdef MUC_STATIC_TEST

static_assert([] {
    const auto [x, converged]{muc::find_root::newton_raphson(
        [](auto x) {
            return x * x - 1;
        },
        [](auto x) {
            return 2 * x;
        },
        0.5)};
    return converged and muc::abs(x - 1) < 2 * muc::default_tolerance<double>;
}());

static_assert([] {
    const auto [x, converged]{muc::find_root::secant(
        [](auto x) {
            return x * x - 1;
        },
        0.5)};
    return converged and muc::abs(x - 1) < 2 * muc::default_tolerance<double>;
}());

// static_assert([] {
//     const auto [x, converged]{muc::find_root::zbrent(
//         [](auto x) {
//             return x * x - 1;
//         },
//         0.5, 2.5)};
//     return converged and muc::abs(x - 1) < 2 * muc::default_tolerance<double>;
// }());

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <type_traits>

namespace muc {

/// @brief Performs trilinear interpolation.
/// @tparam T value type, can be a scalar or vector or something.
/// @tparam U scalar type
/// @param c values on square grid. See note for details.
/// @param u interpolation parameter. 0<u<1 implies interpolation, otherwise
/// extrapolation.
/// @param v interpolation parameter. 0<v<1 implies interpolation, otherwise
/// extrapolation.
/// @return interpolated value.
/// @note For parameter c:
///
///         c011    c111
///            +----+
///      c010 /|   /|
///          +----+ + c101
///          |c001|/
/// v w      +----+
/// ^ ^  c000     c100
/// |/
/// +----> u
template<typename T, typename U,
         std::enable_if_t<is_general_arithmetic_v<T>, bool> = true,
         std::enable_if_t<std::is_floating_point_v<U>, bool> = true>
constexpr auto trilerp(const T& c000, const T& c001, const T& c010,
                       const T& c011, const T& c100, const T& c101,
                       const T& c110, const T& c111, U u, U v, U w) -> T {
    return muc::bilerp(muc::lerp(c000, c001, w), muc::lerp(c010, c011, w),
                       muc::lerp(c100, c101, w), muc::lerp(c110, c111, w), u,
                       v);
}

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_PTR_SPAN_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_PTR_SPAN_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <cassert>
#include <cstddef>
#include <iterator>
#include <memory>
#include <sstream>
#include <stdexcept>
#include <type_traits>
#include <utility>

namespace muc {

template<typename T,
         typename =
             std::void_t<decltype(*std::declval<typename T::value_type>())>>
class ptr_span {
private:
    using raw_ptr_vector = T;

public:
    using value_type = typename std::pointer_traits<
        typename raw_ptr_vector::value_type>::element_type;
    using size_type = typename raw_ptr_vector::size_type;
    using difference_type = typename raw_ptr_vector::difference_type;
    using reference = value_type&;
    using const_reference = const value_type&;
    using pointer = value_type*;             // TODO: Do we need traits?
    using const_pointer = const value_type*; // TODO: Do we need traits?

private:
    template<typename RawIterator>
    class basic_iterator {
        friend class ptr_span;

    public:
        using difference_type = typename ptr_span::difference_type;
        using value_type = std::conditional_t<
            std::is_const_v<
                typename std::iterator_traits<RawIterator>::value_type>,
            const typename ptr_span::value_type, typename ptr_span::value_type>;
        using pointer = std::conditional_t<
            std::is_const_v<
                typename std::iterator_traits<RawIterator>::value_type>,
            typename ptr_span::const_pointer, typename ptr_span::pointer>;
        using reference = std::conditional_t<
            std::is_const_v<
                typename std::iterator_traits<RawIterator>::value_type>,
            typename ptr_span::const_reference, typename ptr_span::reference>;
        using iterator_category = std::random_access_iterator_tag;

    public:
        basic_iterator() :
            m_iter{} {}

    private:
        explicit basic_iterator(RawIterator iter) :
            m_iter{iter} {}

    public:
        operator basic_iterator<typename raw_ptr_vector::const_iterator>() {
            return basic_iterator<typename raw_ptr_vector::const_iterator>{
                m_iter};
        }

        auto operator*() const -> reference {
            return **m_iter;
        }

        auto operator->() const -> pointer {
            return muc::to_address(*m_iter);
        }

        auto operator[](std::size_t index) const -> reference {
            return *m_iter[index];
        }

        auto operator-(basic_iterator other) const -> difference_type {
            return m_iter - other.m_iter;
        }

        auto operator++() -> basic_iterator& {
            m_iter++;
            return *this;
        }

        auto operator++(int) -> basic_iterator {
            auto next{*this};
            ++(*this);
            return next;
        }

        auto operator--() -> basic_iterator& {
            m_iter--;
            return *this;
        }

        auto operator--(int) -> basic_iterator {
            auto prev{*this};
            --(*this);
            return prev;
        }

        auto operator+=(difference_type n) -> basic_iterator& {
            m_iter += n;
            return *this;
        }

        auto operator-=(difference_type n) -> basic_iterator& {
            m_iter -= n;
            return *this;
        }

        auto operator+(difference_type n) const -> basic_iterator {
            return basic_iterator{m_iter + n};
        }

        auto operator-(difference_type n) const -> basic_iterator {
            return basic_iterator{m_iter - n};
        }

        auto operator==(const basic_iterator& other) const -> bool {
            return m_iter == other.m_iter;
        }
#if __cplusplus >= 202002L
        auto operator<=>(const basic_iterator& other) const -> auto {
            return m_iter <=> other.m_iter;
        }
#else
        auto operator!=(const basic_iterator& other) const -> bool {
            return m_iter != other.m_iter;
        }

        auto operator<(const basic_iterator& other) const -> bool {
            return m_iter < other.m_iter;
        }

        auto operator<=(const basic_iterator& other) const -> bool {
            return m_iter <= other.m_iter;
        }

        auto operator>(const basic_iterator& other) const -> bool {
            return m_iter > other.m_iter;
        }

        auto operator>=(const basic_iterator& other) const -> bool {
            return m_iter >= other.m_iter;
        }
#endif
    private:
        RawIterator m_iter;
    };

public:
    using iterator = basic_iterator<typename raw_ptr_vector::iterator>;
    using const_iterator =
        basic_iterator<typename raw_ptr_vector::const_iterator>;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

public:
    ptr_span() noexcept :
        m_ptr_vector{} {}

    ptr_span(T& ptr_vector) noexcept :
        m_ptr_vector{&ptr_vector} {}

    ptr_span(T&& ptr_vector) = delete;

    //
    // Element access
    //

    auto at(size_type pos) -> reference {
        range_check(pos);
        return (*this)[pos];
    }

    auto at(size_type pos) const -> const_reference {
        range_check(pos);
        return (*this)[pos];
    }

    auto operator[](size_type pos) -> reference {
        assert(pos < size());
        return *m_ptr_vector[pos];
    }

    auto operator[](size_type pos) const -> const_reference {
        assert(pos < size());
        return *m_ptr_vector[pos];
    }

    auto front() -> reference {
        assert(not empty());
        return *m_ptr_vector->front();
    }

    auto front() const -> const_reference {
        assert(not empty());
        return *m_ptr_vector->front();
    }

    auto back() -> reference {
        assert(not empty());
        return *m_ptr_vector->back();
    }

    auto back() const -> const_reference {
        assert(not empty());
        return *m_ptr_vector->back();
    }

    auto underlying() -> raw_ptr_vector& {
        return *m_ptr_vector;
    }

    auto underlying() const -> const raw_ptr_vector& {
        return *m_ptr_vector;
    }

    //
    // Iterators
    //

    auto begin() const noexcept -> const_iterator {
        return const_iterator{m_ptr_vector->begin()};
    }

    auto cbegin() const noexcept -> const_iterator {
        return begin();
    }

    auto end() const noexcept -> const_iterator {
        return const_iterator{m_ptr_vector->end()};
    }

    auto cend() const noexcept -> const_iterator {
        return end();
    }

    auto rbegin() const noexcept -> const_reverse_iterator {
        return const_reverse_iterator{end()};
    }

    auto crbegin() const noexcept -> const_reverse_iterator {
        return rbegin();
    }

    auto rend() const noexcept -> const_reverse_iterator {
        return const_reverse_iterator{begin()};
    }

    auto crend() const noexcept -> const_reverse_iterator {
        return rend();
    }

    //
    // Pointer vector iterator
    //

    auto pbegin() noexcept -> typename raw_ptr_vector::iterator {
        return m_ptr_vector->begin();
    }

    auto pbegin() const noexcept -> typename raw_ptr_vector::const_iterator {
        return m_ptr_vector->begin();
    }

    auto pcbegin() const noexcept -> typename raw_ptr_vector::const_iterator {
        return m_ptr_vector->cbegin();
    }

    auto pend() noexcept -> typename raw_ptr_vector::iterator {
        return m_ptr_vector->end();
    }

    auto pend() const noexcept -> typename raw_ptr_vector::const_iterator {
        return m_ptr_vector->end();
    }

    auto pcend() const noexcept -> typename raw_ptr_vector::const_iterator {
        return m_ptr_vector->cend();
    }

    auto prbegin() noexcept -> typename raw_ptr_vector::reverse_iterator {
        return m_ptr_vector->rbegin();
    }

    auto prbegin() const noexcept ->
        typename raw_ptr_vector::const_reverse_iterator {
        return m_ptr_vector->rbegin();
    }

    auto pcrbegin() const noexcept ->
        typename raw_ptr_vector::const_reverse_iterator {
        return m_ptr_vector->crbegin();
    }

    auto prend() noexcept -> typename raw_ptr_vector::reverse_iterator {
        return m_ptr_vector->rend();
    }

    auto prend() const noexcept ->
        typename raw_ptr_vector::const_reverse_iterator {
        return m_ptr_vector->rend();
    }

    auto pcrend() const noexcept ->
        typename raw_ptr_vector::const_reverse_iterator {
        return m_ptr_vector->crend();
    }

    //
    // Writable iterators & range
    //

    auto vbegin() noexcept -> iterator {
        return iterator{m_ptr_vector->begin()};
    }

    auto vend() noexcept -> iterator {
        return iterator{m_ptr_vector->end()};
    }

    auto vrbegin() noexcept -> reverse_iterator {
        return reverse_iterator{vend()};
    }

    auto vrend() noexcept -> reverse_iterator {
        return reverse_iterator{vbegin()};
    }

    class vrange_type {
        friend auto ptr_span::vrange() const noexcept -> vrange_type;

    public:
        auto begin() const noexcept -> iterator {
            return iterator{m_ptr_vector->begin()};
        }

        auto end() const noexcept -> iterator {
            return iterator{m_ptr_vector->end()};
        }

        auto rbegin() const noexcept -> reverse_iterator {
            return reverse_iterator{end()};
        }

        auto rend() const noexcept -> reverse_iterator {
            return reverse_iterator{begin()};
        }

    private:
        raw_ptr_vector* m_ptr_vector;
    };

    auto vrange() const noexcept -> vrange_type {
        return m_ptr_vector;
    }

    //
    // Capacity
    //

    [[nodiscard]] auto empty() const noexcept -> bool {
        return m_ptr_vector ? m_ptr_vector->empty() : true;
    }

    auto size() const noexcept -> size_type {
        return m_ptr_vector ? m_ptr_vector->size() : 0;
    }

    auto max_size() const noexcept -> size_type {
        return m_ptr_vector->max_size();
    }

    auto reserve(size_type new_capacity) -> void {
        return m_ptr_vector->reserve(new_capacity);
    }

    auto capacity() const noexcept -> size_type {
        return m_ptr_vector->capacity();
    }

    auto shrink_to_fit() -> void {
        return m_ptr_vector->shrink_to_fit();
    }

    //
    // Modifier
    //

    auto clear() -> void {
        m_ptr_vector->clear();
    }

    auto erase(const_iterator pos) -> iterator {
        return iterator{m_ptr_vector->erase(pos.m_iter)};
    }

    auto erase(const_iterator first, const_iterator last) -> iterator {
        return iterator{m_ptr_vector->erase(first.m_iter, last.m_iter)};
    }

    auto pop_back() -> void {
        m_ptr_vector->pop_back();
    }

    auto swap(ptr_span& other) noexcept -> void {
        std::swap(m_ptr_vector, other.m_ptr_vector);
    }

    //
    // Compare
    //

    auto operator==(const ptr_span& other) const -> bool {
        return *m_ptr_vector == *other.m_ptr_vector;
    }
#if __cplusplus >= 202002L
    auto operator<=>(const ptr_span& other) const -> auto {
        return *m_ptr_vector <=> *other.m_ptr_vector;
    }
#else
    auto operator!=(const ptr_span& other) const -> bool {
        return *m_ptr_vector != *other.m_ptr_vector;
    }

    auto operator<(const ptr_span& other) const -> bool {
        return *m_ptr_vector < *other.m_ptr_vector;
    }

    auto operator<=(const ptr_span& other) const -> bool {
        return *m_ptr_vector <= *other.m_ptr_vector;
    }

    auto operator>(const ptr_span& other) const -> bool {
        return *m_ptr_vector > *other.m_ptr_vector;
    }

    auto operator>=(const ptr_span& other) const -> bool {
        return *m_ptr_vector >= *other.m_ptr_vector;
    }
#endif

private:
    auto range_check(size_type pos) const -> void {
        if (pos >= size()) {
            std::stringstream ss;
            ss << "muc::ptr_span::range_check: pos >= size() [" << pos
               << " >= " << size() << ']';
            throw std::out_of_range{ss.str()};
        }
    }

private:
    raw_ptr_vector* m_ptr_vector;
};

template<typename T>
auto swap(ptr_span<T>& lhs,
          ptr_span<T>& rhs) noexcept(noexcept(lhs.swap(rhs))) -> void {
    lhs.swap(rhs);
}

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_PTR_VECTOR_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_PTR_VECTOR_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <algorithm>
#include <cassert>
#include <cstddef>
#include <initializer_list>
#include <iterator>
#include <memory>
#include <sstream>
#include <stdexcept>
#include <type_traits>
#include <utility>

namespace muc::impl {
#if false
namespace impl {

template<typename T>
struct as_pointer {
    struct type : T {
    public:
        using T::T;

        auto operator*() noexcept -> T& {
            return *this;
        }

        auto operator*() const noexcept -> const T& {
            return *this;
        }

        auto operator->() noexcept -> T* {
            return this;
        }

        auto operator->() const noexcept -> const T* {
            return this;
        }
    };
};

template<typename T>
struct as_pointer<T*> {
    using type = T*;
};

template<typename T>
using as_pointer_t = typename as_pointer<T>::type;

} // namespace impl
#endif
template<typename Derived, typename RawPtrVector>
class ptr_vector_base {
protected:
    using raw_ptr_vector = RawPtrVector;

public:
    using value_type = typename std::pointer_traits<
        typename raw_ptr_vector::value_type>::element_type;
    using allocator_type = typename std::allocator_traits<
        typename raw_ptr_vector::allocator_type>::
        template rebind_alloc<value_type>;
    using size_type = typename raw_ptr_vector::size_type;
    using difference_type = typename raw_ptr_vector::difference_type;
    using reference = value_type&;
    using const_reference = const value_type&;
    using pointer = typename std::allocator_traits<allocator_type>::pointer;
    using const_pointer =
        typename std::allocator_traits<allocator_type>::const_pointer;

private:
    template<typename RawIterator>
    class basic_iterator {
        friend class ptr_vector_base;

    public:
        using difference_type = typename ptr_vector_base::difference_type;
        using value_type =
            std::conditional_t<std::is_const_v<typename std::iterator_traits<
                                   RawIterator>::value_type>,
                               const typename ptr_vector_base::value_type,
                               typename ptr_vector_base::value_type>;
        using pointer =
            std::conditional_t<std::is_const_v<typename std::iterator_traits<
                                   RawIterator>::value_type>,
                               typename ptr_vector_base::const_pointer,
                               typename ptr_vector_base::pointer>;
        using reference =
            std::conditional_t<std::is_const_v<typename std::iterator_traits<
                                   RawIterator>::value_type>,
                               typename ptr_vector_base::const_reference,
                               typename ptr_vector_base::reference>;
        using iterator_category = std::random_access_iterator_tag;

    public:
        basic_iterator() :
            m_iter{} {}

    private:
        explicit basic_iterator(RawIterator iter) :
            m_iter{iter} {}

    public:
        operator basic_iterator<typename raw_ptr_vector::const_iterator>() {
            return basic_iterator<typename raw_ptr_vector::const_iterator>{
                m_iter};
        }

        auto operator*() const -> reference {
            return **m_iter;
        }

        auto operator->() const -> pointer {
            return muc::to_address(*m_iter);
        }

        auto operator[](std::size_t index) const -> reference {
            return *m_iter[index];
        }

        auto operator-(basic_iterator other) const -> difference_type {
            return m_iter - other.m_iter;
        }

        auto operator++() -> basic_iterator& {
            m_iter++;
            return *this;
        }

        auto operator++(int) -> basic_iterator {
            auto next{*this};
            ++(*this);
            return next;
        }

        auto operator--() -> basic_iterator& {
            m_iter--;
            return *this;
        }

        auto operator--(int) -> basic_iterator {
            auto prev{*this};
            --(*this);
            return prev;
        }

        auto operator+=(difference_type n) -> basic_iterator& {
            m_iter += n;
            return *this;
        }

        auto operator-=(difference_type n) -> basic_iterator& {
            m_iter -= n;
            return *this;
        }

        auto operator+(difference_type n) const -> basic_iterator {
            return basic_iterator{m_iter + n};
        }

        auto operator-(difference_type n) const -> basic_iterator {
            return basic_iterator{m_iter - n};
        }

        auto operator==(const basic_iterator& other) const -> bool {
            return m_iter == other.m_iter;
        }
#if __cplusplus >= 202002L
        auto operator<=>(const basic_iterator& other) const -> auto {
            return m_iter <=> other.m_iter;
        }
#else
        auto operator!=(const basic_iterator& other) const -> bool {
            return m_iter != other.m_iter;
        }

        auto operator<(const basic_iterator& other) const -> bool {
            return m_iter < other.m_iter;
        }

        auto operator<=(const basic_iterator& other) const -> bool {
            return m_iter <= other.m_iter;
        }

        auto operator>(const basic_iterator& other) const -> bool {
            return m_iter > other.m_iter;
        }

        auto operator>=(const basic_iterator& other) const -> bool {
            return m_iter >= other.m_iter;
        }
#endif
    private:
        RawIterator m_iter;
    };

public:
    using iterator = basic_iterator<typename raw_ptr_vector::iterator>;
    using const_iterator =
        basic_iterator<typename raw_ptr_vector::const_iterator>;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

protected:
    ptr_vector_base() :
        m_ptr_vector{} {}

    ptr_vector_base(const raw_ptr_vector& ptr_vec) :
        m_ptr_vector{ptr_vec} {}

    ptr_vector_base(raw_ptr_vector&& ptr_vec) :
        m_ptr_vector{std::move(ptr_vec)} {}

    template<typename... Args>
    ptr_vector_base(Args&&... args) :
        m_ptr_vector{std::forward<Args>(args)...} {}

    ptr_vector_base(const ptr_vector_base&) = default;

    ptr_vector_base(ptr_vector_base&&) noexcept = default;

    ~ptr_vector_base() = default;

public:
    //
    // Assignment
    //

    auto operator=(const ptr_vector_base& other) -> ptr_vector_base& = default;

    auto operator=(ptr_vector_base&& other) noexcept(
        std::is_nothrow_move_constructible_v<raw_ptr_vector>)
        -> ptr_vector_base& = default;
#if false
    auto
    operator=(std::initializer_list<value_type> ilist) -> ptr_vector_base& {
        m_ptr_vector.clear();
        insert(cend(), std::move(ilist));
        return *this;
    }

    auto assign(size_type count, const value_type& value) -> void {
        m_ptr_vector.clear();
        insert(cend(), count, value);
    }

    template<typename InputIt>
    auto assign(InputIt first, InputIt last) -> void {
        m_ptr_vector.clear();
        insert(cend(), first, last);
    }

    auto assign(std::initializer_list<value_type> ilist) -> void {
        m_ptr_vector.clear();
        insert(cend(), std::move(ilist));
    }
#endif
    auto get_allocator() const -> allocator_type {
        return allocator_type{m_ptr_vector.get_allocator()};
    }

    //
    // Element access
    //

    auto at(size_type pos) -> reference {
        range_check(pos);
        return (*this)[pos];
    }

    auto at(size_type pos) const -> const_reference {
        range_check(pos);
        return (*this)[pos];
    }

    auto operator[](size_type pos) -> reference {
        assert(pos < size());
        return *m_ptr_vector[pos];
    }

    auto operator[](size_type pos) const -> const_reference {
        assert(pos < size());
        return *m_ptr_vector[pos];
    }

    auto front() -> reference {
        assert(not empty());
        return *m_ptr_vector.front();
    }

    auto front() const -> const_reference {
        assert(not empty());
        return *m_ptr_vector.front();
    }

    auto back() -> reference {
        assert(not empty());
        return *m_ptr_vector.back();
    }

    auto back() const -> const_reference {
        assert(not empty());
        return *m_ptr_vector.back();
    }

    auto underlying() -> raw_ptr_vector& {
        return m_ptr_vector;
    }

    auto underlying() const -> const raw_ptr_vector& {
        return m_ptr_vector;
    }

    //
    // Iterators
    //

    auto begin() const noexcept -> const_iterator {
        return const_iterator{m_ptr_vector.begin()};
    }

    auto cbegin() const noexcept -> const_iterator {
        return begin();
    }

    auto end() const noexcept -> const_iterator {
        return const_iterator{m_ptr_vector.end()};
    }

    auto cend() const noexcept -> const_iterator {
        return end();
    }

    auto rbegin() const noexcept -> const_reverse_iterator {
        return const_reverse_iterator{end()};
    }

    auto crbegin() const noexcept -> const_reverse_iterator {
        return rbegin();
    }

    auto rend() const noexcept -> const_reverse_iterator {
        return const_reverse_iterator{begin()};
    }

    auto crend() const noexcept -> const_reverse_iterator {
        return rend();
    }

    //
    // Pointer vector iterator
    //

    auto pbegin() noexcept -> typename raw_ptr_vector::iterator {
        return m_ptr_vector.begin();
    }

    auto pbegin() const noexcept -> typename raw_ptr_vector::const_iterator {
        return m_ptr_vector.begin();
    }

    auto pcbegin() const noexcept -> typename raw_ptr_vector::const_iterator {
        return m_ptr_vector.cbegin();
    }

    auto pend() noexcept -> typename raw_ptr_vector::iterator {
        return m_ptr_vector.end();
    }

    auto pend() const noexcept -> typename raw_ptr_vector::const_iterator {
        return m_ptr_vector.end();
    }

    auto pcend() const noexcept -> typename raw_ptr_vector::const_iterator {
        return m_ptr_vector.cend();
    }

    auto prbegin() noexcept -> typename raw_ptr_vector::reverse_iterator {
        return m_ptr_vector.rbegin();
    }

    auto prbegin() const noexcept ->
        typename raw_ptr_vector::const_reverse_iterator {
        return m_ptr_vector.rbegin();
    }

    auto pcrbegin() const noexcept ->
        typename raw_ptr_vector::const_reverse_iterator {
        return m_ptr_vector.crbegin();
    }

    auto prend() noexcept -> typename raw_ptr_vector::reverse_iterator {
        return m_ptr_vector.rend();
    }

    auto prend() const noexcept ->
        typename raw_ptr_vector::const_reverse_iterator {
        return m_ptr_vector.rend();
    }

    auto pcrend() const noexcept ->
        typename raw_ptr_vector::const_reverse_iterator {
        return m_ptr_vector.crend();
    }

    //
    // Writable iterators & range
    //

    auto vbegin() noexcept -> iterator {
        return iterator{m_ptr_vector.begin()};
    }

    auto vend() noexcept -> iterator {
        return iterator{m_ptr_vector.end()};
    }

    auto vrbegin() noexcept -> reverse_iterator {
        return reverse_iterator{vend()};
    }

    auto vrend() noexcept -> reverse_iterator {
        return reverse_iterator{vbegin()};
    }

    class vrange_type {
        friend auto ptr_vector_base::vrange() const noexcept -> vrange_type;

    public:
        auto begin() const noexcept -> iterator {
            return iterator{m_ptr_vector->begin()};
        }

        auto end() const noexcept -> iterator {
            return iterator{m_ptr_vector->end()};
        }

        auto rbegin() const noexcept -> reverse_iterator {
            return reverse_iterator{end()};
        }

        auto rend() const noexcept -> reverse_iterator {
            return reverse_iterator{begin()};
        }

    private:
        raw_ptr_vector* m_ptr_vector;
    };

    auto vrange() const noexcept -> vrange_type {
        return m_ptr_vector;
    }

    //
    // Capacity
    //

    [[nodiscard]] auto empty() const noexcept -> bool {
        return m_ptr_vector.empty();
    }

    auto size() const noexcept -> size_type {
        return m_ptr_vector.size();
    }

    auto max_size() const noexcept -> size_type {
        return m_ptr_vector.max_size();
    }

    auto reserve(size_type new_capacity) -> void {
        return m_ptr_vector.reserve(new_capacity);
    }

    auto capacity() const noexcept -> size_type {
        return m_ptr_vector.capacity();
    }

    auto shrink_to_fit() -> void {
        return m_ptr_vector.shrink_to_fit();
    }

    //
    // Modifier
    //

    auto clear() -> void {
        m_ptr_vector.clear();
    }

    auto insert(const_iterator pos, const value_type& value) -> iterator {
        return emplace(pos, value);
    }

    auto insert(const_iterator pos, value_type&& value) -> iterator {
        return emplace(pos, std::move(value));
    }
#if false
    auto insert(const_iterator pos, size_type count,
                const value_type& value) -> iterator {
        const auto i_pos{pos - cbegin()};

        m_ptr_vector.resize(size() + count);
        const auto first{pbegin() + i_pos};
        const auto last{first + count};

        std::move_backward(first, last, pend());
        std::generate(first, last, [&]() {
            return allocate_ptr(value);
        });

        return iterator{first};
    }

    template<typename InputIt>
    auto insert(const_iterator pos, InputIt first, InputIt last) -> iterator {
        const auto i_pos{pos - cbegin()};
        const auto count{std::distance(first, last)};

        m_ptr_vector.resize(size() + count);
        const auto dst_first{pbegin() + i_pos};
        const auto dst_last{dst_first + count};

        std::move_backward(dst_first, dst_last, pend());
        std::generate(dst_first, dst_last, [&]() {
            return allocate_ptr(*first++);
        });

        return iterator{dst_first};
    }

    auto insert(const_iterator pos,
                std::initializer_list<value_type> ilist) -> iterator {
        return insert(pos, ilist.begin(), ilist.end());
    }
#endif
    template<typename... Args>
    auto emplace(const_iterator pos, Args&&... args) -> iterator {
        return iterator{m_ptr_vector.emplace(
            pos.m_iter, allocate_ptr(std::forward<Args>(args)...))};
    }

    auto erase(const_iterator pos) -> iterator {
        return iterator{m_ptr_vector.erase(pos.m_iter)};
    }

    auto erase(const_iterator first, const_iterator last) -> iterator {
        return iterator{m_ptr_vector.erase(first.m_iter, last.m_iter)};
    }

    auto push_back(const value_type& value) -> void {
        emplace_back(value);
    }

    auto push_back(value_type&& value) -> void {
        emplace_back(std::move(value));
    }

    template<typename... Args>
    auto emplace_back(Args&&... args) -> reference {
        return *m_ptr_vector.emplace_back(
            allocate_ptr(std::forward<Args>(args)...));
    }

    auto pop_back() -> void {
        m_ptr_vector.pop_back();
    }
#if false
    auto resize(size_type count) -> void {
        if (size() >= count) {
            erase(cbegin() + count, cend());
        } else {
            const auto first{
                m_ptr_vector.insert(m_ptr_vector.cend(), count - size(), {})};
            const auto last{m_ptr_vector.end()};
            for (auto i{first}; i != last; ++i) {
                *i = allocate_ptr();
            }
        }
    }

    auto resize(size_type count, const value_type& value) -> void {
        if (size() >= count) {
            erase(cbegin() + count, cend());
        } else {
            const auto first{
                m_ptr_vector.insert(m_ptr_vector.cend(), count - size(), {})};
            const auto last{m_ptr_vector.end()};
            for (auto i{first}; i != last; ++i) {
                *i = allocate_ptr(value);
            }
        }
    }
#endif
    auto swap(ptr_vector_base& other) noexcept -> void {
        m_ptr_vector.swap(other.m_ptr_vector);
    }

    //
    // Compare
    //

    auto operator==(const ptr_vector_base& other) const -> bool {
        return m_ptr_vector == other.m_ptr_vector;
    }
#if __cplusplus >= 202002L
    auto operator<=>(const ptr_vector_base& other) const -> auto {
        return m_ptr_vector <=> other.m_ptr_vector;
    }
#else
    auto operator!=(const ptr_vector_base& other) const -> bool {
        return m_ptr_vector != other.m_ptr_vector;
    }

    auto operator<(const ptr_vector_base& other) const -> bool {
        return m_ptr_vector < other.m_ptr_vector;
    }

    auto operator<=(const ptr_vector_base& other) const -> bool {
        return m_ptr_vector <= other.m_ptr_vector;
    }

    auto operator>(const ptr_vector_base& other) const -> bool {
        return m_ptr_vector > other.m_ptr_vector;
    }

    auto operator>=(const ptr_vector_base& other) const -> bool {
        return m_ptr_vector >= other.m_ptr_vector;
    }
#endif

private:
    auto range_check(size_type pos) const -> void {
        if (pos >= size()) {
            std::stringstream ss;
            ss << "muc::impl::ptr_vector_base::range_check: pos >= size() "
               << '[' << pos << " >= " << size() << ']';
            throw std::out_of_range{ss.str()};
        }
    }

    template<typename... Args>
    auto allocate_ptr(Args&&... args) const ->
        typename raw_ptr_vector::value_type {
        return static_cast<const Derived*>(this)->allocate_ptr(
            std::forward<Args>(args)...);
    }

protected:
    raw_ptr_vector m_ptr_vector;
};

} // namespace muc::impl

#include <initializer_list>
#include <iterator>
#include <memory>
#include <memory_resource>
#include <type_traits>
#include <utility>
#include <vector>

namespace muc {

template<typename T, typename Allocator = typename std::allocator<T>>
class shared_ptr_vector :
    public impl::ptr_vector_base<
        shared_ptr_vector<T, Allocator>,
        std::vector<std::shared_ptr<T>,
                    typename std::allocator_traits<Allocator>::
                        template rebind_alloc<std::shared_ptr<T>>>> {
    static_assert(not std::is_reference_v<T>,
                  "value type of muc::shared_ptr_vector cannot be a reference");
    static_assert(not std::is_array_v<T>,
                  "value type of muc::shared_ptr_vector cannot be an array");
    static_assert(std::is_same_v<typename Allocator::value_type, T>,
                  "muc::shared_ptr_vector must have the same value_type as its "
                  "allocator");

private:
    using base = impl::ptr_vector_base<
        shared_ptr_vector<T, Allocator>,
        std::vector<std::shared_ptr<T>,
                    typename std::allocator_traits<
                        Allocator>::template rebind_alloc<std::shared_ptr<T>>>>;

    friend base; // for access allocate_ptr

public:
    shared_ptr_vector() noexcept(noexcept(Allocator{})) = default;

    explicit shared_ptr_vector(const Allocator& alloc) noexcept :
        base{typename base::raw_ptr_vector::allocator_type{alloc}} {}
#if false
    shared_ptr_vector(size_type count, const T& value,
                      const Allocator& alloc = {}) :
        base{count, alloc} {
        for (auto&& ptr : this->m_ptr_vector) {
            ptr = allocate_ptr(value);
        }
    }

    shared_ptr_vector(size_type count, const Allocator& alloc = {}) :
        base{count, alloc} {
        for (auto&& ptr : this->m_ptr_vector) {
            ptr = allocate_ptr();
        }
    }

    template<typename InputIt>
    shared_ptr_vector(InputIt first, InputIt last,
                      const Allocator& alloc = {}) :
        base{alloc} {
        this->insert(this->cend(), first, last);
    }
#endif
    shared_ptr_vector(const shared_ptr_vector&) = default;

    shared_ptr_vector(shared_ptr_vector&&) noexcept = default;

    shared_ptr_vector(const shared_ptr_vector& other, const Allocator& alloc) :
        base{other.m_ptr_vector,
             typename base::raw_ptr_vector::allocator_type{alloc}} {}

    shared_ptr_vector(shared_ptr_vector&& other, const Allocator& alloc) :
        base{std::move(other.m_ptr_vector),
             typename base::raw_ptr_vector::allocator_type{alloc}} {}

    shared_ptr_vector(const typename base::raw_ptr_vector& ptr_vector,
                      const Allocator& alloc = {}) :
        base{ptr_vector, typename base::raw_ptr_vector::allocator_type{alloc}} {
    }

    shared_ptr_vector(typename base::raw_ptr_vector&& ptr_vector,
                      const Allocator& alloc = {}) :
        base{std::move(ptr_vector),
             typename base::raw_ptr_vector::allocator_type{alloc}} {}

    template<
        typename C,
        std::enable_if_t<std::is_lvalue_reference_v<const C&>, bool> = true,
        typename = std::void_t<decltype(std::begin(std::declval<const C&>()))>,
        typename = std::void_t<decltype(std::end(std::declval<const C&>()))>,
        std::enable_if_t<
            std::is_constructible_v<typename base::raw_ptr_vector::value_type,
                                    decltype(*std::begin(std::declval<C>())++)>,
            bool> = true>
    shared_ptr_vector(const C& ptr_vector, const Allocator& alloc = {}) :
        shared_ptr_vector{alloc} {
        auto first{std::begin(ptr_vector)};
        const auto last{std::end(ptr_vector)};
        this->reserve(std::distance(first, last));
        while (first != last) {
            this->m_ptr_vector.push_back(
                typename base::raw_ptr_vector::value_type{*first++});
        }
    }

    template<typename C,
             std::enable_if_t<std::is_rvalue_reference_v<C&&>, bool> = true,
             typename = std::void_t<decltype(std::begin(std::declval<C>()))>,
             typename = std::void_t<decltype(std::end(std::declval<C>()))>,
             std::enable_if_t<
                 std::is_constructible_v<
                     typename base::raw_ptr_vector::value_type,
                     decltype(std::move(*std::begin(std::declval<C>())++))>,
                 bool> = true>
    shared_ptr_vector(C&& ptr_vector, const Allocator& alloc = {}) :
        shared_ptr_vector{alloc} {
        auto first{std::begin(ptr_vector)};
        const auto last{std::end(ptr_vector)};
        this->reserve(std::distance(first, last));
        while (first != last) {
            this->m_ptr_vector.push_back(
                typename base::raw_ptr_vector::value_type{std::move(*first++)});
        }
    }
#if false
    shared_ptr_vector(std::initializer_list<T> init,
                      const Allocator& alloc = {}) :
        base{alloc} {
        this->insert(this->cend(), std::move(init));
    }
#endif
private:
    template<typename... Args>
    auto allocate_ptr(Args&&... args) const -> std::shared_ptr<T> {
        return std::allocate_shared<T>(this->get_allocator(),
                                       std::forward<Args>(args)...);
    }
};

template<typename T, typename Allocator>
auto swap(shared_ptr_vector<T, Allocator>& lhs,
          shared_ptr_vector<T, Allocator>&
              rhs) noexcept(noexcept(lhs.swap(rhs))) -> void {
    lhs.swap(rhs);
}

namespace pmr {

template<typename T>
using shared_ptr_vector =
    ::muc::shared_ptr_vector<T, std::pmr::polymorphic_allocator<T>>;

} // namespace pmr

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <initializer_list>
#include <iterator>
#include <memory>
#include <memory_resource>
#include <type_traits>
#include <utility>
#include <vector>

namespace muc {

template<typename T, typename Allocator = typename std::allocator<T>>
class unique_ptr_vector :
    public impl::ptr_vector_base<
        unique_ptr_vector<T, Allocator>,
        std::vector<
            std::unique_ptr<T, allocator_delete<Allocator>>,
            typename std::allocator_traits<Allocator>::template rebind_alloc<
                std::unique_ptr<T, allocator_delete<Allocator>>>>> {
    static_assert(not std::is_reference_v<T>,
                  "value type of muc::unique_ptr_vector cannot be a reference");
    static_assert(not std::is_array_v<T>,
                  "value type of muc::unique_ptr_vector cannot be an array");
    static_assert(std::is_same_v<typename Allocator::value_type, T>,
                  "muc::shared_ptr_vector must have the same value_type as its "
                  "allocator");

private:
    using base = impl::ptr_vector_base<
        unique_ptr_vector<T, Allocator>,
        std::vector<
            std::unique_ptr<T, allocator_delete<Allocator>>,
            typename std::allocator_traits<Allocator>::template rebind_alloc<
                std::unique_ptr<T, allocator_delete<Allocator>>>>>;

    friend base; // for access allocate_ptr

public:
    unique_ptr_vector() noexcept(noexcept(Allocator{})) = default;

    explicit unique_ptr_vector(const Allocator& alloc) noexcept :
        base{typename base::raw_ptr_vector::allocator_type{alloc}} {}
#if false
    unique_ptr_vector(size_type count, const T& value,
                      const Allocator& alloc = {}) :
        base{count, alloc} {
        for (auto&& ptr : this->m_ptr_vector) {
            ptr = allocate_ptr(value);
        }
    }

    explicit unique_ptr_vector(size_type count, const Allocator& alloc = {}) :
        base{count, alloc} {
        for (auto&& ptr : this->m_ptr_vector) {
            ptr = allocate_ptr();
        }
    }

    template<typename InputIt>
    unique_ptr_vector(InputIt first, InputIt last,
                      const Allocator& alloc = {}) :
        base{alloc} {
        this->insert(this->cend(), first, last);
    }
#endif
    unique_ptr_vector(const unique_ptr_vector&) = default;

    unique_ptr_vector(unique_ptr_vector&&) noexcept = default;

    unique_ptr_vector(const unique_ptr_vector& other, const Allocator& alloc) :
        base{other.m_ptr_vector,
             typename base::raw_ptr_vector::allocator_type{alloc}} {}

    unique_ptr_vector(unique_ptr_vector&& other, const Allocator& alloc) :
        base{std::move(other.m_ptr_vector),
             typename base::raw_ptr_vector::allocator_type{alloc}} {}

    unique_ptr_vector(const typename base::raw_ptr_vector& ptr_vector,
                      const Allocator& alloc = {}) :
        base{ptr_vector, typename base::raw_ptr_vector::allocator_type{alloc}} {
    }

    unique_ptr_vector(typename base::raw_ptr_vector&& ptr_vector,
                      const Allocator& alloc = {}) :
        base{std::move(ptr_vector),
             typename base::raw_ptr_vector::allocator_type{alloc}} {}

    template<
        typename C,
        std::enable_if_t<std::is_lvalue_reference_v<const C&>, bool> = true,
        typename = std::void_t<decltype(std::begin(std::declval<const C&>()))>,
        typename = std::void_t<decltype(std::end(std::declval<const C&>()))>,
        std::enable_if_t<
            std::is_constructible_v<typename base::raw_ptr_vector::value_type,
                                    decltype(*std::begin(std::declval<C>())++)>,
            bool> = true>
    unique_ptr_vector(const C& ptr_vector, const Allocator& alloc = {}) :
        unique_ptr_vector{alloc} {
        auto first{std::begin(ptr_vector)};
        const auto last{std::end(ptr_vector)};
        this->reserve(std::distance(first, last));
        while (first != last) {
            this->m_ptr_vector.push_back(
                typename base::raw_ptr_vector::value_type{*first++});
        }
    }

    template<typename C,
             std::enable_if_t<std::is_rvalue_reference_v<C&&>, bool> = true,
             typename = std::void_t<decltype(std::begin(std::declval<C>()))>,
             typename = std::void_t<decltype(std::end(std::declval<C>()))>,
             std::enable_if_t<
                 std::is_constructible_v<
                     typename base::raw_ptr_vector::value_type,
                     decltype(std::move(*std::begin(std::declval<C>())++))>,
                 bool> = true>
    unique_ptr_vector(C&& ptr_vector, const Allocator& alloc = {}) :
        unique_ptr_vector{alloc} {
        auto first{std::begin(ptr_vector)};
        const auto last{std::end(ptr_vector)};
        this->reserve(std::distance(first, last));
        while (first != last) {
            this->m_ptr_vector.push_back(
                typename base::raw_ptr_vector::value_type{std::move(*first++)});
        }
    }
#if false
    unique_ptr_vector(std::initializer_list<T> init,
                      const Allocator& alloc = {}) :
        base{alloc} {
        this->insert(this->cend(), std::move(init));
    }
#endif
private:
    template<typename... Args>
    auto allocate_ptr(Args&&... args) const
        -> std::unique_ptr<T, allocator_delete<Allocator>> {
        return allocate_unique<T>(this->get_allocator(),
                                  std::forward<Args>(args)...);
    }
};

template<typename T, typename Allocator>
auto swap(unique_ptr_vector<T, Allocator>& lhs,
          unique_ptr_vector<T, Allocator>&
              rhs) noexcept(noexcept(lhs.swap(rhs))) -> void {
    lhs.swap(rhs);
}

namespace pmr {

template<typename T>
using unique_ptr_vector =
    ::muc::unique_ptr_vector<T, std::pmr::polymorphic_allocator<T>>;

} // namespace pmr

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_TIME_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_TIME_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// Linux/BSD implementation:
#if (defined linux or defined __linux__ or defined __linux) or             \
    (defined __DragonFly__ or defined __FreeBSD__ or defined __NetBSD__ or \
     defined __OpenBSD__)
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <ctime>
#include <sys/time.h>

namespace muc::impl {

template<typename Time>
class cpu_time_stopwatch {
public:
    cpu_time_stopwatch() noexcept :
        m_t0{} {
        clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &m_t0);
    }

    auto s_used() const noexcept -> Time {
        return ns_used() / 1'000'000'000;
    }

    auto ms_used() const noexcept -> Time {
        return ns_used() / 1'000'000;
    }

    auto us_used() const noexcept -> Time {
        return ns_used() / 1'000;
    }

    auto ns_used() const noexcept -> Time {
        std::timespec t;
        clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &t);
        return static_cast<Time>(t.tv_sec - m_t0.tv_sec) * 1'000'000'000 +
               static_cast<Time>(t.tv_nsec - m_t0.tv_nsec);
    }

private:
    std::timespec m_t0;
};

} // namespace muc::impl
// Windows implementation:
#elif defined _WIN32
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#if defined _MSC_VER and not defined __clang__ and not defined __GNUC__ and \
    not defined NOMINMAX
#define NOMINMAX // Otherwise MS compilers act like idiots when using
                 // std::numeric_limits<>::max() and including windows.h
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#undef WIN32_LEAN_AND_MEAN
#else
#include <windows.h>
#endif

#include <cstring>
#include <type_traits>

namespace muc::impl {

template<typename Time>
class cpu_time_stopwatch {
public:
    cpu_time_stopwatch() noexcept :
        m_current_process{GetCurrentProcess()},
        m_t0{clock_in_100ns()} {}

    auto s_used() const noexcept -> Time {
        return hecto_ns_used() / 10'000'000;
    }

    auto ms_used() const noexcept -> Time {
        return hecto_ns_used() / 10'000;
    }

    auto us_used() const noexcept -> Time {
        return hecto_ns_used() / 10;
    }

    auto ns_used() const noexcept -> Time {
        return hecto_ns_used() * 100;
    }

private:
    auto hecto_ns_used() const noexcept -> Time {
        return static_cast<Time>(clock_in_100ns().QuadPart - m_t0.QuadPart);
    }

    auto clock_in_100ns() const noexcept -> ULARGE_INTEGER {
        FILETIME t_creation;
        FILETIME t_exit;
        FILETIME t_kernel;
        FILETIME t_user;
        GetProcessTimes(m_current_process, &t_creation, &t_exit, &t_kernel,
                        &t_user);
        ULARGE_INTEGER t;
        static_assert(sizeof(FILETIME) == sizeof(ULARGE_INTEGER));
        static_assert(std::is_trivially_copyable_v<FILETIME>);
        static_assert(std::is_trivially_copyable_v<ULARGE_INTEGER>);
        std::memcpy(&t, &t_user, sizeof(FILETIME));
        return t;
    }

private:
    HANDLE m_current_process;
    ULARGE_INTEGER m_t0;
};

} // namespace muc::impl
// Fallback implementation:
#else
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <ctime>

namespace muc::impl {

template<typename Time>
class cpu_time_stopwatch {
public:
    cpu_time_stopwatch() noexcept :
        m_t0{std::clock()} {}

    auto s_used() const noexcept -> Time {
        static_cast<Time>(std::clock() - m_t0) / CLOCKS_PER_SEC;
    }

    auto ms_used() const noexcept -> Time {
        return s_used() * 1'000;
    }

    auto us_used() const noexcept -> Time {
        return s_used() * 1'000'000;
    }

    auto ns_used() const noexcept -> Time {
        return s_used() * 1'000'000'000;
    }

private:
    std::clock_t m_t0;
};

} // namespace muc::impl
#endif

#include <limits>
#include <type_traits>

namespace muc {

/// @brief CPU stopwatch better than std::clock() when available.
template<typename Time = double>
class cpu_time_stopwatch final : protected impl::cpu_time_stopwatch<Time> {
    static_assert(std::is_floating_point_v<Time>,
                  "the value type for stopwatch should be a floating point");
    static_assert(std::numeric_limits<Time>::digits >=
                      std::numeric_limits<double>::digits,
                  "stopwatch value type should be at least as long as double");

public:
    using value_type = Time;

public:
    auto s_used() const noexcept -> value_type {
        return impl::cpu_time_stopwatch<Time>::s_used();
    }

    auto ms_used() const noexcept -> value_type {
        return impl::cpu_time_stopwatch<Time>::ms_used();
    }

    auto us_used() const noexcept -> value_type {
        return impl::cpu_time_stopwatch<Time>::us_used();
    }

    auto ns_used() const noexcept -> value_type {
        return impl::cpu_time_stopwatch<Time>::ns_used();
    }
};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// Copyright (c) 2022, Matthew Bentley (mattreecebentley@gmail.com)
// www.plflib.org

// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgement in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.


// Linux/BSD implementation:
#if (defined linux or defined __linux__ or defined __linux) or             \
    (defined __DragonFly__ or defined __FreeBSD__ or defined __NetBSD__ or \
     defined __OpenBSD__)
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// Copyright (c) 2022, Matthew Bentley (mattreecebentley@gmail.com)
// www.plflib.org

// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgement in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.


#include <ctime>
#include <sys/time.h>

namespace muc::impl {

template<typename Time>
class wall_time_stopwatch {
public:
    wall_time_stopwatch() noexcept :
        m_t0{} {
        clock_gettime(CLOCK_MONOTONIC, &m_t0);
    }

    auto s_elapsed() const noexcept -> Time {
        return ns_elapsed() / 1'000'000'000;
    }

    auto ms_elapsed() const noexcept -> Time {
        return ns_elapsed() / 1'000'000;
    }

    auto us_elapsed() const noexcept -> Time {
        return ns_elapsed() / 1'000;
    }

    auto ns_elapsed() const noexcept -> Time {
        std::timespec t;
        clock_gettime(CLOCK_MONOTONIC, &t);
        return static_cast<Time>(t.tv_sec - m_t0.tv_sec) * 1'000'000'000 +
               static_cast<Time>(t.tv_nsec - m_t0.tv_nsec);
    }

private:
    std::timespec m_t0;
};

} // namespace muc::impl
// Windows implementation:
#elif defined _WIN32
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// Copyright (c) 2022, Matthew Bentley (mattreecebentley@gmail.com)
// www.plflib.org

// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgement in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.


#if defined _MSC_VER and not defined __clang__ and not defined __GNUC__ and \
    not defined NOMINMAX
#define NOMINMAX // Otherwise MS compilers act like idiots when using
                 // std::numeric_limits<>::max() and including windows.h
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#undef WIN32_LEAN_AND_MEAN
#else
#include <windows.h>
#endif

namespace muc::impl {

template<typename Time>
class wall_time_stopwatch {
public:
    wall_time_stopwatch() noexcept :
        m_frequency{},
        m_t0{} {
        QueryPerformanceFrequency(&m_frequency);
        QueryPerformanceCounter(&m_t0);
    }

    auto s_elapsed() const noexcept -> Time {
        LARGE_INTEGER t;
        QueryPerformanceCounter(&t);
        return static_cast<Time>(t.QuadPart - m_t0.QuadPart) /
               m_frequency.QuadPart;
    }

    auto ms_elapsed() const noexcept -> Time {
        return s_elapsed() * 1'000;
    }

    auto us_elapsed() const noexcept -> Time {
        return s_elapsed() * 1'000'000;
    }

    auto ns_elapsed() const noexcept -> Time {
        return s_elapsed() * 1'000'000'000;
    }

private:
    LARGE_INTEGER m_frequency;
    LARGE_INTEGER m_t0;
};

} // namespace muc::impl
// Fallback implementation:
#else
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <chrono>

namespace muc::impl {

template<typename Time>
class wall_time_stopwatch {
private:
    using sc = std::chrono::steady_clock;
    using s = std::chrono::duration<Time, std::ratio<1>>;
    using ms = std::chrono::duration<Time, std::milli>;
    using us = std::chrono::duration<Time, std::micro>;
    using ns = std::chrono::duration<Time, std::nano>;

public:
    wall_time_stopwatch() noexcept :
        m_t0{sc::now()} {}

    auto s_elapsed() const noexcept -> Time {
        s{sc::now() - m_t0}.count();
    }

    auto ms_elapsed() const noexcept -> Time {
        ms{sc::now() - m_t0}.count();
    }

    auto us_elapsed() const noexcept -> Time {
        us{sc::now() - m_t0}.count();
    }

    auto ns_elapsed() const noexcept -> Time {
        ns{sc::now() - m_t0}.count();
    }

private:
    sc::time_point m_t0;
};

} // namespace muc::impl
#endif

#include <limits>
#include <type_traits>

namespace muc {

/// @brief high-precision cross-platform (linux/bsd/windows/etc.) simple
/// stopwatch class
template<typename Time = double>
class wall_time_stopwatch : protected impl::wall_time_stopwatch<Time> {
    static_assert(std::is_floating_point_v<Time>,
                  "the value type for stopwatch should be a floating point");
    static_assert(std::numeric_limits<Time>::digits >=
                      std::numeric_limits<double>::digits,
                  "stopwatch value type should be at least as long as double");

public:
    using value_type = Time;

public:
    auto s_elapsed() const noexcept -> value_type {
        return impl::wall_time_stopwatch<Time>::s_elapsed();
    }

    auto ms_elapsed() const noexcept -> value_type {
        return impl::wall_time_stopwatch<Time>::ms_elapsed();
    }

    auto us_elapsed() const noexcept -> value_type {
        return impl::wall_time_stopwatch<Time>::us_elapsed();
    }

    auto ns_elapsed() const noexcept -> value_type {
        return impl::wall_time_stopwatch<Time>::ns_elapsed();
    }
};

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_TUPLE_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_TUPLE_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 202002L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <concepts>
#include <type_traits>
#include <utility>

namespace muc {

namespace impl {

template<typename T, std::size_t I>
concept has_tuple_element_and_get = requires(T t) {
    typename std::tuple_element_t<I, T>;
    { get<I>(t) } -> std::convertible_to<const std::tuple_element_t<I, T>&>;
};

} // namespace impl

template<typename T>
concept tuple_like = requires {
    requires not std::is_reference_v<T>;
    typename std::tuple_size<T>::type;
    requires std::derived_from<
        std::tuple_size<T>,
        std::integral_constant<std::size_t, std::tuple_size_v<T>>>;
    requires([]<std::size_t... Is>(std::index_sequence<Is...>) {
        return (... and impl::has_tuple_element_and_get<T, Is>);
    }(std::make_index_sequence<std::tuple_size_v<T>>()));
};

} // namespace muc

#include <functional>
#include <utility>

namespace muc {

namespace impl {

template<typename F, typename T, std::size_t... Is>
    requires tuple_like<std::decay_t<T>>
constexpr auto apply(F&& f, T&& t, std::index_sequence<Is...>) noexcept(
    noexcept(std::invoke(std::forward<F>(f),
                         get<Is>(std::forward<T>(t))...))) -> decltype(auto) {
    return std::invoke(std::forward<F>(f), get<Is>(std::forward<T>(t))...);
}

} // namespace impl

template<typename F, typename T>
    requires tuple_like<std::decay_t<T>>
constexpr auto apply(F&& f, T&& t) noexcept(noexcept(impl::apply(
    std::forward<F>(f), std::forward<T>(t),
    std::make_index_sequence<std::tuple_size_v<std::decay_t<T>>>{})))
    -> decltype(auto) {
    return impl::apply(
        std::forward<F>(f), std::forward<T>(t),
        std::make_index_sequence<std::tuple_size_v<std::decay_t<T>>>{});
}

} // namespace muc

#include <utility>

namespace muc {

template<typename F, typename T>
concept applicable_on = requires(F&& Func, T&& t) {
    requires tuple_like<T>;
    { apply(std::forward<F>(Func), std::forward<T>(t)) };
};

template<typename F, typename T>
concept predicate_applicable_on = requires(F&& Func, T&& t) {
    requires tuple_like<T>;
    { apply(std::forward<F>(Func), std::forward<T>(t)) } -> boolean_testable;
};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



namespace muc {

template<typename T>
concept pair_like = requires {
    requires tuple_like<T>;
    requires std::tuple_size_v<T> == 2;
};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <tuple>

namespace muc {

namespace impl {

template<tuple_like, std::size_t, std::size_t, tuple_like>
struct to_std_tuple_helper;

template<tuple_like T, std::size_t I, std::size_t N, typename... Ts>
struct to_std_tuple_helper<T, I, N, std::tuple<Ts...>> :
    to_std_tuple_helper<T, I + 1, N,
                        std::tuple<Ts..., std::tuple_element_t<I, T>>> {};

template<tuple_like T, std::size_t N, typename... Ts>
struct to_std_tuple_helper<T, N, N, std::tuple<Ts...>> {
    using type = std::tuple<Ts...>;
};

} // namespace impl

template<tuple_like T>
struct to_std_tuple :
    impl::to_std_tuple_helper<T, 0, std::tuple_size_v<T>, std::tuple<>> {};

template<tuple_like T>
using to_std_tuple_t = typename to_std_tuple<T>::type;

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <tuple>

namespace muc {

namespace impl {

template<tuple_like...>
struct std_tuple_concat;

template<>
struct std_tuple_concat<> {
    using type = std::tuple<>;
};

template<typename... Ts>
struct std_tuple_concat<std::tuple<Ts...>> {
    using type = std::tuple<Ts...>;
};

template<typename... Ts, typename... Us, typename... Vs>
struct std_tuple_concat<std::tuple<Ts...>, std::tuple<Us...>, Vs...> :
    std_tuple_concat<std::tuple<Ts..., Us...>, Vs...> {};

template<tuple_like... Ts>
using std_tuple_concat_t = typename std_tuple_concat<Ts...>::type;

} // namespace impl

template<tuple_like... Ts>
struct tuple_concat : impl::std_tuple_concat<to_std_tuple_t<Ts>...> {};

template<tuple_like... Ts>
using tuple_concat_t = typename tuple_concat<Ts...>::type;

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <concepts>
#include <tuple>
#include <type_traits>

namespace muc {

namespace impl {

template<tuple_like, typename>
struct std_tuple_count;

template<typename... Ts, typename T>
struct std_tuple_count<std::tuple<Ts...>, T> :
    std::integral_constant<std::size_t, (... + static_cast<std::size_t>(
                                                   std::same_as<T, Ts>))> {};

} // namespace impl

template<tuple_like T, typename U>
struct tuple_count : impl::std_tuple_count<to_std_tuple_t<T>, U> {};

template<tuple_like T, typename U>
inline constexpr auto tuple_count_v{tuple_count<T, U>::value};

} // namespace muc

#include <type_traits>

namespace muc {

template<tuple_like T, typename U>
struct tuple_contains :
    std::conditional_t<tuple_count_v<T, U> >= 1, std::true_type,
                       std::false_type> {};

template<tuple_like T, typename U>
inline constexpr auto tuple_contains_v = tuple_contains<T, U>::value;

template<tuple_like T, typename U>
struct tuple_contains_unique :
    std::conditional_t<tuple_count_v<T, U> == 1, std::true_type,
                       std::false_type> {};

template<tuple_like T, typename U>
inline constexpr auto tuple_contains_unique_v{
    tuple_contains_unique<T, U>::value};

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_TYPE_TRAITS_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_TYPE_TRAITS_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 202002L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <tuple>
#include <type_traits>

namespace muc {

template<typename... Ts>
struct is_type_set :
    std::bool_constant<(... and tuple_contains_unique_v<std::tuple<Ts...>, Ts>)> {
};

template<typename... Ts>
inline constexpr auto is_type_set_v = is_type_set<Ts...>::value;

} // namespace muc

#ifdef MUC_STATIC_TEST

static_assert(muc::is_type_set_v<>);
static_assert(muc::is_type_set_v<int>);
static_assert(muc::is_type_set_v<int, double>);
static_assert(not muc::is_type_set_v<int, int>);
static_assert(not muc::is_type_set_v<int, int, double>);

#endif
#endif

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#include <type_traits>
#include <utility>

namespace muc {

template<typename T, typename U>
struct is_arithmetic_operable_with :
    std::bool_constant<
        is_general_arithmetic_v<T> and is_general_arithmetic_v<U> and
        // T <-> {U}
        impl::has_binary_arithmetic_with_v<T, U> and
        impl::has_binary_arithmetic_with_v<
            T,
            decltype(std::declval<const U&>() + std::declval<const U&>())> and
        impl::has_binary_arithmetic_with_v<
            T,
            decltype(std::declval<const U&>() - std::declval<const U&>())> and
        /* impl::has_binary_arithmetic_with_v<
            U, decltype(+std::declval<const U&>())> and */
        impl::has_binary_arithmetic_with_v<
            U, decltype(-std::declval<const U&>())> and
        impl::has_binary_arithmetic_with_v<
            T, decltype(1 * std::declval<const U&>())> and
        /* impl::has_binary_arithmetic_with_v<
            T, decltype(std::declval<const U&>() * 1)> and
        impl::has_binary_arithmetic_with_v<
            T, decltype(std::declval<const U&>() / 1)> and */
        // T <-> {T <-> U}
        impl::has_binary_arithmetic_with_v<
            T,
            decltype(std::declval<const T&>() + std::declval<const U&>())> and
        impl::has_binary_arithmetic_with_v<
            T,
            decltype(std::declval<const T&>() - std::declval<const U&>())> and
        impl::has_binary_arithmetic_with_v<
            T,
            decltype(std::declval<const U&>() + std::declval<const T&>())> and
        impl::has_binary_arithmetic_with_v<
            T,
            decltype(std::declval<const U&>() - std::declval<const T&>())> and
        // U <-> {T}
        impl::has_binary_arithmetic_with_v<U, T> and
        impl::has_binary_arithmetic_with_v<
            U,
            decltype(std::declval<const T&>() + std::declval<const T&>())> and
        impl::has_binary_arithmetic_with_v<
            U,
            decltype(std::declval<const T&>() - std::declval<const T&>())> and
        /* impl::has_binary_arithmetic_with_v<
            U, decltype(+std::declval<const T&>())> and */
        impl::has_binary_arithmetic_with_v<
            U, decltype(-std::declval<const T&>())> and
        impl::has_binary_arithmetic_with_v<
            U, decltype(1 * std::declval<const T&>())> and
        /* impl::has_binary_arithmetic_with_v<
            U, decltype(std::declval<const T&>() * 1)> and
        impl::has_binary_arithmetic_with_v<
            U, decltype(std::declval<const T&>() / 1)> and */
        // U <-> {T <-> U}
        impl::has_binary_arithmetic_with_v<
            U,
            decltype(std::declval<const T&>() + std::declval<const U&>())> and
        impl::has_binary_arithmetic_with_v<
            U,
            decltype(std::declval<const T&>() - std::declval<const U&>())> and
        impl::has_binary_arithmetic_with_v<
            U,
            decltype(std::declval<const U&>() + std::declval<const T&>())> and
        impl::has_binary_arithmetic_with_v<
            U, decltype(std::declval<const U&>() - std::declval<const T&>())>> {
};

template<typename T, typename U>
inline constexpr bool is_arithmetic_operable_with_v{
    is_arithmetic_operable_with<T, U>::value};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <cstddef>
#include <type_traits>

namespace muc {

template<typename T>
struct is_bounded_array : std::false_type {};

template<typename T, std::size_t N>
struct is_bounded_array<T[N]> : std::true_type {};

template<typename T>
inline constexpr bool is_bounded_array_v{is_bounded_array<T>::value};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

template<typename T>
struct is_scoped_enum :
    std::bool_constant<
        std::is_enum_v<T> and
        not std::is_convertible_v<T, std::underlying_type_t<T>>> {};

template<typename T>
inline constexpr bool is_scoped_enum_v{is_scoped_enum<T>::value};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

template<class T>
struct is_unbounded_array : std::false_type {};

template<class T>
struct is_unbounded_array<T[]> : std::true_type {};

template<typename T>
inline constexpr bool is_unbounded_array_v{is_unbounded_array<T>::value};

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

template<typename T>
struct remove_cref : std::remove_const<std::remove_reference_t<T>> {};

template<typename T>
using remove_cref_t = typename remove_cref<T>::type;

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

template<typename T>
struct remove_cvref {
    using type = std::remove_cv_t<std::remove_reference_t<T>>;
};

template<typename T>
using remove_cvref_t = typename remove_cvref<T>::type;

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

template<typename T>
struct remove_vref : std::remove_volatile<std::remove_reference_t<T>> {};

template<typename T>
using remove_vref_t = typename remove_vref<T>::type;

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


namespace muc {

template<typename T>
struct type_identity {
    using type = T;
};

template<typename T>
using type_identity_t = typename type_identity<T>::type;

} // namespace muc
#endif

#endif
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef MUC_UTILITY_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768
#define MUC_UTILITY_35fd64e5dd5518762ebc391025fd06efd3f82687e245b5830b55c4a3ab96d768

#if __cplusplus >= 202002L
#endif

#if __cplusplus >= 201703L
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#if not __has_cpp_attribute(assume) and \
    not(defined __clang__ or defined __GNUC__ or defined _MSC_VER)
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#if __cplusplus >= 202002L // >= C++20
#include <version>
#ifdef __cpp_lib_unreachable // >= C++23
#define MUC_CPP_LIB_UNREACHABLE
#endif
#endif

#ifdef MUC_CPP_LIB_UNREACHABLE
#include <utility>
#endif

namespace muc {

[[noreturn]] inline auto unreachable() -> void {
#ifdef MUC_CPP_LIB_UNREACHABLE
    std::unreachable(); // C++23
#elif defined __clang__ or defined __GNUC__
    __builtin_unreachable();
#elif defined _MSC_VER
    __assume(false);
#endif
}

} // namespace muc

#undef MUC_CPP_LIB_UNREACHABLE
#endif

namespace muc {

constexpr auto assume(bool condition) noexcept -> void {
#if __has_cpp_attribute(assume)
    [[assume(condition)]]; // C++23
#elif defined __clang__
    __builtin_assume(condition);
#elif defined __GNUC__
    if (not condition) {
        __builtin_unreachable();
    }
#elif defined _MSC_VER
    __assume(condition);
#else
    if (not condition) {
        unreachable();
    }
#endif
}

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#if __cplusplus >= 202002L // >= C++20
#include <version>
#ifdef __cpp_lib_forward_like // >= C++23
#define MUC_CPP_LIB_FORWARD_LIKE
#endif
#endif

#include <utility>

#ifndef MUC_CPP_LIB_FORWARD_LIKE // backport
#include <type_traits>
#endif

namespace muc {

template<typename T, typename U>
[[nodiscard]] constexpr auto forward_like(U&& x) noexcept -> auto&& {
#ifdef MUC_CPP_LIB_FORWARD_LIKE // C++23
    return std::forward_like<T, U>(x);
#else // backport
    constexpr bool is_adding_const =
        std::is_const_v<std::remove_reference_t<T>>;
    if constexpr (std::is_lvalue_reference_v<T&&>) {
        if constexpr (is_adding_const) {
            return std::as_const(x);
        } else {
            return static_cast<U&>(x);
        }
    } else {
        if constexpr (is_adding_const) {
            return std::move(std::as_const(x));
        } else {
            return std::move(x);
        }
    }
#endif
}

} // namespace muc

#undef MUC_CPP_LIB_FORWARD_LIKE
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

template<typename T, std::enable_if_t<std::is_integral_v<T>, bool> = true>
constexpr auto to_signed(T k) -> std::make_signed_t<T> {
    return k;
}

} // namespace muc
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#if __cplusplus >= 202002L // >= C++20
#include <version>
#ifdef __cpp_lib_to_underlying // >= C++23
#define MUC_CPP_LIB_TO_UNDERLYING
#endif
#endif

#ifdef MUC_CPP_LIB_TO_UNDERLYING
#include <utility>
#else // backport
#include <type_traits>
#endif

namespace muc {

template<typename E>
constexpr auto to_underlying(E value) noexcept -> std::underlying_type_t<E> {
#ifdef MUC_CPP_LIB_TO_UNDERLYING
    return std::to_underlying<E>(value);
#else // backport
    return static_cast<typename std::underlying_type_t<E>>(value);
#endif
}

} // namespace muc

#undef MUC_CPP_LIB_TO_UNDERLYING
// -*- C++ -*-
//
// Copyright 2024  Shihan Zhao
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <type_traits>

namespace muc {

template<typename T, std::enable_if_t<std::is_integral_v<T>, bool> = true>
constexpr auto to_unsigned(T k) -> std::make_unsigned_t<T> {
    return k;
}

} // namespace muc
#endif

#endif
